global jpl_main
global _jpl_main
extern _fail_assertion
extern _jpl_alloc
extern _get_time
extern _show
extern _print
extern _print_time
extern _read_image
extern _write_image
extern _fmod
extern _sqrt
extern _exp
extern _sin
extern _cos
extern _tan
extern _asin
extern _acos
extern _atan
extern _log
extern _pow
extern _atan2
extern _to_int
extern _to_float

section .data
const0: dq 1
const1: dq 0
const2: db `non-positive loop bound`, 0
const3: db `overflow computing array size`, 0
const4: dq 908
const5: db `negative array index`, 0
const6: db `index too large`, 0
const7: dq 453
const8: db `b`, 0
const9: dq 25.45
const10: dq 492
const11: dq 90.17
const12: dq 916
const13: dq 900
const14: dq 394
const15: dq 94.3
const16: dq 12.95
const17: dq 21.47
const18: dq 60.62
const19: dq 83.35
const20: dq 73.93
const21: dq 994
const22: dq 87.39
const23: dq 598
const24: dq 69.07
const25: dq 18.12
const26: dq 723
const27: dq 486
const28: dq 520
const29: dq 75.42
const30: dq 43.26
const31: dq 53.05
const32: dq 6.62
const33: dq 383
const34: dq 301
const35: dq 365
const36: dq 45.14
const37: dq 96.41
const38: dq 826
const39: dq 32
const40: dq 572
const41: db `mod by zero`, 0
const42: dq 451
const43: dq 682
const44: dq 599
const45: dq 314
const46: dq 679
const47: dq 121
const48: dq 300
const49: dq 227
const50: dq 14.0
const51: dq 928
const52: dq 61
const53: dq 593
const54: dq 691
const55: dq 444
const56: dq 18.28
const57: db `divide by zero`, 0
const58: dq 938
const59: dq 395
const60: dq 764
const61: dq 88.53
const62: dq 48.7
const63: dq 36.82
const64: dq 244
const65: dq 75.54
const66: dq 63.89
const67: dq 44.2
const68: dq 48.65
const69: dq 44.86
const70: dq 620
const71: dq 282
const72: dq 178
const73: dq 553
const74: dq 152
const75: dq 827
const76: dq 13
const77: dq 573
const78: dq 58.36
const79: dq 345
const80: dq 436
const81: dq 57.12
const82: dq 366
const83: dq 991
const84: dq 102
const85: dq 1.32
const86: dq 70.04
const87: dq 22.93
const88: dq 99
const89: dq 41.38
const90: dq 404
const91: dq 724
const92: dq 92.11
const93: dq 623
const94: dq 92.18
const95: dq 2.33
const96: dq 592
const97: dq 744
const98: dq 22.22
const99: dq 99.96
const100: dq 80.18
const101: dq 75.47
const102: dq 36
const103: dq 8.2
const104: dq 64.56
const105: dq 99.87
const106: dq 99.95
const107: dq 8.95
const108: dq 64.96
const109: db `m`, 0
const110: dq 333
const111: dq 633
const112: dq 299
const113: dq 624
const114: dq 750
const115: dq 600
const116: dq 65.67
const117: dq 39.49
const118: dq 654
const119: dq 83
const120: dq 30.4
const121: dq 29.99
const122: dq 20
const123: dq 267
const124: dq 55.23

section .text
a:
_a:
	push rbp
	mov rbp, rsp
	push rdi
	mov rax, [rel const0] ; True
	push rax
	mov rax, [rel const1] ; False
	push rax
	pop rax
	pop r10
	cmp rax, r10
	setne al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump1
	sub rsp, 8
	; Moving 8 bytes from r12 - -16 to rsp
		mov r10, [r12 - -16 + 0]
		mov [rsp + 0], r10
	; Moving 8 bytes from rsp + 0 to rsp + 0
		mov r10, [rsp + 0 + 0]
		mov [rsp + 0 + 0], r10
	add rsp, 0
	jmp .jump2
.jump1:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for c
	sub rsp, 8
	; Moving 8 bytes from r12 - -16 to rsp
		mov r10, [r12 - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3
	sub rsp, 8 ; Align stack
	lea rdi, [rel const2] ; non-positive loop bound
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3:
	; Computing bound for b
	sub rsp, 8
	; Moving 8 bytes from r12 - -16 to rsp
		mov r10, [r12 - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump4
	lea rdi, [rel const2] ; non-positive loop bound
	call _fail_assertion
.jump4:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int
	imul rdi, [rsp + 0 + 0] ; multiply by argnum
	jno .jump5
	lea rdi, [rel const3] ; overflow computing array size
	call _fail_assertion
.jump5:
	imul rdi, [rsp + 0 + 8] ; multiply by argnum
	jno .jump6
	lea rdi, [rel const3] ; overflow computing array size
	call _fail_assertion
.jump6:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize c to 0
	mov rax, 0
	push rax
	; Initialize b to 0
	mov rax, 0
	push rax
.jump7: ; Begin body of loop
	; Compare c to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump9 ; If c >= bound, ...
	mov qword [rsp + 8], 0 ; c = 0
	add qword [rsp + 0], 1 ; b++
.jump9:
	; Compare b to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jge .jump8 ; If b >= bound, break
.jump10:
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment c
	add qword [rsp + 8], 1
	jmp .jump7
.jump8: ; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from r12 - -16 to rsp
		mov r10, [r12 - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const4] ; 908
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump11
	lea rdi, [rel const5] ; negative array index
	call _fail_assertion
.jump11:
	cmp rax, [rsp + 16]
	jl .jump12
	lea rdi, [rel const6] ; index too large
	call _fail_assertion
.jump12:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump13
	lea rdi, [rel const5] ; negative array index
	call _fail_assertion
.jump13:
	cmp rax, [rsp + 24]
	jl .jump14
	lea rdi, [rel const6] ; index too large
	call _fail_assertion
.jump14:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 8
	; Moving 8 bytes from rax to rsp
		mov r10, [rax + 0]
		mov [rsp + 0], r10
.jump2:
	pop rax
	neg rax
	push rax
	sub rsp, 32
	lea rdi, [rsp + 0]
	call _a
	; Moving 8 bytes from rsp + 8 to rsp + 24
		mov r10, [rsp + 8 + 0]
		mov [rsp + 24 + 0], r10
	add rsp, 24
	mov rax, [rel const7] ; 453
	push rax
	pop rax
	pop r10
	add rax, r10
	push rax
	pop rax
	pop r10
	cmp rax, r10
	setne al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	jne .jump15
	sub rsp, 8 ; Align stack
	lea rdi, [rel const8] ; b
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump15:
	mov rax, [rel const0] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump16
	sub rsp, 32
	sub rsp, 8 ; Align stack
	lea rdi, [rsp + 8]
	call _a
	add rsp, 8 ; Remove alignment
	jmp .jump17
.jump16:
	mov rax, [rel const0] ; True
	push rax
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump18
	mov rax, [rel const0] ; True
	push rax
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump20
	sub rsp, 32
	sub rsp, 8 ; Align stack
	lea rdi, [rsp + 8]
	call _a
	add rsp, 8 ; Remove alignment
	jmp .jump21
.jump20:
	sub rsp, 32
	sub rsp, 8 ; Align stack
	lea rdi, [rsp + 8]
	call _a
	add rsp, 8 ; Remove alignment
.jump21:
	jmp .jump19
.jump18:
	sub rsp, 32
	sub rsp, 8 ; Align stack
	lea rdi, [rsp + 8]
	call _a
	add rsp, 8 ; Remove alignment
.jump19:
.jump17:
	; Moving 32 bytes from rsp + 0 to rsp + 0
		mov r10, [rsp + 0 + 24]
		mov [rsp + 0 + 24], r10
		mov r10, [rsp + 0 + 16]
		mov [rsp + 0 + 16], r10
		mov r10, [rsp + 0 + 8]
		mov [rsp + 0 + 8], r10
		mov r10, [rsp + 0 + 0]
		mov [rsp + 0 + 0], r10
	add rsp, 0
	mov rax, [rbp - 8] ; Address to write return value into
	; Moving 32 bytes from rsp to rax
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 40 ; Local variables
	pop rbp
	ret
	sub rsp, 8 ; Align stack
	sub rsp, 8
	; Moving 8 bytes from r12 - -16 to rsp
		mov r10, [r12 - -16 + 0]
		mov [rsp + 0], r10
	pop rdi
	call _to_float
	add rsp, 8 ; Remove alignment
	sub rsp, 8
	movsd [rsp], xmm0
	sub rsp, 32
	lea rdi, [rsp + 0]
	call _a
	mov rax, [rel const9] ; 25.45
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	call _sqrt
	sub rsp, 8
	movsd [rsp], xmm0
	; Moving 8 bytes from rsp + 0 to rsp + 32
		mov r10, [rsp + 0 + 0]
		mov [rsp + 32 + 0], r10
	add rsp, 32
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmpltsd xmm1, xmm0
	movq rax, xmm1
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump22
	mov rax, [rel const1] ; False
	push rax
	pop rax
	xor rax, 1
	push rax
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	jne .jump24
	mov rax, [rel const10] ; 492
	push rax
	sub rsp, 8
	; Moving 8 bytes from r12 - -16 to rsp
		mov r10, [r12 - -16 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	sete al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	jne .jump25
	mov rax, [rel const0] ; True
	push rax
	pop rax
.jump25:
	push rax
	pop rax
.jump24:
	push rax
	mov rax, [rel const11] ; 90.17
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	call _to_int
	push rax
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for c
	mov rax, [rel const12] ; 916
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump26
	sub rsp, 8 ; Align stack
	lea rdi, [rel const2] ; non-positive loop bound
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump26:
	; Computing bound for b
	sub rsp, 8
	; Moving 8 bytes from r12 - -16 to rsp
		mov r10, [r12 - -16 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump27
	lea rdi, [rel const2] ; non-positive loop bound
	call _fail_assertion
.jump27:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize c to 0
	mov rax, 0
	push rax
	; Initialize b to 0
	mov rax, 0
	push rax
.jump28: ; Begin body of loop
	; Compare c to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump30 ; If c >= bound, ...
	mov qword [rsp + 8], 0 ; c = 0
	add qword [rsp + 0], 1 ; b++
.jump30:
	; Compare b to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jge .jump29 ; If b >= bound, break
.jump31:
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment c
	add qword [rsp + 8], 1
	jmp .jump28
.jump29: ; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	pop rax
	pop r10
	cmp rax, r10
	sete al
	and rax, 1
	push rax
	pop rax
	pop r10
	cmp rax, r10
	sete al
	and rax, 1
	push rax
	jmp .jump23
.jump22:
	mov rax, [rel const1] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump32
	mov rax, [rel const0] ; True
	push rax
	sub rsp, 16
	; Moving 16 bytes from r12 - -16 to rsp
		mov r10, [r12 - -16 + 8]
		mov [rsp + 8], r10
		mov r10, [r12 - -16 + 0]
		mov [rsp + 0], r10
	jmp .jump33
.jump32:
	mov rax, [rel const1] ; False
	push rax
	sub rsp, 16
	; Moving 16 bytes from r12 - -16 to rsp
		mov r10, [r12 - -16 + 8]
		mov [rsp + 8], r10
		mov r10, [r12 - -16 + 0]
		mov [rsp + 0], r10
.jump33:
	; Moving 8 bytes from rsp + 16 to rsp + 16
		mov r10, [rsp + 16 + 0]
		mov [rsp + 16 + 0], r10
	add rsp, 16
	mov rax, [rel const0] ; True
	push rax
	pop rax
	cmp rax, 0
	jne .jump34
	mov rax, [rel const1] ; False
	push rax
	pop rax
.jump34:
	push rax
	pop rax
	cmp rax, 0
	je .jump35
	mov rax, [rel const13] ; 900
	push rax
	sub rsp, 8
	; Moving 8 bytes from r12 - -16 to rsp
		mov r10, [r12 - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const14] ; 394
	push rax
	pop rax
	pop r10
	sub rax, r10
	push rax
	pop rax
	pop r10
	cmp rax, r10
	setl al
	and rax, 1
	push rax
	jmp .jump36
.jump35:
	mov rax, [rel const1] ; False
	push rax
	pop rax
	xor rax, 1
	push rax
	pop rax
	xor rax, 1
	push rax
.jump36:
	pop rax
	pop r10
	cmp rax, r10
	sete al
	and rax, 1
	push rax
.jump23:
	pop rax
	cmp rax, 0
	jne .jump37
	sub rsp, 8 ; Align stack
	lea rdi, [rel const8] ; b
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump37:
	sub rsp, 8 ; Align stack
	mov rax, [rel const15] ; 94.3
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	call _exp
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	call _sqrt
	add rsp, 8 ; Remove alignment
	sub rsp, 8
	movsd [rsp], xmm0
	mov rax, [rel const1] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump38
	mov rax, [rel const1] ; False
	push rax
	jmp .jump39
.jump38:
	mov rax, [rel const1] ; False
	push rax
.jump39:
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump40
	mov rax, [rel const0] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump42
	mov rax, [rel const1] ; False
	push rax
	jmp .jump43
.jump42:
	mov rax, [rel const0] ; True
	push rax
.jump43:
	pop rax
	cmp rax, 0
	je .jump44
	mov rax, [rel const16] ; 12.95
	push rax
	mov rax, [rel const17] ; 21.47
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	call _pow
	sub rsp, 8
	movsd [rsp], xmm0
	jmp .jump45
.jump44:
	sub rsp, 8
	; Moving 8 bytes from r12 - -16 to rsp
		mov r10, [r12 - -16 + 0]
		mov [rsp + 0], r10
	pop rdi
	call _to_float
	sub rsp, 8
	movsd [rsp], xmm0
.jump45:
	jmp .jump41
.jump40:
	mov rax, [rel const0] ; True
	push rax
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump46
	mov rax, [rel const18] ; 60.62
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	call _exp
	sub rsp, 8
	movsd [rsp], xmm0
	jmp .jump47
.jump46:
	mov rax, [rel const19] ; 83.35
	push rax
.jump47:
.jump41:
	movsd xmm0, [rsp]
	add rsp, 8
	call _asin
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmpltsd xmm0, xmm1
	movq rax, xmm0
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	jne .jump48
	sub rsp, 8 ; Align stack
	lea rdi, [rel const8] ; b
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump48:
	mov rax, [rel const1] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump49
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for b
	mov rax, [rel const20] ; 73.93
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	call _to_int
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump51
	sub rsp, 8 ; Align stack
	lea rdi, [rel const2] ; non-positive loop bound
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump51:
	; Computing total size of heap memory to allocate
	mov rdi, 0 ; sizeof {}
	imul rdi, [rsp + 0 + 0] ; multiply by to_int(73.93)
	jno .jump52
	sub rsp, 8 ; Align stack
	lea rdi, [rel const3] ; overflow computing array size
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump52:
	sub rsp, 8 ; Align stack
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize b to 0
	mov rax, 0
	push rax
.jump53: ; Begin body of loop
	; Compare b to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jge .jump54 ; If b >= bound, break
.jump55:
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for d
	mov rax, [rel const21] ; 994
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump56
	lea rdi, [rel const2] ; non-positive loop bound
	call _fail_assertion
.jump56:
	; Computing bound for c
	sub rsp, 8
	; Moving 8 bytes from r12 - -16 to rsp
		mov r10, [r12 - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump57
	sub rsp, 8 ; Align stack
	lea rdi, [rel const2] ; non-positive loop bound
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump57:
	; Computing total size of heap memory to allocate
	mov rdi, 0 ; sizeof {}
	imul rdi, [rsp + 0 + 0] ; multiply by argnum
	jno .jump58
	sub rsp, 8 ; Align stack
	lea rdi, [rel const3] ; overflow computing array size
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump58:
	imul rdi, [rsp + 0 + 8] ; multiply by 994
	jno .jump59
	sub rsp, 8 ; Align stack
	lea rdi, [rel const3] ; overflow computing array size
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump59:
	sub rsp, 8 ; Align stack
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize d to 0
	mov rax, 0
	push rax
	; Initialize c to 0
	mov rax, 0
	push rax
.jump60: ; Begin body of loop
	; Compare d to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump62 ; If d >= bound, ...
	mov qword [rsp + 8], 0 ; d = 0
	add qword [rsp + 0], 1 ; c++
.jump62:
	; Compare c to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jge .jump61 ; If c >= bound, break
.jump63:
	; Compute loop body
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 0
	add rax, [rsp + 32]
	; Move body (0 bytes) to index
	; Moving 0 bytes from rsp to rax
	add rsp, 0
	; Increment d
	add qword [rsp + 8], 1
	jmp .jump60
.jump61: ; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	sub rsp, 8 ; Align stack
	mov rax, [rel const22] ; 87.39
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	call _to_int
	add rsp, 8 ; Remove alignment
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 64 to rsp
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump64
	sub rsp, 8 ; Align stack
	lea rdi, [rel const5] ; negative array index
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump64:
	cmp rax, [rsp + 16]
	jl .jump65
	sub rsp, 8 ; Align stack
	lea rdi, [rel const6] ; index too large
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump65:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump66
	sub rsp, 8 ; Align stack
	lea rdi, [rel const5] ; negative array index
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump66:
	cmp rax, [rsp + 24]
	jl .jump67
	sub rsp, 8 ; Align stack
	lea rdi, [rel const6] ; index too large
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump67:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 0
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 0
	; Moving 0 bytes from rax to rsp
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 0
	add rax, [rsp + 16]
	; Move body (0 bytes) to index
	; Moving 0 bytes from rsp to rax
	add rsp, 0
	; Increment b
	add qword [rsp + 0], 1
	jmp .jump53
.jump54: ; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	jmp .jump50
.jump49:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for c
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for b
	mov rax, [rel const23] ; 598
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump68
	lea rdi, [rel const2] ; non-positive loop bound
	call _fail_assertion
.jump68:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize b to 0
	mov rax, 0
	push rax
.jump69: ; Begin body of loop
	; Compare b to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jge .jump70 ; If b >= bound, break
.jump71:
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment b
	add qword [rsp + 0], 1
	jmp .jump69
.jump70: ; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump72
	sub rsp, 8 ; Align stack
	lea rdi, [rel const2] ; non-positive loop bound
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump72:
	; Computing bound for b
	sub rsp, 8
	; Moving 8 bytes from r12 - -16 to rsp
		mov r10, [r12 - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump73
	lea rdi, [rel const2] ; non-positive loop bound
	call _fail_assertion
.jump73:
	; Computing total size of heap memory to allocate
	mov rdi, 16 ; sizeof {}[]
	imul rdi, [rsp + 0 + 0] ; multiply by argnum
	jno .jump74
	lea rdi, [rel const3] ; overflow computing array size
	call _fail_assertion
.jump74:
imul rdi, [rsp + 0 + 8] ; multiply by (sum[b : 598] b)
	jno .jump75
	lea rdi, [rel const3] ; overflow computing array size
	call _fail_assertion
.jump75:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize c to 0
	mov rax, 0
	push rax
	; Initialize b to 0
	mov rax, 0
	push rax
.jump76: ; Begin body of loop
	; Compare c to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump78 ; If c >= bound, ...
	mov qword [rsp + 8], 0 ; c = 0
	add qword [rsp + 0], 1 ; b++
.jump78:
	; Compare b to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jge .jump77 ; If b >= bound, break
.jump79:
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for d
	sub rsp, 8
	; Moving 8 bytes from r12 - -16 to rsp
		mov r10, [r12 - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump80
	lea rdi, [rel const2] ; non-positive loop bound
	call _fail_assertion
.jump80:
	; Computing total size of heap memory to allocate
	mov rdi, 0 ; sizeof {}
	imul rdi, [rsp + 0 + 0] ; multiply by argnum
	jno .jump81
	lea rdi, [rel const3] ; overflow computing array size
	call _fail_assertion
.jump81:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize d to 0
	mov rax, 0
	push rax
.jump82: ; Begin body of loop
	; Compare d to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jge .jump83 ; If d >= bound, break
.jump84:
	; Compute loop body
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 0
	add rax, [rsp + 16]
	; Move body (0 bytes) to index
	; Moving 0 bytes from rsp to rax
	add rsp, 0
	; Increment d
	add qword [rsp + 0], 1
	jmp .jump82
.jump83: ; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 16
	add rax, [rsp + 48]
	; Move body (16 bytes) to index
	; Moving 16 bytes from rsp to rax
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 16
	; Increment c
	add qword [rsp + 8], 1
	jmp .jump76
.jump77: ; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	mov rax, [rel const0] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump85
	mov rax, [rel const24] ; 69.07
	push rax
	jmp .jump86
.jump85:
	mov rax, [rel const25] ; 18.12
	push rax
.jump86:
	movsd xmm0, [rsp]
	add rsp, 8
	call _to_int
	push rax
	mov rax, [rel const26] ; 723
	push rax
	mov rax, [rel const27] ; 486
	push rax
	sub rsp, 8
	; Moving 8 bytes from r12 - -16 to rsp
		mov r10, [r12 - -16 + 0]
		mov [rsp + 0], r10
	mov rdi, 24
	call _jpl_alloc
	; Moving 24 bytes from rsp to rax
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 24
	push rax
	mov rax, 3
	push rax
	mov rax, [rel const28] ; 520
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump87
	lea rdi, [rel const5] ; negative array index
	call _fail_assertion
.jump87:
	cmp rax, [rsp + 8]
	jl .jump88
	lea rdi, [rel const6] ; index too large
	call _fail_assertion
.jump88:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump89
	lea rdi, [rel const5] ; negative array index
	call _fail_assertion
.jump89:
	cmp rax, [rsp + 16]
	jl .jump90
	lea rdi, [rel const6] ; index too large
	call _fail_assertion
.jump90:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump91
	lea rdi, [rel const5] ; negative array index
	call _fail_assertion
.jump91:
	cmp rax, [rsp + 24]
	jl .jump92
	lea rdi, [rel const6] ; index too large
	call _fail_assertion
.jump92:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 16
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 16
	; Moving 16 bytes from rax to rsp
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
.jump50:
	sub rsp, 8 ; Align stack
	mov rax, [rel const29] ; 75.42
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	call _to_int
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rel const30] ; 43.26
	push rax
	mov rax, [rbp - 8] ; Address to write return value into
	; Moving 32 bytes from rsp to rax
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 72 ; Local variables
	pop rbp
	ret

b:
_b:
	push rbp
	mov rbp, rsp
	push rdi
	sub rsp, 8 ; Align stack
	mov rax, [rel const31] ; 53.05
	push rax
	sub rsp, 32
	sub rsp, 8 ; Align stack
	lea rdi, [rsp + 8]
	call _a
	add rsp, 8 ; Remove alignment
	; Moving 8 bytes from rsp + 0 to rsp + 24
		mov r10, [rsp + 0 + 0]
		mov [rsp + 24 + 0], r10
	add rsp, 24
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	call _atan2
	sub rsp, 8
	movsd [rsp], xmm0
	mov rax, [rel const32] ; 6.62
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	call _atan2
	sub rsp, 8
	movsd [rsp], xmm0
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for e
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for d
	mov rax, [rel const33] ; 383
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump93
	lea rdi, [rel const2] ; non-positive loop bound
	call _fail_assertion
.jump93:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize d to 0
	mov rax, 0
	push rax
.jump94: ; Begin body of loop
	; Compare d to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jge .jump95 ; If d >= bound, break
.jump96:
	; Compute loop body
	mov rax, [rel const34] ; 301
	push rax
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment d
	add qword [rsp + 0], 1
	jmp .jump94
.jump95: ; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump97
	sub rsp, 8 ; Align stack
	lea rdi, [rel const2] ; non-positive loop bound
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump97:
	; Computing bound for d
	mov rax, [rel const35] ; 365
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump98
	lea rdi, [rel const2] ; non-positive loop bound
	call _fail_assertion
.jump98:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize e to 0
	mov rax, 0
	push rax
	; Initialize d to 0
	mov rax, 0
	push rax
.jump99: ; Begin body of loop
	; Compare e to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump101 ; If e >= bound, ...
	mov qword [rsp + 8], 0 ; e = 0
	add qword [rsp + 0], 1 ; d++
.jump101:
	; Compare d to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jge .jump100 ; If d >= bound, break
.jump102:
	; Compute loop body
	mov rax, [rel const36] ; 45.14
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	call _cos
	sub rsp, 8
	movsd [rsp], xmm0
	sub rsp, 8 ; Align stack
	mov rax, [rel const37] ; 96.41
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	call _log
	add rsp, 8 ; Remove alignment
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	call _atan2
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp + 32] ; Load sum
	addsd xmm0, xmm1 ; Add loop body
	movsd [rsp + 32], xmm0 ; Save sum
	; Increment e
	add qword [rsp + 8], 1
	jmp .jump99
.jump100: ; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	call _pow
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	call _sqrt
	add rsp, 8 ; Remove alignment
	sub rsp, 8
	movsd [rsp], xmm0
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for g
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for e
	mov rax, [rel const38] ; 826
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump103
	sub rsp, 8 ; Align stack
	lea rdi, [rel const2] ; non-positive loop bound
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump103:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof {int}
	imul rdi, [rsp + 0 + 0] ; multiply by 826
	jno .jump104
	sub rsp, 8 ; Align stack
	lea rdi, [rel const3] ; overflow computing array size
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump104:
	sub rsp, 8 ; Align stack
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize e to 0
	mov rax, 0
	push rax
.jump105: ; Begin body of loop
	; Compare e to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jge .jump106 ; If e >= bound, break
.jump107:
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - -16 to rsp
		mov r10, [r12 - -16 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 24]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment e
	add qword [rsp + 0], 1
	jmp .jump105
.jump106: ; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	sub rsp, 8 ; Align stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 8 to rsp
		mov r10, [rbp - 8 + 0]
		mov [rsp + 0], r10
	pop rdi
	call _b
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump108
	lea rdi, [rel const5] ; negative array index
	call _fail_assertion
.jump108:
	cmp rax, [rsp + 8]
	jl .jump109
	lea rdi, [rel const6] ; index too large
	call _fail_assertion
.jump109:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	; Moving 8 bytes from rsp + 0 to rsp + 0
		mov r10, [rsp + 0 + 0]
		mov [rsp + 0 + 0], r10
	add rsp, 0
	mov rax, [rsp]
	cmp rax, 0
	jg .jump110
	lea rdi, [rel const2] ; non-positive loop bound
	call _fail_assertion
.jump110:
	; Computing bound for f
	sub rsp, 8
	; Moving 8 bytes from r12 - -16 to rsp
		mov r10, [r12 - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const39] ; 32
	push rax
	mov rax, [rel const40] ; 572
	push rax
	pop rax
	pop r10
	cmp r10, 0
	jne .jump111
	sub rsp, 8 ; Align stack
	lea rdi, [rel const41] ; mod by zero
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump111:
	cqo
	idiv r10
	mov rax, rdx
	push rax
	pop rax
	pop r10
	imul rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump112
	sub rsp, 8 ; Align stack
	lea rdi, [rel const2] ; non-positive loop bound
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump112:
	; Computing bound for e
	sub rsp, 8 ; Align stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	movsd xmm0, [rsp]
	add rsp, 8
	call _asin
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	call _to_int
	add rsp, 8 ; Remove alignment
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	movsd xmm0, [rsp]
	add rsp, 8
	call _asin
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	call _to_int
	push rax
	pop rax
	pop r10
	cmp rax, r10
	setle al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump113
	sub rsp, 8 ; Align stack
	sub rsp, 8
	; Moving 8 bytes from r12 - -16 to rsp
		mov r10, [r12 - -16 + 0]
		mov [rsp + 0], r10
	pop rdi
	call _to_float
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	call _to_int
	add rsp, 8 ; Remove alignment
	push rax
	jmp .jump114
.jump113:
	mov rax, [rel const0] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump115
	mov rax, [rel const0] ; True
	push rax
	jmp .jump116
.jump115:
	sub rsp, 8
	; Moving 8 bytes from rbp - 8 to rsp
		mov r10, [rbp - 8 + 0]
		mov [rsp + 0], r10
.jump116:
	pop rax
	cmp rax, 0
	je .jump117
	mov rax, [rel const42] ; 451
	push rax
	jmp .jump118
.jump117:
	sub rsp, 8
	; Moving 8 bytes from r12 - -16 to rsp
		mov r10, [r12 - -16 + 0]
		mov [rsp + 0], r10
.jump118:
	; Moving 8 bytes from rsp + 0 to rsp + 0
		mov r10, [rsp + 0 + 0]
		mov [rsp + 0 + 0], r10
	add rsp, 0
.jump114:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump119
	lea rdi, [rel const2] ; non-positive loop bound
	call _fail_assertion
.jump119:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof float
	imul rdi, [rsp + 0 + 0] ; multiply by (if (to_int(asin(d)) <= to_int(asin(d))) then to_int((- to_float(argnum))) else (if (if true then true else c) then {451} else {argnum}){0})
	jno .jump120
	lea rdi, [rel const3] ; overflow computing array size
	call _fail_assertion
.jump120:
	imul rdi, [rsp + 0 + 8] ; multiply by ((572 % 32) * argnum)
	jno .jump121
	lea rdi, [rel const3] ; overflow computing array size
	call _fail_assertion
.jump121:
imul rdi, [rsp + 0 + 16] ; multiply by (array[e : 826] {argnum})[b(c)]{0}
	jno .jump122
	lea rdi, [rel const3] ; overflow computing array size
	call _fail_assertion
.jump122:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize g to 0
	mov rax, 0
	push rax
	; Initialize f to 0
	mov rax, 0
	push rax
	; Initialize e to 0
	mov rax, 0
	push rax
.jump123: ; Begin body of loop
	; Compare g to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump125 ; If g >= bound, ...
	mov qword [rsp + 16], 0 ; g = 0
	add qword [rsp + 8], 1 ; f++
.jump125:
	; Compare f to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump126 ; If f >= bound, ...
	mov qword [rsp + 8], 0 ; f = 0
	add qword [rsp + 0], 1 ; e++
.jump126:
	; Compare e to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jge .jump124 ; If e >= bound, break
.jump127:
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for j
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump128
	sub rsp, 8 ; Align stack
	lea rdi, [rel const2] ; non-positive loop bound
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump128:
	; Computing bound for i
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump129
	lea rdi, [rel const2] ; non-positive loop bound
	call _fail_assertion
.jump129:
	; Computing bound for h
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for j
	sub rsp, 8
	; Moving 8 bytes from rbp - 64 to rsp
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump130
	lea rdi, [rel const2] ; non-positive loop bound
	call _fail_assertion
.jump130:
	; Computing bound for i
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump131
	sub rsp, 8 ; Align stack
	lea rdi, [rel const2] ; non-positive loop bound
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump131:
	; Computing bound for h
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump132
	lea rdi, [rel const2] ; non-positive loop bound
	call _fail_assertion
.jump132:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize j to 0
	mov rax, 0
	push rax
	; Initialize i to 0
	mov rax, 0
	push rax
	; Initialize h to 0
	mov rax, 0
	push rax
.jump133: ; Begin body of loop
	; Compare j to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump135 ; If j >= bound, ...
	mov qword [rsp + 16], 0 ; j = 0
	add qword [rsp + 8], 1 ; i++
.jump135:
	; Compare i to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump136 ; If i >= bound, ...
	mov qword [rsp + 8], 0 ; i = 0
	add qword [rsp + 0], 1 ; h++
.jump136:
	; Compare h to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jge .jump134 ; If h >= bound, break
.jump137:
	; Compute loop body
	sub rsp, 16
	; Moving 16 bytes from r12 - -16 to rsp
		mov r10, [r12 - -16 + 8]
		mov [rsp + 8], r10
		mov r10, [r12 - -16 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump138
	lea rdi, [rel const5] ; negative array index
	call _fail_assertion
.jump138:
	cmp rax, [rsp + 8]
	jl .jump139
	lea rdi, [rel const6] ; index too large
	call _fail_assertion
.jump139:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment j
	add qword [rsp + 16], 1
	jmp .jump133
.jump134: ; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump140
	sub rsp, 8 ; Align stack
	lea rdi, [rel const2] ; non-positive loop bound
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump140:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof float
imul rdi, [rsp + 0 + 0] ; multiply by (sum[h : e, i : e, j : f] args[e])
	jno .jump141
	sub rsp, 8 ; Align stack
	lea rdi, [rel const3] ; overflow computing array size
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump141:
	imul rdi, [rsp + 0 + 8] ; multiply by g
	jno .jump142
	sub rsp, 8 ; Align stack
	lea rdi, [rel const3] ; overflow computing array size
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump142:
	imul rdi, [rsp + 0 + 16] ; multiply by e
	jno .jump143
	sub rsp, 8 ; Align stack
	lea rdi, [rel const3] ; overflow computing array size
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump143:
	sub rsp, 8 ; Align stack
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize j to 0
	mov rax, 0
	push rax
	; Initialize i to 0
	mov rax, 0
	push rax
	; Initialize h to 0
	mov rax, 0
	push rax
.jump144: ; Begin body of loop
	; Compare j to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump146 ; If j >= bound, ...
	mov qword [rsp + 16], 0 ; j = 0
	add qword [rsp + 8], 1 ; i++
.jump146:
	; Compare i to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump147 ; If i >= bound, ...
	mov qword [rsp + 8], 0 ; i = 0
	add qword [rsp + 0], 1 ; h++
.jump147:
	; Compare h to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jge .jump145 ; If h >= bound, break
.jump148:
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 120 to rsp
		mov r10, [rbp - 120 + 0]
		mov [rsp + 0], r10
	pop rdi
	call _to_float
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	call _atan
	sub rsp, 8
	movsd [rsp], xmm0
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment j
	add qword [rsp + 16], 1
	jmp .jump144
.jump145: ; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for h
	mov rax, [rel const43] ; 682
	push rax
	pop rdi
	call _to_float
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	call _to_int
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump149
	sub rsp, 8 ; Align stack
	lea rdi, [rel const2] ; non-positive loop bound
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump149:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize h to 0
	mov rax, 0
	push rax
.jump150: ; Begin body of loop
	; Compare h to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jge .jump151 ; If h >= bound, break
.jump152:
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 64 to rsp
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment h
	add qword [rsp + 0], 1
	jmp .jump150
.jump151: ; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	sub rsp, 8
	; Moving 8 bytes from r12 - -16 to rsp
		mov r10, [r12 - -16 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 64 to rsp
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump153
	lea rdi, [rel const5] ; negative array index
	call _fail_assertion
.jump153:
	cmp rax, [rsp + 24]
	jl .jump154
	lea rdi, [rel const6] ; index too large
	call _fail_assertion
.jump154:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump155
	lea rdi, [rel const5] ; negative array index
	call _fail_assertion
.jump155:
	cmp rax, [rsp + 32]
	jl .jump156
	lea rdi, [rel const6] ; index too large
	call _fail_assertion
.jump156:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump157
	lea rdi, [rel const5] ; negative array index
	call _fail_assertion
.jump157:
	cmp rax, [rsp + 40]
	jl .jump158
	lea rdi, [rel const6] ; index too large
	call _fail_assertion
.jump158:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 8
	; Moving 8 bytes from rax to rsp
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment g
	add qword [rsp + 16], 1
	jmp .jump123
.jump124: ; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	sub rsp, 32
	lea rdi, [rsp + 0]
	call _a
	; Moving 8 bytes from rsp + 8 to rsp + 24
		mov r10, [rsp + 8 + 0]
		mov [rsp + 24 + 0], r10
	add rsp, 24
	pop rax
	neg rax
	push rax
	pop rax
	add rsp, 48 ; Local variables
	pop rbp
	ret
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for k
	sub rsp, 8
	; Moving 8 bytes from r12 - -16 to rsp
		mov r10, [r12 - -16 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump159
	lea rdi, [rel const2] ; non-positive loop bound
	call _fail_assertion
.jump159:
	; Computing bound for j
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for j
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump160
	lea rdi, [rel const2] ; non-positive loop bound
	call _fail_assertion
.jump160:
	; Computing bound for i
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const44] ; 599
	push rax
	pop rax
	pop r10
	sub rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump161
	sub rsp, 8 ; Align stack
	lea rdi, [rel const2] ; non-positive loop bound
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump161:
	; Computing total size of heap memory to allocate
	mov rdi, 16 ; sizeof int[]
	imul rdi, [rsp + 0 + 0] ; multiply by (599 - g)
	jno .jump162
	sub rsp, 8 ; Align stack
	lea rdi, [rel const3] ; overflow computing array size
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump162:
	imul rdi, [rsp + 0 + 8] ; multiply by h
	jno .jump163
	sub rsp, 8 ; Align stack
	lea rdi, [rel const3] ; overflow computing array size
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump163:
	sub rsp, 8 ; Align stack
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize j to 0
	mov rax, 0
	push rax
	; Initialize i to 0
	mov rax, 0
	push rax
.jump164: ; Begin body of loop
	; Compare j to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump166 ; If j >= bound, ...
	mov qword [rsp + 8], 0 ; j = 0
	add qword [rsp + 0], 1 ; i++
.jump166:
	; Compare i to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jge .jump165 ; If i >= bound, break
.jump167:
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for k
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump168
	sub rsp, 8 ; Align stack
	lea rdi, [rel const2] ; non-positive loop bound
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump168:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int
	imul rdi, [rsp + 0 + 0] ; multiply by j
	jno .jump169
	sub rsp, 8 ; Align stack
	lea rdi, [rel const3] ; overflow computing array size
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump169:
	sub rsp, 8 ; Align stack
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize k to 0
	mov rax, 0
	push rax
.jump170: ; Begin body of loop
	; Compare k to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jge .jump171 ; If k >= bound, break
.jump172:
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 24]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment k
	add qword [rsp + 0], 1
	jmp .jump170
.jump171: ; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 16
	add rax, [rsp + 48]
	; Move body (16 bytes) to index
	; Moving 16 bytes from rsp to rax
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 16
	; Increment j
	add qword [rsp + 8], 1
	jmp .jump164
.jump165: ; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	movsd xmm0, [rsp]
	add rsp, 8
	call _to_int
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump173
	sub rsp, 8 ; Align stack
	lea rdi, [rel const5] ; negative array index
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump173:
	cmp rax, [rsp + 16]
	jl .jump174
	sub rsp, 8 ; Align stack
	lea rdi, [rel const6] ; index too large
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump174:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump175
	sub rsp, 8 ; Align stack
	lea rdi, [rel const5] ; negative array index
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump175:
	cmp rax, [rsp + 24]
	jl .jump176
	sub rsp, 8 ; Align stack
	lea rdi, [rel const6] ; index too large
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump176:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 16
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 16
	; Moving 16 bytes from rax to rsp
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump177
	sub rsp, 8 ; Align stack
	lea rdi, [rel const5] ; negative array index
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump177:
	cmp rax, [rsp + 8]
	jl .jump178
	sub rsp, 8 ; Align stack
	lea rdi, [rel const6] ; index too large
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump178:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump179
	sub rsp, 8 ; Align stack
	lea rdi, [rel const2] ; non-positive loop bound
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump179:
	; Computing bound for i
	sub rsp, 8
	; Moving 8 bytes from r12 - -16 to rsp
		mov r10, [r12 - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump180
	lea rdi, [rel const2] ; non-positive loop bound
	call _fail_assertion
.jump180:
	; Computing total size of heap memory to allocate
	mov rdi, 16 ; sizeof int[]
	imul rdi, [rsp + 0 + 0] ; multiply by argnum
	jno .jump181
	lea rdi, [rel const3] ; overflow computing array size
	call _fail_assertion
.jump181:
imul rdi, [rsp + 0 + 8] ; multiply by (array[i : (599 - g), j : h] (array[k : j] g))[to_int(d), g][g]
	jno .jump182
	lea rdi, [rel const3] ; overflow computing array size
	call _fail_assertion
.jump182:
	imul rdi, [rsp + 0 + 16] ; multiply by (- argnum)
	jno .jump183
	lea rdi, [rel const3] ; overflow computing array size
	call _fail_assertion
.jump183:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize k to 0
	mov rax, 0
	push rax
	; Initialize j to 0
	mov rax, 0
	push rax
	; Initialize i to 0
	mov rax, 0
	push rax
.jump184: ; Begin body of loop
	; Compare k to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump186 ; If k >= bound, ...
	mov qword [rsp + 16], 0 ; k = 0
	add qword [rsp + 8], 1 ; j++
.jump186:
	; Compare j to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump187 ; If j >= bound, ...
	mov qword [rsp + 8], 0 ; j = 0
	add qword [rsp + 0], 1 ; i++
.jump187:
	; Compare i to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jge .jump185 ; If i >= bound, break
.jump188:
	; Compute loop body
	sub rsp, 16
	; Moving 16 bytes from r12 - -16 to rsp
		mov r10, [r12 - -16 + 8]
		mov [rsp + 8], r10
		mov r10, [r12 - -16 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 16
	add rax, [rsp + 64]
	; Move body (16 bytes) to index
	; Moving 16 bytes from rsp to rax
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 16
	; Increment k
	add qword [rsp + 16], 1
	jmp .jump184
.jump185: ; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 8 to rsp
		mov r10, [rbp - 8 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump189
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	sub rsp, 8 ; Align stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	movsd xmm0, [rsp]
	add rsp, 8
	call _cos
	add rsp, 8 ; Remove alignment
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmpneqsd xmm0, xmm1
	movq rax, xmm0
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump191
	mov rax, [rel const1] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump193
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	jmp .jump194
.jump193:
	sub rsp, 8
	; Moving 8 bytes from r12 - -16 to rsp
		mov r10, [r12 - -16 + 0]
		mov [rsp + 0], r10
.jump194:
	jmp .jump192
.jump191:
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	add rax, r10
	push rax
.jump192:
	jmp .jump190
.jump189:
	mov rax, [rel const1] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump195
	mov rax, [rel const0] ; True
	push rax
	mov rax, [rel const0] ; True
	push rax
	pop rax
	pop r10
	cmp rax, r10
	setne al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump197
	sub rsp, 8
	; Moving 8 bytes from rbp - 64 to rsp
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
	jmp .jump198
.jump197:
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
.jump198:
	jmp .jump196
.jump195:
	mov rax, [rel const45] ; 314
	push rax
	pop rax
	neg rax
	push rax
.jump196:
.jump190:
	; Moving 8 bytes from rsp + 0 to rsp + 0
		mov r10, [rsp + 0 + 0]
		mov [rsp + 0 + 0], r10
	add rsp, 0
	pop rax
	add rsp, 80 ; Local variables
	pop rbp
	ret

d:
_d:
	push rbp
	mov rbp, rsp
	push rdi
	push rsi
	sub rsp, 8
	movsd [rsp], xmm0
	sub rsp, 8 ; Align stack
	mov rax, [rel const50] ; 14.0
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	call _cos
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	call _tan
	add rsp, 8 ; Remove alignment
	sub rsp, 8
	movsd [rsp], xmm0
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmpneqsd xmm0, xmm1
	movq rax, xmm0
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump202
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump204
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for h
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	movsd xmm0, [rsp]
	add rsp, 8
	call _to_int
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump206
	sub rsp, 8 ; Align stack
	lea rdi, [rel const2] ; non-positive loop bound
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump206:
	; Computing bound for g
	mov rax, [rel const51] ; 928
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump207
	lea rdi, [rel const2] ; non-positive loop bound
	call _fail_assertion
.jump207:
	; Computing total size of heap memory to allocate
	mov rdi, 0 ; sizeof {{}}
	imul rdi, [rsp + 0 + 0] ; multiply by 928
	jno .jump208
	lea rdi, [rel const3] ; overflow computing array size
	call _fail_assertion
.jump208:
	imul rdi, [rsp + 0 + 8] ; multiply by to_int(f)
	jno .jump209
	lea rdi, [rel const3] ; overflow computing array size
	call _fail_assertion
.jump209:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize h to 0
	mov rax, 0
	push rax
	; Initialize g to 0
	mov rax, 0
	push rax
.jump210: ; Begin body of loop
	; Compare h to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump212 ; If h >= bound, ...
	mov qword [rsp + 8], 0 ; h = 0
	add qword [rsp + 0], 1 ; g++
.jump212:
	; Compare g to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jge .jump211 ; If g >= bound, break
.jump213:
	; Compute loop body
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 0
	add rax, [rsp + 32]
	; Move body (0 bytes) to index
	; Moving 0 bytes from rsp to rax
	add rsp, 0
	; Increment h
	add qword [rsp + 8], 1
	jmp .jump210
.jump211: ; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	jmp .jump205
.jump204:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for h
	mov rax, [rel const52] ; 61
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	sub rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump214
	sub rsp, 8 ; Align stack
	lea rdi, [rel const2] ; non-positive loop bound
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump214:
	; Computing bound for g
	mov rax, [rel const53] ; 593
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump215
	lea rdi, [rel const2] ; non-positive loop bound
	call _fail_assertion
.jump215:
	; Computing total size of heap memory to allocate
	mov rdi, 0 ; sizeof {{}}
	imul rdi, [rsp + 0 + 0] ; multiply by 593
	jno .jump216
	lea rdi, [rel const3] ; overflow computing array size
	call _fail_assertion
.jump216:
	imul rdi, [rsp + 0 + 8] ; multiply by (e - 61)
	jno .jump217
	lea rdi, [rel const3] ; overflow computing array size
	call _fail_assertion
.jump217:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize h to 0
	mov rax, 0
	push rax
	; Initialize g to 0
	mov rax, 0
	push rax
.jump218: ; Begin body of loop
	; Compare h to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump220 ; If h >= bound, ...
	mov qword [rsp + 8], 0 ; h = 0
	add qword [rsp + 0], 1 ; g++
.jump220:
	; Compare g to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jge .jump219 ; If g >= bound, break
.jump221:
	; Compute loop body
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 0
	add rax, [rsp + 32]
	; Move body (0 bytes) to index
	; Moving 0 bytes from rsp to rax
	add rsp, 0
	; Increment h
	add qword [rsp + 8], 1
	jmp .jump218
.jump219: ; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
.jump205:
	jmp .jump203
.jump202:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for h
	mov rax, [rel const54] ; 691
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump222
	sub rsp, 8 ; Align stack
	lea rdi, [rel const2] ; non-positive loop bound
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump222:
	; Computing bound for g
	mov rax, [rel const55] ; 444
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump223
	lea rdi, [rel const2] ; non-positive loop bound
	call _fail_assertion
.jump223:
	; Computing total size of heap memory to allocate
	mov rdi, 0 ; sizeof {{}}
	imul rdi, [rsp + 0 + 0] ; multiply by 444
	jno .jump224
	lea rdi, [rel const3] ; overflow computing array size
	call _fail_assertion
.jump224:
	imul rdi, [rsp + 0 + 8] ; multiply by 691
	jno .jump225
	lea rdi, [rel const3] ; overflow computing array size
	call _fail_assertion
.jump225:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize h to 0
	mov rax, 0
	push rax
	; Initialize g to 0
	mov rax, 0
	push rax
.jump226: ; Begin body of loop
	; Compare h to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump228 ; If h >= bound, ...
	mov qword [rsp + 8], 0 ; h = 0
	add qword [rsp + 0], 1 ; g++
.jump228:
	; Compare g to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jge .jump227 ; If g >= bound, break
.jump229:
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump230
	jmp .jump231
.jump230:
.jump231:
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 0
	add rax, [rsp + 32]
	; Move body (0 bytes) to index
	; Moving 0 bytes from rsp to rax
	add rsp, 0
	; Increment h
	add qword [rsp + 8], 1
	jmp .jump226
.jump227: ; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
.jump203:
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for i
	mov rax, [rel const56] ; 18.28
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmpltsd xmm0, xmm1
	movq rax, xmm0
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump232
	sub rsp, 8
	; Moving 8 bytes from r12 - -16 to rsp
		mov r10, [r12 - -16 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - -16 to rsp
		mov r10, [r12 - -16 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp r10, 0
	jne .jump234
	lea rdi, [rel const57] ; divide by zero
	call _fail_assertion
.jump234:
	cqo
	idiv r10
	push rax
	jmp .jump233
.jump232:
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
.jump233:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump235
	sub rsp, 8 ; Align stack
	lea rdi, [rel const2] ; non-positive loop bound
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump235:
	; Computing bound for h
	mov rax, [rel const58] ; 938
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump236
	lea rdi, [rel const2] ; non-positive loop bound
	call _fail_assertion
.jump236:
	; Computing bound for g
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	pop rdi
	call _b
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump237
	sub rsp, 8 ; Align stack
	lea rdi, [rel const2] ; non-positive loop bound
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump237:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize i to 0
	mov rax, 0
	push rax
	; Initialize h to 0
	mov rax, 0
	push rax
	; Initialize g to 0
	mov rax, 0
	push rax
.jump238: ; Begin body of loop
	; Compare i to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump240 ; If i >= bound, ...
	mov qword [rsp + 16], 0 ; i = 0
	add qword [rsp + 8], 1 ; h++
.jump240:
	; Compare h to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump241 ; If h >= bound, ...
	mov qword [rsp + 8], 0 ; h = 0
	add qword [rsp + 0], 1 ; g++
.jump241:
	; Compare g to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jge .jump239 ; If g >= bound, break
.jump242:
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - -16 to rsp
		mov r10, [r12 - -16 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment i
	add qword [rsp + 16], 1
	jmp .jump238
.jump239: ; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	pop rax
	pop r10
	cmp r10, 0
	jne .jump243
	lea rdi, [rel const57] ; divide by zero
	call _fail_assertion
.jump243:
	cqo
	idiv r10
	push rax
	sub rsp, 8 ; Align stack
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for h
	mov rax, [rel const59] ; 395
	push rax
	pop rax
	neg rax
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump244
	lea rdi, [rel const2] ; non-positive loop bound
	call _fail_assertion
.jump244:
	; Computing bound for g
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump245
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump247
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	jmp .jump248
.jump247:
	sub rsp, 8
	; Moving 8 bytes from r12 - -16 to rsp
		mov r10, [r12 - -16 + 0]
		mov [rsp + 0], r10
.jump248:
	jmp .jump246
.jump245:
	mov rax, [rel const60] ; 764
	push rax
.jump246:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump249
	sub rsp, 8 ; Align stack
	lea rdi, [rel const2] ; non-positive loop bound
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump249:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize h to 0
	mov rax, 0
	push rax
	; Initialize g to 0
	mov rax, 0
	push rax
.jump250: ; Begin body of loop
	; Compare h to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump252 ; If h >= bound, ...
	mov qword [rsp + 8], 0 ; h = 0
	add qword [rsp + 0], 1 ; g++
.jump252:
	; Compare g to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jge .jump251 ; If g >= bound, break
.jump253:
	; Compute loop body
	sub rsp, 8 ; Align stack
	mov rax, [rel const61] ; 88.53
	push rax
	mov rax, [rel const62] ; 48.7
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	call _fmod
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	call _sqrt
	add rsp, 8 ; Remove alignment
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp + 32] ; Load sum
	addsd xmm0, xmm1 ; Add loop body
	movsd [rsp + 32], xmm0 ; Save sum
	; Increment h
	add qword [rsp + 8], 1
	jmp .jump250
.jump251: ; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	movsd xmm0, [rsp]
	add rsp, 8
	call _to_int
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump254
	lea rdi, [rel const5] ; negative array index
	call _fail_assertion
.jump254:
	cmp rax, [rsp + 16]
	jl .jump255
	lea rdi, [rel const6] ; index too large
	call _fail_assertion
.jump255:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump256
	lea rdi, [rel const5] ; negative array index
	call _fail_assertion
.jump256:
	cmp rax, [rsp + 24]
	jl .jump257
	lea rdi, [rel const6] ; index too large
	call _fail_assertion
.jump257:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 0
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 0
	; Moving 0 bytes from rax to rsp
	sub rsp, 8 ; Align stack
	mov rax, [rel const63] ; 36.82
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	call _acos
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	call _to_int
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rel const64] ; 244
	push rax
	pop rax
	neg rax
	push rax
	pop rax
	pop r10
	cmp rax, r10
	sete al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump258
	mov rax, [rel const1] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump260
	mov rax, [rel const1] ; False
	push rax
	pop rax
.jump260:
	push rax
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump261
	mov rax, [rel const0] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump263
	mov rax, [rel const1] ; False
	push rax
	jmp .jump264
.jump263:
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
.jump264:
	pop rax
	cmp rax, 0
	je .jump265
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	jmp .jump266
.jump265:
	mov rax, [rel const65] ; 75.54
	push rax
.jump266:
	jmp .jump262
.jump261:
	mov rax, [rel const0] ; True
	push rax
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump267
	mov rax, [rel const66] ; 63.89
	push rax
	jmp .jump268
.jump267:
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
.jump268:
.jump262:
	jmp .jump259
.jump258:
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const67] ; 44.2
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rdi, 24
	call _jpl_alloc
	; Moving 24 bytes from rsp to rax
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 24
	push rax
	mov rax, 3
	push rax
	sub rsp, 8
	; Moving 8 bytes from r12 - -16 to rsp
		mov r10, [r12 - -16 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump269
	lea rdi, [rel const5] ; negative array index
	call _fail_assertion
.jump269:
	cmp rax, [rsp + 8]
	jl .jump270
	lea rdi, [rel const6] ; index too large
	call _fail_assertion
.jump270:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp
		mov r10, [rax + 0]
		mov [rsp + 0], r10
.jump259:
	; Moving 8 bytes from rsp + 0 to rsp + 0
		mov r10, [rsp + 0 + 0]
		mov [rsp + 0 + 0], r10
	add rsp, 0
	mov rax, [rel const68] ; 48.65
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	call _sin
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	call _sin
	sub rsp, 8
	movsd [rsp], xmm0
	sub rsp, 8 ; Align stack
	mov rax, [rel const69] ; 44.86
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	call _cos
	add rsp, 8 ; Remove alignment
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	call _pow
	sub rsp, 8
	movsd [rsp], xmm0
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for k
	mov rax, [rel const70] ; 620
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump271
	sub rsp, 8 ; Align stack
	lea rdi, [rel const2] ; non-positive loop bound
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump271:
	; Computing bound for j
	sub rsp, 8
	; Moving 8 bytes from r12 - -16 to rsp
		mov r10, [r12 - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump272
	lea rdi, [rel const2] ; non-positive loop bound
	call _fail_assertion
.jump272:
	; Computing bound for i
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const71] ; 282
	push rax
	pop rax
	pop r10
	cmp rax, r10
	setg al
	and rax, 1
	push rax
	pop rdi
	call _b
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump273
	sub rsp, 8 ; Align stack
	lea rdi, [rel const2] ; non-positive loop bound
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump273:
	; Computing total size of heap memory to allocate
	mov rdi, 40 ; sizeof {int[,,],bool}
	imul rdi, [rsp + 0 + 0] ; multiply by b((282 > e))
	jno .jump274
	sub rsp, 8 ; Align stack
	lea rdi, [rel const3] ; overflow computing array size
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump274:
	imul rdi, [rsp + 0 + 8] ; multiply by argnum
	jno .jump275
	sub rsp, 8 ; Align stack
	lea rdi, [rel const3] ; overflow computing array size
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump275:
	imul rdi, [rsp + 0 + 16] ; multiply by 620
	jno .jump276
	sub rsp, 8 ; Align stack
	lea rdi, [rel const3] ; overflow computing array size
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump276:
	sub rsp, 8 ; Align stack
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize k to 0
	mov rax, 0
	push rax
	; Initialize j to 0
	mov rax, 0
	push rax
	; Initialize i to 0
	mov rax, 0
	push rax
.jump277: ; Begin body of loop
	; Compare k to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump279 ; If k >= bound, ...
	mov qword [rsp + 16], 0 ; k = 0
	add qword [rsp + 8], 1 ; j++
.jump279:
	; Compare j to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump280 ; If j >= bound, ...
	mov qword [rsp + 8], 0 ; j = 0
	add qword [rsp + 0], 1 ; i++
.jump280:
	; Compare i to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jge .jump278 ; If i >= bound, break
.jump281:
	; Compute loop body
	mov rax, [rel const1] ; False
	push rax
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for n
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump282
	sub rsp, 8 ; Align stack
	lea rdi, [rel const2] ; non-positive loop bound
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump282:
	; Computing bound for m
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump283
	lea rdi, [rel const2] ; non-positive loop bound
	call _fail_assertion
.jump283:
	; Computing bound for l
	mov rax, [rel const72] ; 178
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump284
	sub rsp, 8 ; Align stack
	lea rdi, [rel const2] ; non-positive loop bound
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump284:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int
	imul rdi, [rsp + 0 + 0] ; multiply by 178
	jno .jump285
	sub rsp, 8 ; Align stack
	lea rdi, [rel const3] ; overflow computing array size
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump285:
	imul rdi, [rsp + 0 + 8] ; multiply by i
	jno .jump286
	sub rsp, 8 ; Align stack
	lea rdi, [rel const3] ; overflow computing array size
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump286:
	imul rdi, [rsp + 0 + 16] ; multiply by e
	jno .jump287
	sub rsp, 8 ; Align stack
	lea rdi, [rel const3] ; overflow computing array size
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump287:
	sub rsp, 8 ; Align stack
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize n to 0
	mov rax, 0
	push rax
	; Initialize m to 0
	mov rax, 0
	push rax
	; Initialize l to 0
	mov rax, 0
	push rax
.jump288: ; Begin body of loop
	; Compare n to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump290 ; If n >= bound, ...
	mov qword [rsp + 16], 0 ; n = 0
	add qword [rsp + 8], 1 ; m++
.jump290:
	; Compare m to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump291 ; If m >= bound, ...
	mov qword [rsp + 8], 0 ; m = 0
	add qword [rsp + 0], 1 ; l++
.jump291:
	; Compare l to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jge .jump289 ; If l >= bound, break
.jump292:
	; Compute loop body
	mov rax, [rel const73] ; 553
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment n
	add qword [rsp + 16], 1
	jmp .jump288
.jump289: ; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, [rsp + 80] ; No overflow if indices in bounds
	add rax, [rsp + 56]
	imul rax, 40
	add rax, [rsp + 88]
	; Move body (40 bytes) to index
	; Moving 40 bytes from rsp to rax
		mov r10, [rsp + 32]
		mov [rax + 32], r10
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 40
	; Increment k
	add qword [rsp + 16], 1
	jmp .jump277
.jump278: ; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from r12 - -16 to rsp
		mov r10, [r12 - -16 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	movsd xmm0, [rsp]
	add rsp, 8
	call _sqrt
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	call _to_int
	push rax
	pop rax
	neg rax
	push rax
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for j
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump293
	sub rsp, 8 ; Align stack
	lea rdi, [rel const2] ; non-positive loop bound
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump293:
	; Computing bound for i
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump294
	lea rdi, [rel const2] ; non-positive loop bound
	call _fail_assertion
.jump294:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int
	imul rdi, [rsp + 0 + 0] ; multiply by e
	jno .jump295
	lea rdi, [rel const3] ; overflow computing array size
	call _fail_assertion
.jump295:
	imul rdi, [rsp + 0 + 8] ; multiply by (- e)
	jno .jump296
	lea rdi, [rel const3] ; overflow computing array size
	call _fail_assertion
.jump296:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize j to 0
	mov rax, 0
	push rax
	; Initialize i to 0
	mov rax, 0
	push rax
.jump297: ; Begin body of loop
	; Compare j to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump299 ; If j >= bound, ...
	mov qword [rsp + 8], 0 ; j = 0
	add qword [rsp + 0], 1 ; i++
.jump299:
	; Compare i to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jge .jump298 ; If i >= bound, break
.jump300:
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - -16 to rsp
		mov r10, [r12 - -16 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment j
	add qword [rsp + 8], 1
	jmp .jump297
.jump298: ; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for k
	mov rax, [rel const74] ; 152
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump301
	lea rdi, [rel const2] ; non-positive loop bound
	call _fail_assertion
.jump301:
	; Computing bound for j
	sub rsp, 8
	; Moving 8 bytes from r12 - -16 to rsp
		mov r10, [r12 - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump302
	sub rsp, 8 ; Align stack
	lea rdi, [rel const2] ; non-positive loop bound
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump302:
	; Computing bound for i
	mov rax, [rel const75] ; 827
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump303
	lea rdi, [rel const2] ; non-positive loop bound
	call _fail_assertion
.jump303:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int
	imul rdi, [rsp + 0 + 0] ; multiply by 827
	jno .jump304
	lea rdi, [rel const3] ; overflow computing array size
	call _fail_assertion
.jump304:
	imul rdi, [rsp + 0 + 8] ; multiply by argnum
	jno .jump305
	lea rdi, [rel const3] ; overflow computing array size
	call _fail_assertion
.jump305:
	imul rdi, [rsp + 0 + 16] ; multiply by 152
	jno .jump306
	lea rdi, [rel const3] ; overflow computing array size
	call _fail_assertion
.jump306:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize k to 0
	mov rax, 0
	push rax
	; Initialize j to 0
	mov rax, 0
	push rax
	; Initialize i to 0
	mov rax, 0
	push rax
.jump307: ; Begin body of loop
	; Compare k to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump309 ; If k >= bound, ...
	mov qword [rsp + 16], 0 ; k = 0
	add qword [rsp + 8], 1 ; j++
.jump309:
	; Compare j to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump310 ; If j >= bound, ...
	mov qword [rsp + 8], 0 ; j = 0
	add qword [rsp + 0], 1 ; i++
.jump310:
	; Compare i to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jge .jump308 ; If i >= bound, break
.jump311:
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 168 to rsp
		mov r10, [rbp - 168 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment k
	add qword [rsp + 16], 1
	jmp .jump307
.jump308: ; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	mov rax, [rel const76] ; 13
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp r10, 0
	jne .jump312
	lea rdi, [rel const57] ; divide by zero
	call _fail_assertion
.jump312:
	cqo
	idiv r10
	push rax
	mov rax, [rel const0] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump313
	sub rsp, 8
	; Moving 8 bytes from r12 - -16 to rsp
		mov r10, [r12 - -16 + 0]
		mov [rsp + 0], r10
	jmp .jump314
.jump313:
	mov rax, [rel const77] ; 573
	push rax
.jump314:
	mov rax, [rel const78] ; 58.36
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	call _to_int
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump315
	sub rsp, 8 ; Align stack
	lea rdi, [rel const5] ; negative array index
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump315:
	cmp rax, [rsp + 24]
	jl .jump316
	sub rsp, 8 ; Align stack
	lea rdi, [rel const6] ; index too large
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump316:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump317
	sub rsp, 8 ; Align stack
	lea rdi, [rel const5] ; negative array index
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump317:
	cmp rax, [rsp + 32]
	jl .jump318
	sub rsp, 8 ; Align stack
	lea rdi, [rel const6] ; index too large
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump318:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump319
	sub rsp, 8 ; Align stack
	lea rdi, [rel const5] ; negative array index
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump319:
	cmp rax, [rsp + 40]
	jl .jump320
	sub rsp, 8 ; Align stack
	lea rdi, [rel const6] ; index too large
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump320:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 8
	; Moving 8 bytes from rax to rsp
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	sub rsp, 8 ; Align stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	movsd xmm0, [rsp]
	add rsp, 8
	call _atan
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	call _to_int
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump321
	lea rdi, [rel const5] ; negative array index
	call _fail_assertion
.jump321:
	cmp rax, [rsp + 16]
	jl .jump322
	lea rdi, [rel const6] ; index too large
	call _fail_assertion
.jump322:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump323
	lea rdi, [rel const5] ; negative array index
	call _fail_assertion
.jump323:
	cmp rax, [rsp + 24]
	jl .jump324
	lea rdi, [rel const6] ; index too large
	call _fail_assertion
.jump324:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 8
	; Moving 8 bytes from rax to rsp
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump325
	lea rdi, [rel const5] ; negative array index
	call _fail_assertion
.jump325:
	cmp rax, [rsp + 24]
	jl .jump326
	lea rdi, [rel const6] ; index too large
	call _fail_assertion
.jump326:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump327
	lea rdi, [rel const5] ; negative array index
	call _fail_assertion
.jump327:
	cmp rax, [rsp + 32]
	jl .jump328
	lea rdi, [rel const6] ; index too large
	call _fail_assertion
.jump328:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump329
	lea rdi, [rel const5] ; negative array index
	call _fail_assertion
.jump329:
	cmp rax, [rsp + 40]
	jl .jump330
	lea rdi, [rel const6] ; index too large
	call _fail_assertion
.jump330:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 40
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 40
	; Moving 40 bytes from rax to rsp
		mov r10, [rax + 32]
		mov [rsp + 32], r10
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	; Moving 32 bytes from rsp + 0 to rsp + 8
		mov r10, [rsp + 0 + 24]
		mov [rsp + 8 + 24], r10
		mov r10, [rsp + 0 + 16]
		mov [rsp + 8 + 16], r10
		mov r10, [rsp + 0 + 8]
		mov [rsp + 8 + 8], r10
		mov r10, [rsp + 0 + 0]
		mov [rsp + 8 + 0], r10
	add rsp, 8
	sub rsp, 32
	sub rsp, 8 ; Align stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	call _pow
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	call _sin
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for m
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for o
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump331
	lea rdi, [rel const2] ; non-positive loop bound
	call _fail_assertion
.jump331:
	; Computing bound for n
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 64 to rsp
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
	mov rdi, 16
	call _jpl_alloc
	; Moving 16 bytes from rsp to rax
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 16
	push rax
	mov rax, 2
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump332
	sub rsp, 8 ; Align stack
	lea rdi, [rel const5] ; negative array index
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump332:
	cmp rax, [rsp + 8]
	jl .jump333
	sub rsp, 8 ; Align stack
	lea rdi, [rel const6] ; index too large
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump333:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump334
	sub rsp, 8 ; Align stack
	lea rdi, [rel const2] ; non-positive loop bound
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump334:
	; Computing bound for m
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for n
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump335
	sub rsp, 8 ; Align stack
	lea rdi, [rel const2] ; non-positive loop bound
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump335:
	; Computing bound for m
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump336
	lea rdi, [rel const2] ; non-positive loop bound
	call _fail_assertion
.jump336:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize n to 0
	mov rax, 0
	push rax
	; Initialize m to 0
	mov rax, 0
	push rax
.jump337: ; Begin body of loop
	; Compare n to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump339 ; If n >= bound, ...
	mov qword [rsp + 8], 0 ; n = 0
	add qword [rsp + 0], 1 ; m++
.jump339:
	; Compare m to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jge .jump338 ; If m >= bound, break
.jump340:
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - -16 to rsp
		mov r10, [r12 - -16 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment n
	add qword [rsp + 8], 1
	jmp .jump337
.jump338: ; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump341
	lea rdi, [rel const2] ; non-positive loop bound
	call _fail_assertion
.jump341:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize o to 0
	mov rax, 0
	push rax
	; Initialize n to 0
	mov rax, 0
	push rax
	; Initialize m to 0
	mov rax, 0
	push rax
.jump342: ; Begin body of loop
	; Compare o to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump344 ; If o >= bound, ...
	mov qword [rsp + 16], 0 ; o = 0
	add qword [rsp + 8], 1 ; n++
.jump344:
	; Compare n to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump345 ; If n >= bound, ...
	mov qword [rsp + 8], 0 ; n = 0
	add qword [rsp + 0], 1 ; m++
.jump345:
	; Compare m to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jge .jump343 ; If m >= bound, break
.jump346:
	; Compute loop body
	mov rax, [rel const0] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump347
	sub rsp, 16
	; Moving 16 bytes from r12 - -16 to rsp
		mov r10, [r12 - -16 + 8]
		mov [rsp + 8], r10
		mov r10, [r12 - -16 + 0]
		mov [rsp + 0], r10
	jmp .jump348
.jump347:
	sub rsp, 16
	; Moving 16 bytes from r12 - -16 to rsp
		mov r10, [r12 - -16 + 8]
		mov [rsp + 8], r10
		mov r10, [r12 - -16 + 0]
		mov [rsp + 0], r10
.jump348:
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump349
	lea rdi, [rel const5] ; negative array index
	call _fail_assertion
.jump349:
	cmp rax, [rsp + 8]
	jl .jump350
	lea rdi, [rel const6] ; index too large
	call _fail_assertion
.jump350:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment o
	add qword [rsp + 16], 1
	jmp .jump342
.jump343: ; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump351
	sub rsp, 8 ; Align stack
	lea rdi, [rel const2] ; non-positive loop bound
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump351:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize m to 0
	mov rax, 0
	push rax
.jump352: ; Begin body of loop
	; Compare m to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jge .jump353 ; If m >= bound, break
.jump354:
	; Compute loop body
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for n
	sub rsp, 8 ; Align stack
	mov rax, [rel const1] ; False
	push rax
	mov rax, [rel const0] ; True
	push rax
	pop rax
	pop r10
	cmp rax, r10
	sete al
	and rax, 1
	push rax
	pop rdi
	call _b
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump355
	lea rdi, [rel const2] ; non-positive loop bound
	call _fail_assertion
.jump355:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize n to 0
	mov rax, 0
	push rax
.jump356: ; Begin body of loop
	; Compare n to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jge .jump357 ; If n >= bound, break
.jump358:
	; Compute loop body
	sub rsp, 8 ; Align stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmpeqsd xmm0, xmm1
	movq rax, xmm0
	and rax, 1
	push rax
	pop rdi
	call _b
	add rsp, 8 ; Remove alignment
	push rax
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment n
	add qword [rsp + 0], 1
	jmp .jump356
.jump357: ; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment m
	add qword [rsp + 0], 1
	jmp .jump352
.jump353: ; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	pop rsi
	movsd xmm0, [rsp]
	add rsp, 8
	lea rdi, [rsp + 8]
	call _d
	add rsp, 8 ; Remove alignment
	mov rax, [rbp - 8] ; Address to write return value into
	; Moving 32 bytes from rsp to rax
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 104 ; Local variables
	pop rbp
	ret

g:
_g:
	push rbp
	mov rbp, rsp
	mov rax, [rel const0] ; True
	push rax
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump399
	mov rax, [rel const87] ; 22.93
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	call _acos
	sub rsp, 8
	movsd [rsp], xmm0
	sub rsp, 8 ; Align stack
	sub rsp, 8
	; Moving 8 bytes from r12 - 32 to rsp
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	pop rdi
	call _to_float
	add rsp, 8 ; Remove alignment
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmpneqsd xmm0, xmm1
	movq rax, xmm0
	and rax, 1
	push rax
	pop rax
.jump399:
	push rax
	pop rax
	add rsp, 0 ; Local variables
	pop rbp
	ret
	mov rax, [rel const1] ; False
	push rax
	pop rax
	cmp rax, 0
	jne .jump400
	mov rax, [rel const88] ; 99
	push rax
	pop rax
	neg rax
	push rax
	pop rdi
	call _to_float
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	call _atan
	sub rsp, 8
	movsd [rsp], xmm0
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for h
	sub rsp, 8
	; Moving 8 bytes from r12 - -16 to rsp
		mov r10, [r12 - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump401
	sub rsp, 8 ; Align stack
	lea rdi, [rel const2] ; non-positive loop bound
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump401:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof float
	imul rdi, [rsp + 0 + 0] ; multiply by argnum
	jno .jump402
	sub rsp, 8 ; Align stack
	lea rdi, [rel const3] ; overflow computing array size
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump402:
	sub rsp, 8 ; Align stack
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize h to 0
	mov rax, 0
	push rax
.jump403: ; Begin body of loop
	; Compare h to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jge .jump404 ; If h >= bound, break
.jump405:
	; Compute loop body
	mov rax, [rel const89] ; 41.38
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 24]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment h
	add qword [rsp + 0], 1
	jmp .jump403
.jump404: ; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from r12 - 32 to rsp
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump406
	lea rdi, [rel const5] ; negative array index
	call _fail_assertion
.jump406:
	cmp rax, [rsp + 8]
	jl .jump407
	lea rdi, [rel const6] ; index too large
	call _fail_assertion
.jump407:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmpneqsd xmm0, xmm1
	movq rax, xmm0
	and rax, 1
	push rax
	pop rax
.jump400:
	push rax
	sub rsp, 8 ; Align stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 8 to rsp
		mov r10, [rbp - 8 + 0]
		mov [rsp + 0], r10
	pop rdi
	call _b
	add rsp, 8 ; Remove alignment
	push rax
	sub rsp, 16
	; Moving 16 bytes from r12 - -16 to rsp
		mov r10, [r12 - -16 + 8]
		mov [rsp + 8], r10
		mov r10, [r12 - -16 + 0]
		mov [rsp + 0], r10
	call _g
	push rax
	sub rsp, 16
	; Moving 16 bytes from r12 - -16 to rsp
		mov r10, [r12 - -16 + 8]
		mov [rsp + 8], r10
		mov r10, [r12 - -16 + 0]
		mov [rsp + 0], r10
	; Moving 24 bytes from rsp + 0 to rsp + 24
		mov r10, [rsp + 0 + 16]
		mov [rsp + 24 + 16], r10
		mov r10, [rsp + 0 + 8]
		mov [rsp + 24 + 8], r10
		mov r10, [rsp + 0 + 0]
		mov [rsp + 24 + 0], r10
	add rsp, 24
	; Moving 8 bytes from rsp + 16 to rsp + 16
		mov r10, [rsp + 16 + 0]
		mov [rsp + 16 + 0], r10
	add rsp, 16
	pop rax
	cmp rax, 0
	je .jump408
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump410
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for j
	mov rax, [rel const90] ; 404
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump412
	sub rsp, 8 ; Align stack
	lea rdi, [rel const2] ; non-positive loop bound
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump412:
	; Computing bound for i
	sub rsp, 8 ; Align stack
	call _g
	push rax
	pop rax
	cmp rax, 0
	jne .jump413
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	pop rax
.jump413:
	push rax
	pop rdi
	call _b
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump414
	lea rdi, [rel const2] ; non-positive loop bound
	call _fail_assertion
.jump414:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool
	imul rdi, [rsp + 0 + 0] ; multiply by b((g() || c))
	jno .jump415
	lea rdi, [rel const3] ; overflow computing array size
	call _fail_assertion
.jump415:
	imul rdi, [rsp + 0 + 8] ; multiply by 404
	jno .jump416
	lea rdi, [rel const3] ; overflow computing array size
	call _fail_assertion
.jump416:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize j to 0
	mov rax, 0
	push rax
	; Initialize i to 0
	mov rax, 0
	push rax
.jump417: ; Begin body of loop
	; Compare j to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump419 ; If j >= bound, ...
	mov qword [rsp + 8], 0 ; j = 0
	add qword [rsp + 0], 1 ; i++
.jump419:
	; Compare i to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jge .jump418 ; If i >= bound, break
.jump420:
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 8 to rsp
		mov r10, [rbp - 8 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment j
	add qword [rsp + 8], 1
	jmp .jump417
.jump418: ; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	jmp .jump411
.jump410:
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	xor rax, 1
	push rax
	call _g
	push rax
	pop rax
	cmp rax, 0
	jne .jump421
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	pop rax
.jump421:
	push rax
	pop rax
	pop r10
	cmp rax, r10
	sete al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump422
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for j
	call _g
	push rax
	pop rax
	cmp rax, 0
	je .jump424
	mov rax, [rel const91] ; 724
	push rax
	jmp .jump425
.jump424:
	sub rsp, 8
	; Moving 8 bytes from r12 - 32 to rsp
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
.jump425:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump426
	sub rsp, 8 ; Align stack
	lea rdi, [rel const2] ; non-positive loop bound
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump426:
	; Computing bound for i
	sub rsp, 8
	; Moving 8 bytes from r12 - -16 to rsp
		mov r10, [r12 - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump427
	lea rdi, [rel const2] ; non-positive loop bound
	call _fail_assertion
.jump427:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool
	imul rdi, [rsp + 0 + 0] ; multiply by argnum
	jno .jump428
	lea rdi, [rel const3] ; overflow computing array size
	call _fail_assertion
.jump428:
	imul rdi, [rsp + 0 + 8] ; multiply by (if g() then 724 else f)
	jno .jump429
	lea rdi, [rel const3] ; overflow computing array size
	call _fail_assertion
.jump429:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize j to 0
	mov rax, 0
	push rax
	; Initialize i to 0
	mov rax, 0
	push rax
.jump430: ; Begin body of loop
	; Compare j to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump432 ; If j >= bound, ...
	mov qword [rsp + 8], 0 ; j = 0
	add qword [rsp + 0], 1 ; i++
.jump432:
	; Compare i to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jge .jump431 ; If i >= bound, break
.jump433:
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 8 to rsp
		mov r10, [rbp - 8 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment j
	add qword [rsp + 8], 1
	jmp .jump430
.jump431: ; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	jmp .jump423
.jump422:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for j
	sub rsp, 8
	; Moving 8 bytes from r12 - 32 to rsp
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump434
	sub rsp, 8 ; Align stack
	lea rdi, [rel const2] ; non-positive loop bound
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump434:
	; Computing bound for i
	sub rsp, 8
	; Moving 8 bytes from r12 - -16 to rsp
		mov r10, [r12 - -16 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump435
	lea rdi, [rel const2] ; non-positive loop bound
	call _fail_assertion
.jump435:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool
	imul rdi, [rsp + 0 + 0] ; multiply by (- argnum)
	jno .jump436
	lea rdi, [rel const3] ; overflow computing array size
	call _fail_assertion
.jump436:
	imul rdi, [rsp + 0 + 8] ; multiply by (- f)
	jno .jump437
	lea rdi, [rel const3] ; overflow computing array size
	call _fail_assertion
.jump437:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize j to 0
	mov rax, 0
	push rax
	; Initialize i to 0
	mov rax, 0
	push rax
.jump438: ; Begin body of loop
	; Compare j to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump440 ; If j >= bound, ...
	mov qword [rsp + 8], 0 ; j = 0
	add qword [rsp + 0], 1 ; i++
.jump440:
	; Compare i to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jge .jump439 ; If i >= bound, break
.jump441:
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment j
	add qword [rsp + 8], 1
	jmp .jump438
.jump439: ; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
.jump423:
.jump411:
	jmp .jump409
.jump408:
	sub rsp, 8
	; Moving 8 bytes from rbp - 8 to rsp
		mov r10, [rbp - 8 + 0]
		mov [rsp + 0], r10
	; Moving 8 bytes from rsp + 0 to rsp + 0
		mov r10, [rsp + 0 + 0]
		mov [rsp + 0 + 0], r10
	add rsp, 0
	pop rax
	cmp rax, 0
	je .jump442
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for j
	sub rsp, 8
	; Moving 8 bytes from r12 - 32 to rsp
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump444
	sub rsp, 8 ; Align stack
	lea rdi, [rel const2] ; non-positive loop bound
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump444:
	; Computing bound for i
	sub rsp, 8
	; Moving 8 bytes from r12 - -16 to rsp
		mov r10, [r12 - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump445
	lea rdi, [rel const2] ; non-positive loop bound
	call _fail_assertion
.jump445:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool
	imul rdi, [rsp + 0 + 0] ; multiply by argnum
	jno .jump446
	lea rdi, [rel const3] ; overflow computing array size
	call _fail_assertion
.jump446:
	imul rdi, [rsp + 0 + 8] ; multiply by f
	jno .jump447
	lea rdi, [rel const3] ; overflow computing array size
	call _fail_assertion
.jump447:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize j to 0
	mov rax, 0
	push rax
	; Initialize i to 0
	mov rax, 0
	push rax
.jump448: ; Begin body of loop
	; Compare j to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump450 ; If j >= bound, ...
	mov qword [rsp + 8], 0 ; j = 0
	add qword [rsp + 0], 1 ; i++
.jump450:
	; Compare i to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jge .jump449 ; If i >= bound, break
.jump451:
	; Compute loop body
	mov rax, [rel const0] ; True
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment j
	add qword [rsp + 8], 1
	jmp .jump448
.jump449: ; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	mov rax, [rel const92] ; 92.11
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	call _cos
	sub rsp, 8
	movsd [rsp], xmm0
	jmp .jump443
.jump442:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for j
	mov rax, [rel const93] ; 623
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump452
	sub rsp, 8 ; Align stack
	lea rdi, [rel const2] ; non-positive loop bound
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump452:
	; Computing bound for i
	sub rsp, 8
	; Moving 8 bytes from r12 - -16 to rsp
		mov r10, [r12 - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump453
	lea rdi, [rel const2] ; non-positive loop bound
	call _fail_assertion
.jump453:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool
	imul rdi, [rsp + 0 + 0] ; multiply by argnum
	jno .jump454
	lea rdi, [rel const3] ; overflow computing array size
	call _fail_assertion
.jump454:
	imul rdi, [rsp + 0 + 8] ; multiply by 623
	jno .jump455
	lea rdi, [rel const3] ; overflow computing array size
	call _fail_assertion
.jump455:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize j to 0
	mov rax, 0
	push rax
	; Initialize i to 0
	mov rax, 0
	push rax
.jump456: ; Begin body of loop
	; Compare j to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump458 ; If j >= bound, ...
	mov qword [rsp + 8], 0 ; j = 0
	add qword [rsp + 0], 1 ; i++
.jump458:
	; Compare i to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jge .jump457 ; If i >= bound, break
.jump459:
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 8 to rsp
		mov r10, [rbp - 8 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment j
	add qword [rsp + 8], 1
	jmp .jump456
.jump457: ; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	mov rax, [rel const94] ; 92.18
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	call _acos
	sub rsp, 8
	movsd [rsp], xmm0
.jump443:
	; Moving 24 bytes from rsp + 8 to rsp + 8
		mov r10, [rsp + 8 + 16]
		mov [rsp + 8 + 16], r10
		mov r10, [rsp + 8 + 8]
		mov [rsp + 8 + 8], r10
		mov r10, [rsp + 8 + 0]
		mov [rsp + 8 + 0], r10
	add rsp, 8
.jump409:
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	pop rdi
	call _to_float
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	call _acos
	sub rsp, 8
	movsd [rsp], xmm0
	sub rsp, 8 ; Align stack
	sub rsp, 8
	; Moving 8 bytes from r12 - -16 to rsp
		mov r10, [r12 - -16 + 0]
		mov [rsp + 0], r10
	pop rdi
	call _to_float
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	call _acos
	add rsp, 8 ; Remove alignment
	sub rsp, 8
	movsd [rsp], xmm0
	sub rsp, 32
	mov rax, [rel const95] ; 2.33
	push rax
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	sub rsp, 8
	; Moving 8 bytes from r12 - 32 to rsp
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
	pop rsi
	movsd xmm0, [rsp]
	add rsp, 8
	lea rdi, [rsp + 0]
	call _d
	; Moving 48 bytes from rsp + 0 to rsp + 0
		mov r10, [rsp + 0 + 40]
		mov [rsp + 0 + 40], r10
		mov r10, [rsp + 0 + 32]
		mov [rsp + 0 + 32], r10
		mov r10, [rsp + 0 + 24]
		mov [rsp + 0 + 24], r10
		mov r10, [rsp + 0 + 16]
		mov [rsp + 0 + 16], r10
		mov r10, [rsp + 0 + 8]
		mov [rsp + 0 + 8], r10
		mov r10, [rsp + 0 + 0]
		mov [rsp + 0 + 0], r10
	add rsp, 0
	sub rsp, 24
	; Moving 24 bytes from rbp - 32 to rsp
		mov r10, [rbp - 32 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - 32 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 80 to rsp
		mov r10, [rbp - 80 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump460
	sub rsp, 8 ; Align stack
	lea rdi, [rel const5] ; negative array index
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump460:
	cmp rax, [rsp + 16]
	jl .jump461
	sub rsp, 8 ; Align stack
	lea rdi, [rel const6] ; index too large
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump461:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump462
	sub rsp, 8 ; Align stack
	lea rdi, [rel const5] ; negative array index
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump462:
	cmp rax, [rsp + 24]
	jl .jump463
	sub rsp, 8 ; Align stack
	lea rdi, [rel const6] ; index too large
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump463:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 8
	; Moving 8 bytes from rax to rsp
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump464
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for t
	sub rsp, 8
	; Moving 8 bytes from rbp - 64 to rsp
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump466
	lea rdi, [rel const2] ; non-positive loop bound
	call _fail_assertion
.jump466:
	; Computing bound for s
	mov rax, [rel const96] ; 592
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump467
	sub rsp, 8 ; Align stack
	lea rdi, [rel const2] ; non-positive loop bound
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump467:
	; Computing bound for r
	sub rsp, 8
	; Moving 8 bytes from r12 - 32 to rsp
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump468
	lea rdi, [rel const2] ; non-positive loop bound
	call _fail_assertion
.jump468:
	; Computing total size of heap memory to allocate
	mov rdi, 32 ; sizeof bool[,,]
	imul rdi, [rsp + 0 + 0] ; multiply by f
	jno .jump469
	lea rdi, [rel const3] ; overflow computing array size
	call _fail_assertion
.jump469:
	imul rdi, [rsp + 0 + 8] ; multiply by 592
	jno .jump470
	lea rdi, [rel const3] ; overflow computing array size
	call _fail_assertion
.jump470:
	imul rdi, [rsp + 0 + 16] ; multiply by o
	jno .jump471
	lea rdi, [rel const3] ; overflow computing array size
	call _fail_assertion
.jump471:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize t to 0
	mov rax, 0
	push rax
	; Initialize s to 0
	mov rax, 0
	push rax
	; Initialize r to 0
	mov rax, 0
	push rax
.jump472: ; Begin body of loop
	; Compare t to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump474 ; If t >= bound, ...
	mov qword [rsp + 16], 0 ; t = 0
	add qword [rsp + 8], 1 ; s++
.jump474:
	; Compare s to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump475 ; If s >= bound, ...
	mov qword [rsp + 8], 0 ; s = 0
	add qword [rsp + 0], 1 ; r++
.jump475:
	; Compare r to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jge .jump473 ; If r >= bound, break
.jump476:
	; Compute loop body
	sub rsp, 32
	; Moving 32 bytes from rbp - 80 to rsp
		mov r10, [rbp - 80 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - 80 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - 80 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 80 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, 32
	add rax, [rsp + 80]
	; Move body (32 bytes) to index
	; Moving 32 bytes from rsp to rax
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	; Increment t
	add qword [rsp + 16], 1
	jmp .jump472
.jump473: ; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from r12 - -16 to rsp
		mov r10, [r12 - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const97] ; 744
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 80 to rsp
		mov r10, [rbp - 80 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump477
	sub rsp, 8 ; Align stack
	lea rdi, [rel const5] ; negative array index
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump477:
	cmp rax, [rsp + 24]
	jl .jump478
	sub rsp, 8 ; Align stack
	lea rdi, [rel const6] ; index too large
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump478:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump479
	sub rsp, 8 ; Align stack
	lea rdi, [rel const5] ; negative array index
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump479:
	cmp rax, [rsp + 32]
	jl .jump480
	sub rsp, 8 ; Align stack
	lea rdi, [rel const6] ; index too large
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump480:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump481
	sub rsp, 8 ; Align stack
	lea rdi, [rel const5] ; negative array index
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump481:
	cmp rax, [rsp + 40]
	jl .jump482
	sub rsp, 8 ; Align stack
	lea rdi, [rel const6] ; index too large
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump482:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 32
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 32
	; Moving 32 bytes from rax to rsp
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 80 to rsp
		mov r10, [rbp - 80 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 32 to rsp
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump483
	sub rsp, 8 ; Align stack
	lea rdi, [rel const5] ; negative array index
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump483:
	cmp rax, [rsp + 24]
	jl .jump484
	sub rsp, 8 ; Align stack
	lea rdi, [rel const6] ; index too large
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump484:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump485
	sub rsp, 8 ; Align stack
	lea rdi, [rel const5] ; negative array index
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump485:
	cmp rax, [rsp + 32]
	jl .jump486
	sub rsp, 8 ; Align stack
	lea rdi, [rel const6] ; index too large
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump486:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump487
	sub rsp, 8 ; Align stack
	lea rdi, [rel const5] ; negative array index
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump487:
	cmp rax, [rsp + 40]
	jl .jump488
	sub rsp, 8 ; Align stack
	lea rdi, [rel const6] ; index too large
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump488:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 8
	; Moving 8 bytes from rax to rsp
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	jmp .jump465
.jump464:
	sub rsp, 32
	; Moving 32 bytes from rbp - 80 to rsp
		mov r10, [rbp - 80 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - 80 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - 80 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 80 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 80 to rsp
		mov r10, [rbp - 80 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - -16 to rsp
		mov r10, [r12 - -16 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	setl al
	and rax, 1
	push rax
	; Moving 8 bytes from rsp + 0 to rsp + 32
		mov r10, [rsp + 0 + 0]
		mov [rsp + 32 + 0], r10
	add rsp, 32
.jump465:
	pop rax
	cmp rax, 0
	je .jump489
	sub rsp, 8
	; Moving 8 bytes from rbp - 64 to rsp
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	setle al
	and rax, 1
	push rax
	jmp .jump490
.jump489:
	sub rsp, 8
	; Moving 8 bytes from rbp - 8 to rsp
		mov r10, [rbp - 8 + 0]
		mov [rsp + 0], r10
	pop rax
	xor rax, 1
	push rax
	pop rdi
	call _b
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 64 to rsp
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	pop rax
	pop r10
	cmp r10, 0
	jne .jump491
	sub rsp, 8 ; Align stack
	lea rdi, [rel const41] ; mod by zero
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump491:
	cqo
	idiv r10
	mov rax, rdx
	push rax
	pop rax
	pop r10
	cmp rax, r10
	setl al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	jne .jump492
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	movsd xmm0, [rsp]
	add rsp, 8
	call _tan
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	call _log
	sub rsp, 8
	movsd [rsp], xmm0
	sub rsp, 8 ; Align stack
	mov rax, [rel const98] ; 22.22
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	call _atan2
	add rsp, 8 ; Remove alignment
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmplesd xmm0, xmm1
	movq rax, xmm0
	and rax, 1
	push rax
	pop rax
.jump492:
	push rax
.jump490:
	pop rax
	add rsp, 80 ; Local variables
	pop rbp
	ret

h:
_h:
	push rbp
	mov rbp, rsp
	push rdi
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for k
	mov rax, [rel const99] ; 99.96
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	call _tan
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	call _tan
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	call _to_int
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump493
	sub rsp, 8 ; Align stack
	lea rdi, [rel const2] ; non-positive loop bound
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump493:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int
	imul rdi, [rsp + 0 + 0] ; multiply by to_int((- tan(tan(99.96))))
	jno .jump494
	sub rsp, 8 ; Align stack
	lea rdi, [rel const3] ; overflow computing array size
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump494:
	sub rsp, 8 ; Align stack
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize k to 0
	mov rax, 0
	push rax
.jump495: ; Begin body of loop
	; Compare k to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jge .jump496 ; If k >= bound, break
.jump497:
	; Compute loop body
	mov rax, [rel const1] ; False
	push rax
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump498
	sub rsp, 32
	lea rdi, [rsp + 0]
	call _a
	jmp .jump499
.jump498:
	sub rsp, 32
	lea rdi, [rsp + 0]
	call _a
.jump499:
	; Moving 32 bytes from rsp + 0 to rsp + 0
		mov r10, [rsp + 0 + 24]
		mov [rsp + 0 + 24], r10
		mov r10, [rsp + 0 + 16]
		mov [rsp + 0 + 16], r10
		mov r10, [rsp + 0 + 8]
		mov [rsp + 0 + 8], r10
		mov r10, [rsp + 0 + 0]
		mov [rsp + 0 + 0], r10
	add rsp, 0
	; Moving 8 bytes from rsp + 8 to rsp + 24
		mov r10, [rsp + 8 + 0]
		mov [rsp + 24 + 0], r10
	add rsp, 24
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 24]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment k
	add qword [rsp + 0], 1
	jmp .jump495
.jump496: ; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	sub rsp, 8 ; Align stack
	call _g
	add rsp, 8 ; Remove alignment
	push rax
	pop rax
	cmp rax, 0
	je .jump500
	mov rax, [rel const1] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump501
	sub rsp, 8 ; Align stack
	call _g
	add rsp, 8 ; Remove alignment
	push rax
	jmp .jump502
.jump501:
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
.jump502:
	pop rax
.jump500:
	push rax
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump503
	mov rax, [rel const100] ; 80.18
	push rax
	mov rax, [rel const1] ; False
	push rax
	; Moving 8 bytes from rsp + 0 to rsp + 8
		mov r10, [rsp + 0 + 0]
		mov [rsp + 8 + 0], r10
	add rsp, 8
	pop rax
	cmp rax, 0
	je .jump505
	sub rsp, 16
	; Moving 16 bytes from rbp - -16 to rsp
		mov r10, [rbp - -16 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	jmp .jump506
.jump505:
	sub rsp, 16
	; Moving 16 bytes from rbp - -16 to rsp
		mov r10, [rbp - -16 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
.jump506:
	jmp .jump504
.jump503:
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump507
	sub rsp, 8 ; Align stack
	call _g
	add rsp, 8 ; Remove alignment
	push rax
	jmp .jump508
.jump507:
	sub rsp, 8 ; Align stack
	call _g
	add rsp, 8 ; Remove alignment
	push rax
.jump508:
	pop rax
	cmp rax, 0
	je .jump509
	sub rsp, 16
	; Moving 16 bytes from rbp - -16 to rsp
		mov r10, [rbp - -16 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	; Moving 16 bytes from rsp + 0 to rsp + 0
		mov r10, [rsp + 0 + 8]
		mov [rsp + 0 + 8], r10
		mov r10, [rsp + 0 + 0]
		mov [rsp + 0 + 0], r10
	add rsp, 0
	jmp .jump510
.jump509:
	sub rsp, 16
	; Moving 16 bytes from rbp - -16 to rsp
		mov r10, [rbp - -16 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
.jump510:
.jump504:
	sub rsp, 32
	sub rsp, 8 ; Align stack
	sub rsp, 16
	; Moving 16 bytes from rbp - 40 to rsp
		mov r10, [rbp - 40 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	lea rdi, [rsp + 24]
	call _h
	add rsp, 16
	add rsp, 8 ; Remove alignment
	sub rsp, 32
	sub rsp, 8 ; Align stack
	sub rsp, 16
	; Moving 16 bytes from rbp - -16 to rsp
		mov r10, [rbp - -16 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	lea rdi, [rsp + 24]
	call _h
	add rsp, 16
	add rsp, 8 ; Remove alignment
	mov rax, [rbp - 8] ; Address to write return value into
	; Moving 32 bytes from rsp to rax
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 104 ; Local variables
	pop rbp
	ret
	sub rsp, 8 ; Align stack
	mov rax, [rel const101] ; 75.47
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	call _sin
	add rsp, 8 ; Remove alignment
	sub rsp, 8
	movsd [rsp], xmm0
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	sub rsp, 32
	sub rsp, 8 ; Align stack
	sub rsp, 16
	; Moving 16 bytes from rbp - -16 to rsp
		mov r10, [rbp - -16 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	lea rdi, [rsp + 24]
	call _h
	add rsp, 16
	add rsp, 8 ; Remove alignment
	sub rsp, 32
	sub rsp, 8 ; Align stack
	sub rsp, 16
	; Moving 16 bytes from rbp - -16 to rsp
		mov r10, [rbp - -16 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	lea rdi, [rsp + 24]
	call _h
	add rsp, 16
	add rsp, 8 ; Remove alignment
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	; Moving 72 bytes from rsp + 0 to rsp + 16
		mov r10, [rsp + 0 + 64]
		mov [rsp + 16 + 64], r10
		mov r10, [rsp + 0 + 56]
		mov [rsp + 16 + 56], r10
		mov r10, [rsp + 0 + 48]
		mov [rsp + 16 + 48], r10
		mov r10, [rsp + 0 + 40]
		mov [rsp + 16 + 40], r10
		mov r10, [rsp + 0 + 32]
		mov [rsp + 16 + 32], r10
		mov r10, [rsp + 0 + 24]
		mov [rsp + 16 + 24], r10
		mov r10, [rsp + 0 + 16]
		mov [rsp + 16 + 16], r10
		mov r10, [rsp + 0 + 8]
		mov [rsp + 16 + 8], r10
		mov r10, [rsp + 0 + 0]
		mov [rsp + 16 + 0], r10
	add rsp, 16
	; Moving 32 bytes from rsp + 8 to rsp + 40
		mov r10, [rsp + 8 + 24]
		mov [rsp + 40 + 24], r10
		mov r10, [rsp + 8 + 16]
		mov [rsp + 40 + 16], r10
		mov r10, [rsp + 8 + 8]
		mov [rsp + 40 + 8], r10
		mov r10, [rsp + 8 + 0]
		mov [rsp + 40 + 0], r10
	add rsp, 40
	mov rax, [rbp - 8] ; Address to write return value into
	; Moving 32 bytes from rsp to rax
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 136 ; Local variables
	pop rbp
	ret

i:
_i:
	push rbp
	mov rbp, rsp
	push rdi
	sub rsp, 8 ; Align stack
	call _g
	add rsp, 8 ; Remove alignment
	push rax
	sub rsp, 8
	; Moving 8 bytes from r12 - -16 to rsp
		mov r10, [r12 - -16 + 0]
		mov [rsp + 0], r10
	sub rsp, 8 ; Align stack
	call _g
	add rsp, 8 ; Remove alignment
	push rax
	; Moving 8 bytes from rsp + 0 to rsp + 16
		mov r10, [rsp + 0 + 0]
		mov [rsp + 16 + 0], r10
	add rsp, 16
	pop rax
	cmp rax, 0
	je .jump511
	sub rsp, 8
	; Moving 8 bytes from rbp - -24 to rsp
		mov r10, [rbp - -24 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - -128 to rsp
		mov r10, [rbp - -128 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	setge al
	and rax, 1
	push rax
	jmp .jump512
.jump511:
	sub rsp, 8 ; Align stack
	mov rax, [rel const102] ; 36
	push rax
	pop rdi
	call _to_float
	add rsp, 8 ; Remove alignment
	sub rsp, 8
	movsd [rsp], xmm0
	mov rax, [rel const103] ; 8.2
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmplesd xmm1, xmm0
	movq rax, xmm1
	and rax, 1
	push rax
.jump512:
	pop rax
	cmp rax, 0
	je .jump513
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	sub rsp, 16
	; Moving 16 bytes from r12 - 32 to rsp
		mov r10, [r12 - 32 + 8]
		mov [rsp + 8], r10
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const1] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump515
	sub rsp, 24
	; Moving 24 bytes from rbp - -16 to rsp
		mov r10, [rbp - -16 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -16 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	jmp .jump516
.jump515:
	sub rsp, 24
	; Moving 24 bytes from rbp - -16 to rsp
		mov r10, [rbp - -16 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -16 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
.jump516:
	sub rsp, 16
	; Moving 16 bytes from r12 - -16 to rsp
		mov r10, [r12 - -16 + 8]
		mov [rsp + 8], r10
		mov r10, [r12 - -16 + 0]
		mov [rsp + 0], r10
	sub rsp, 8 ; Align stack
	call _g
	add rsp, 8 ; Remove alignment
	push rax
	jmp .jump514
.jump513:
	sub rsp, 8 ; Align stack
	call _g
	add rsp, 8 ; Remove alignment
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - -120 to rsp
		mov r10, [rbp - -120 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - -120 to rsp
		mov r10, [rbp - -120 + 0]
		mov [rsp + 0], r10
	mov rdi, 16
	call _jpl_alloc
	; Moving 16 bytes from rsp to rax
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 16
	push rax
	mov rax, 2
	push rax
	sub rsp, 24
	; Moving 24 bytes from rbp - -16 to rsp
		mov r10, [rbp - -16 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -16 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for t
	sub rsp, 8
	; Moving 8 bytes from rbp - -24 to rsp
		mov r10, [rbp - -24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump517
	sub rsp, 8 ; Align stack
	lea rdi, [rel const2] ; non-positive loop bound
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump517:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int
	imul rdi, [rsp + 0 + 0] ; multiply by l
	jno .jump518
	sub rsp, 8 ; Align stack
	lea rdi, [rel const3] ; overflow computing array size
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump518:
	sub rsp, 8 ; Align stack
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize t to 0
	mov rax, 0
	push rax
.jump519: ; Begin body of loop
	; Compare t to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jge .jump520 ; If t >= bound, break
.jump521:
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - -16 to rsp
		mov r10, [r12 - -16 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 24]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment t
	add qword [rsp + 0], 1
	jmp .jump519
.jump520: ; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	sub rsp, 8 ; Align stack
	call _g
	add rsp, 8 ; Remove alignment
	push rax
.jump514:
	; Moving 56 bytes from rsp + 8 to rsp + 16
		mov r10, [rsp + 8 + 48]
		mov [rsp + 16 + 48], r10
		mov r10, [rsp + 8 + 40]
		mov [rsp + 16 + 40], r10
		mov r10, [rsp + 8 + 32]
		mov [rsp + 16 + 32], r10
		mov r10, [rsp + 8 + 24]
		mov [rsp + 16 + 24], r10
		mov r10, [rsp + 8 + 16]
		mov [rsp + 16 + 16], r10
		mov r10, [rsp + 8 + 8]
		mov [rsp + 16 + 8], r10
		mov r10, [rsp + 8 + 0]
		mov [rsp + 16 + 0], r10
	add rsp, 16
	mov rax, [rel const1] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump522
	sub rsp, 24
	; Moving 24 bytes from rbp - -16 to rsp
		mov r10, [rbp - -16 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -16 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	sub rsp, 32
	sub rsp, 8 ; Align stack
	mov rax, [rel const104] ; 64.56
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	call _log
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	sub rsp, 8 ; Align stack
	mov rax, [rel const105] ; 99.87
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	call _tan
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	call _to_int
	add rsp, 8 ; Remove alignment
	push rax
	pop rsi
	movsd xmm0, [rsp]
	add rsp, 8
	lea rdi, [rsp + 8]
	call _d
	add rsp, 8 ; Remove alignment
	mov rax, [rel const0] ; True
	push rax
	mov rax, [rel const0] ; True
	push rax
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	setne al
	and rax, 1
	push rax
	pop rax
	pop r10
	cmp rax, r10
	sete al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump524
	sub rsp, 0
	; Moving 0 bytes from rbp - -112 to rsp
	sub rsp, 16
	; Moving 16 bytes from r12 - 32 to rsp
		mov r10, [r12 - 32 + 8]
		mov [rsp + 8], r10
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
	sub rsp, 16
	; Moving 16 bytes from rbp - 64 to rsp
		mov r10, [rbp - 64 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
	jmp .jump525
.jump524:
	sub rsp, 16
	; Moving 16 bytes from r12 - 32 to rsp
		mov r10, [r12 - 32 + 8]
		mov [rsp + 8], r10
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
	sub rsp, 16
	; Moving 16 bytes from rbp - 24 to rsp
		mov r10, [rbp - 24 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
.jump525:
	jmp .jump523
.jump522:
	sub rsp, 32
	; Moving 32 bytes from rbp - -40 to rsp
		mov r10, [rbp - -40 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - -40 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -40 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -40 + 0]
		mov [rsp + 0], r10
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for B
	sub rsp, 8
	; Moving 8 bytes from rbp - -120 to rsp
		mov r10, [rbp - -120 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump526
	lea rdi, [rel const2] ; non-positive loop bound
	call _fail_assertion
.jump526:
	; Computing bound for A
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump527
	sub rsp, 8 ; Align stack
	lea rdi, [rel const2] ; non-positive loop bound
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump527:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int
	imul rdi, [rsp + 0 + 0] ; multiply by w
	jno .jump528
	sub rsp, 8 ; Align stack
	lea rdi, [rel const3] ; overflow computing array size
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump528:
	imul rdi, [rsp + 0 + 8] ; multiply by r
	jno .jump529
	sub rsp, 8 ; Align stack
	lea rdi, [rel const3] ; overflow computing array size
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump529:
	sub rsp, 8 ; Align stack
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize B to 0
	mov rax, 0
	push rax
	; Initialize A to 0
	mov rax, 0
	push rax
.jump530: ; Begin body of loop
	; Compare B to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump532 ; If B >= bound, ...
	mov qword [rsp + 8], 0 ; B = 0
	add qword [rsp + 0], 1 ; A++
.jump532:
	; Compare A to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jge .jump531 ; If A >= bound, break
.jump533:
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment B
	add qword [rsp + 8], 1
	jmp .jump530
.jump531: ; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	; Moving 24 bytes from rsp + 0 to rsp + 32
		mov r10, [rsp + 0 + 16]
		mov [rsp + 32 + 16], r10
		mov r10, [rsp + 0 + 8]
		mov [rsp + 32 + 8], r10
		mov r10, [rsp + 0 + 0]
		mov [rsp + 32 + 0], r10
	add rsp, 32
	sub rsp, 32
	sub rsp, 8 ; Align stack
	mov rax, [rel const106] ; 99.95
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	call _sqrt
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	call _exp
	sub rsp, 8
	movsd [rsp], xmm0
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	pop rsi
	movsd xmm0, [rsp]
	add rsp, 8
	lea rdi, [rsp + 8]
	call _d
	add rsp, 8 ; Remove alignment
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump534
	jmp .jump535
.jump534:
.jump535:
	sub rsp, 16
	; Moving 16 bytes from r12 - 32 to rsp
		mov r10, [r12 - 32 + 8]
		mov [rsp + 8], r10
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
	sub rsp, 8 ; Align stack
	call _g
	add rsp, 8 ; Remove alignment
	push rax
	pop rax
	cmp rax, 0
	je .jump536
	sub rsp, 16
	; Moving 16 bytes from r12 - 32 to rsp
		mov r10, [r12 - 32 + 8]
		mov [rsp + 8], r10
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
	jmp .jump537
.jump536:
	sub rsp, 16
	; Moving 16 bytes from rbp - 64 to rsp
		mov r10, [rbp - 64 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
.jump537:
.jump523:
	sub rsp, 8 ; Align stack
	call _g
	add rsp, 8 ; Remove alignment
	push rax
	pop rax
	cmp rax, 0
	je .jump538
	sub rsp, 8 ; Align stack
	call _g
	add rsp, 8 ; Remove alignment
	push rax
	jmp .jump539
.jump538:
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	; Moving 8 bytes from rsp + 0 to rsp + 0
		mov r10, [rsp + 0 + 0]
		mov [rsp + 0 + 0], r10
	add rsp, 0
.jump539:
	pop rax
	cmp rax, 0
	je .jump540
	sub rsp, 8
	; Moving 8 bytes from rbp - 80 to rsp
		mov r10, [rbp - 80 + 0]
		mov [rsp + 0], r10
	sub rsp, 32
	; Moving 32 bytes from rbp - 120 to rsp
		mov r10, [rbp - 120 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - 120 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - 120 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 120 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 152 to rsp
		mov r10, [rbp - 152 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - -120 to rsp
		mov r10, [rbp - -120 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - -16 to rsp
		mov r10, [r12 - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump542
	sub rsp, 8 ; Align stack
	lea rdi, [rel const5] ; negative array index
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump542:
	cmp rax, [rsp + 24]
	jl .jump543
	sub rsp, 8 ; Align stack
	lea rdi, [rel const6] ; index too large
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump543:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump544
	sub rsp, 8 ; Align stack
	lea rdi, [rel const5] ; negative array index
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump544:
	cmp rax, [rsp + 32]
	jl .jump545
	sub rsp, 8 ; Align stack
	lea rdi, [rel const6] ; index too large
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump545:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump546
	sub rsp, 8 ; Align stack
	lea rdi, [rel const5] ; negative array index
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump546:
	cmp rax, [rsp + 40]
	jl .jump547
	sub rsp, 8 ; Align stack
	lea rdi, [rel const6] ; index too large
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump547:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 8
	; Moving 8 bytes from rax to rsp
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump548
	sub rsp, 32
	; Moving 32 bytes from rbp - -40 to rsp
		mov r10, [rbp - -40 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - -40 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -40 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -40 + 0]
		mov [rsp + 0], r10
	jmp .jump549
.jump548:
	mov rax, [rel const1] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump550
	sub rsp, 32
	; Moving 32 bytes from rbp - -40 to rsp
		mov r10, [rbp - -40 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - -40 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -40 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -40 + 0]
		mov [rsp + 0], r10
	jmp .jump551
.jump550:
	sub rsp, 32
	; Moving 32 bytes from rbp - -40 to rsp
		mov r10, [rbp - -40 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - -40 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -40 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -40 + 0]
		mov [rsp + 0], r10
.jump551:
.jump549:
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	jmp .jump541
.jump540:
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for K
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump552
	sub rsp, 8
	; Moving 8 bytes from rbp - 88 to rsp
		mov r10, [rbp - 88 + 0]
		mov [rsp + 0], r10
	jmp .jump553
.jump552:
	sub rsp, 8
	; Moving 8 bytes from rbp - 152 to rsp
		mov r10, [rbp - 152 + 0]
		mov [rsp + 0], r10
.jump553:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump554
	lea rdi, [rel const2] ; non-positive loop bound
	call _fail_assertion
.jump554:
	; Computing bound for J
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	pop rdi
	call _b
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump555
	sub rsp, 8 ; Align stack
	lea rdi, [rel const2] ; non-positive loop bound
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump555:
	; Computing bound for I
	sub rsp, 8
	; Moving 8 bytes from rbp - 80 to rsp
		mov r10, [rbp - 80 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump556
	lea rdi, [rel const2] ; non-positive loop bound
	call _fail_assertion
.jump556:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int
	imul rdi, [rsp + 0 + 0] ; multiply by H
	jno .jump557
	lea rdi, [rel const3] ; overflow computing array size
	call _fail_assertion
.jump557:
	imul rdi, [rsp + 0 + 8] ; multiply by b(c)
	jno .jump558
	lea rdi, [rel const3] ; overflow computing array size
	call _fail_assertion
.jump558:
	imul rdi, [rsp + 0 + 16] ; multiply by (if c then G else B)
	jno .jump559
	lea rdi, [rel const3] ; overflow computing array size
	call _fail_assertion
.jump559:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize K to 0
	mov rax, 0
	push rax
	; Initialize J to 0
	mov rax, 0
	push rax
	; Initialize I to 0
	mov rax, 0
	push rax
.jump560: ; Begin body of loop
	; Compare K to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump562 ; If K >= bound, ...
	mov qword [rsp + 16], 0 ; K = 0
	add qword [rsp + 8], 1 ; J++
.jump562:
	; Compare J to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump563 ; If J >= bound, ...
	mov qword [rsp + 8], 0 ; J = 0
	add qword [rsp + 0], 1 ; I++
.jump563:
	; Compare I to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jge .jump561 ; If I >= bound, break
.jump564:
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 64 to rsp
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment K
	add qword [rsp + 16], 1
	jmp .jump560
.jump561: ; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - -24 to rsp
		mov r10, [rbp - -24 + 0]
		mov [rsp + 0], r10
.jump541:
	; Moving 32 bytes from rsp + 8 to rsp + 16
		mov r10, [rsp + 8 + 24]
		mov [rsp + 16 + 24], r10
		mov r10, [rsp + 8 + 16]
		mov [rsp + 16 + 16], r10
		mov r10, [rsp + 8 + 8]
		mov [rsp + 16 + 8], r10
		mov r10, [rsp + 8 + 0]
		mov [rsp + 16 + 0], r10
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rbp - 176 to rsp
		mov r10, [rbp - 176 + 0]
		mov [rsp + 0], r10
	sub rsp, 32
	mov rax, [rel const0] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump565
	mov rax, [rel const0] ; True
	push rax
	pop rax
.jump565:
	push rax
	pop rax
	cmp rax, 0
	je .jump566
	mov rax, [rel const107] ; 8.95
	push rax
	jmp .jump567
.jump566:
	mov rax, [rel const108] ; 64.96
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	call _log
	sub rsp, 8
	movsd [rsp], xmm0
.jump567:
	movsd xmm0, [rsp]
	add rsp, 8
	call _sqrt
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	call _tan
	sub rsp, 8
	movsd [rsp], xmm0
	sub rsp, 8
	; Moving 8 bytes from rbp - 176 to rsp
		mov r10, [rbp - 176 + 0]
		mov [rsp + 0], r10
	pop rsi
	movsd xmm0, [rsp]
	add rsp, 8
	lea rdi, [rsp + 0]
	call _d
	mov rax, [rbp - 8] ; Address to write return value into
	; Moving 32 bytes from rsp to rax
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 224 ; Local variables
	pop rbp
	ret

l:
_l:
	push rbp
	mov rbp, rsp
	call _l
	push rax
	pop rax
	add rsp, 0 ; Local variables
	pop rbp
	ret
	mov rax, [rel const0] ; True
	push rax
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	jne .jump570
	lea rdi, [rel const109] ; m
	call _fail_assertion
.jump570:
	mov rax, [rel const0] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump571
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for o
	sub rsp, 8 ; Align stack
	call _l
	add rsp, 8 ; Remove alignment
	push rax
	pop rax
	cmp rax, 0
	je .jump573
	mov rax, [rel const110] ; 333
	push rax
	jmp .jump574
.jump573:
	sub rsp, 8
	; Moving 8 bytes from r12 - 48 to rsp
		mov r10, [r12 - 48 + 0]
		mov [rsp + 0], r10
.jump574:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump575
	lea rdi, [rel const2] ; non-positive loop bound
	call _fail_assertion
.jump575:
	; Computing bound for n
	mov rax, [rel const1] ; False
	push rax
	pop rdi
	call _b
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump576
	sub rsp, 8 ; Align stack
	lea rdi, [rel const2] ; non-positive loop bound
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump576:
	; Computing bound for m
	mov rax, [rel const111] ; 633
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump577
	lea rdi, [rel const2] ; non-positive loop bound
	call _fail_assertion
.jump577:
	; Computing total size of heap memory to allocate
	mov rdi, 16 ; sizeof {bool,int}
	imul rdi, [rsp + 0 + 0] ; multiply by 633
	jno .jump578
	lea rdi, [rel const3] ; overflow computing array size
	call _fail_assertion
.jump578:
	imul rdi, [rsp + 0 + 8] ; multiply by b(false)
	jno .jump579
	lea rdi, [rel const3] ; overflow computing array size
	call _fail_assertion
.jump579:
	imul rdi, [rsp + 0 + 16] ; multiply by (if l() then 333 else k)
	jno .jump580
	lea rdi, [rel const3] ; overflow computing array size
	call _fail_assertion
.jump580:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize o to 0
	mov rax, 0
	push rax
	; Initialize n to 0
	mov rax, 0
	push rax
	; Initialize m to 0
	mov rax, 0
	push rax
.jump581: ; Begin body of loop
	; Compare o to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump583 ; If o >= bound, ...
	mov qword [rsp + 16], 0 ; o = 0
	add qword [rsp + 8], 1 ; n++
.jump583:
	; Compare n to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump584 ; If n >= bound, ...
	mov qword [rsp + 8], 0 ; n = 0
	add qword [rsp + 0], 1 ; m++
.jump584:
	; Compare m to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jge .jump582 ; If m >= bound, break
.jump585:
	; Compute loop body
	mov rax, [rel const112] ; 299
	push rax
	call _g
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 16
	add rax, [rsp + 64]
	; Move body (16 bytes) to index
	; Moving 16 bytes from rsp to rax
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 16
	; Increment o
	add qword [rsp + 16], 1
	jmp .jump581
.jump582: ; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	jmp .jump572
.jump571:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for o
	sub rsp, 8
	; Moving 8 bytes from r12 - 48 to rsp
		mov r10, [r12 - 48 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump586
	lea rdi, [rel const2] ; non-positive loop bound
	call _fail_assertion
.jump586:
	; Computing bound for n
	sub rsp, 8
	; Moving 8 bytes from r12 - 32 to rsp
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump587
	sub rsp, 8 ; Align stack
	lea rdi, [rel const2] ; non-positive loop bound
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump587:
	; Computing bound for m
	sub rsp, 8
	; Moving 8 bytes from r12 - -16 to rsp
		mov r10, [r12 - -16 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump588
	lea rdi, [rel const2] ; non-positive loop bound
	call _fail_assertion
.jump588:
	; Computing total size of heap memory to allocate
	mov rdi, 16 ; sizeof {bool,int}
	imul rdi, [rsp + 0 + 0] ; multiply by (- argnum)
	jno .jump589
	lea rdi, [rel const3] ; overflow computing array size
	call _fail_assertion
.jump589:
	imul rdi, [rsp + 0 + 8] ; multiply by f
	jno .jump590
	lea rdi, [rel const3] ; overflow computing array size
	call _fail_assertion
.jump590:
	imul rdi, [rsp + 0 + 16] ; multiply by k
	jno .jump591
	lea rdi, [rel const3] ; overflow computing array size
	call _fail_assertion
.jump591:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize o to 0
	mov rax, 0
	push rax
	; Initialize n to 0
	mov rax, 0
	push rax
	; Initialize m to 0
	mov rax, 0
	push rax
.jump592: ; Begin body of loop
	; Compare o to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump594 ; If o >= bound, ...
	mov qword [rsp + 16], 0 ; o = 0
	add qword [rsp + 8], 1 ; n++
.jump594:
	; Compare n to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump595 ; If n >= bound, ...
	mov qword [rsp + 8], 0 ; n = 0
	add qword [rsp + 0], 1 ; m++
.jump595:
	; Compare m to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jge .jump593 ; If m >= bound, break
.jump596:
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const1] ; False
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 16
	add rax, [rsp + 64]
	; Move body (16 bytes) to index
	; Moving 16 bytes from rsp to rax
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 16
	; Increment o
	add qword [rsp + 16], 1
	jmp .jump592
.jump593: ; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
.jump572:
	sub rsp, 8
	; Moving 8 bytes from r12 - 48 to rsp
		mov r10, [r12 - 48 + 0]
		mov [rsp + 0], r10
	sub rsp, 8 ; Align stack
	mov rax, [rel const1] ; False
	push rax
	pop rdi
	call _b
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rel const113] ; 624
	push rax
	pop rax
	pop r10
	cmp r10, 0
	jne .jump597
	sub rsp, 8 ; Align stack
	lea rdi, [rel const57] ; divide by zero
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump597:
	cqo
	idiv r10
	push rax
	pop rax
	neg rax
	push rax
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for n
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for o
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for o
	sub rsp, 8
	; Moving 8 bytes from r12 - -16 to rsp
		mov r10, [r12 - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump598
	lea rdi, [rel const2] ; non-positive loop bound
	call _fail_assertion
.jump598:
	; Computing bound for n
	sub rsp, 8
	; Moving 8 bytes from r12 - 48 to rsp
		mov r10, [r12 - 48 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump599
	sub rsp, 8 ; Align stack
	lea rdi, [rel const2] ; non-positive loop bound
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump599:
	; Computing bound for m
	sub rsp, 8
	; Moving 8 bytes from r12 - 32 to rsp
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump600
	lea rdi, [rel const2] ; non-positive loop bound
	call _fail_assertion
.jump600:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize o to 0
	mov rax, 0
	push rax
	; Initialize n to 0
	mov rax, 0
	push rax
	; Initialize m to 0
	mov rax, 0
	push rax
.jump601: ; Begin body of loop
	; Compare o to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump603 ; If o >= bound, ...
	mov qword [rsp + 16], 0 ; o = 0
	add qword [rsp + 8], 1 ; n++
.jump603:
	; Compare n to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump604 ; If n >= bound, ...
	mov qword [rsp + 8], 0 ; n = 0
	add qword [rsp + 0], 1 ; m++
.jump604:
	; Compare m to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jge .jump602 ; If m >= bound, break
.jump605:
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 112 to rsp
		mov r10, [rbp - 112 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment o
	add qword [rsp + 16], 1
	jmp .jump601
.jump602: ; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump606
	sub rsp, 8 ; Align stack
	lea rdi, [rel const2] ; non-positive loop bound
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump606:
	; Computing bound for n
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump607
	sub rsp, 8
	; Moving 8 bytes from r12 - -16 to rsp
		mov r10, [r12 - -16 + 0]
		mov [rsp + 0], r10
	jmp .jump608
.jump607:
	sub rsp, 8
	; Moving 8 bytes from r12 - 32 to rsp
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
.jump608:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump609
	lea rdi, [rel const2] ; non-positive loop bound
	call _fail_assertion
.jump609:
	; Computing bound for m
	sub rsp, 8
	; Moving 8 bytes from r12 - -16 to rsp
		mov r10, [r12 - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump610
	sub rsp, 8 ; Align stack
	lea rdi, [rel const2] ; non-positive loop bound
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump610:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize o to 0
	mov rax, 0
	push rax
	; Initialize n to 0
	mov rax, 0
	push rax
	; Initialize m to 0
	mov rax, 0
	push rax
.jump611: ; Begin body of loop
	; Compare o to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump613 ; If o >= bound, ...
	mov qword [rsp + 16], 0 ; o = 0
	add qword [rsp + 8], 1 ; n++
.jump613:
	; Compare n to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump614 ; If n >= bound, ...
	mov qword [rsp + 8], 0 ; n = 0
	add qword [rsp + 0], 1 ; m++
.jump614:
	; Compare m to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jge .jump612 ; If m >= bound, break
.jump615:
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment o
	add qword [rsp + 16], 1
	jmp .jump611
.jump612: ; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump616
	lea rdi, [rel const2] ; non-positive loop bound
	call _fail_assertion
.jump616:
	; Computing bound for m
	mov rax, [rel const114] ; 750
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump617
	sub rsp, 8 ; Align stack
	lea rdi, [rel const2] ; non-positive loop bound
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump617:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize n to 0
	mov rax, 0
	push rax
	; Initialize m to 0
	mov rax, 0
	push rax
.jump618: ; Begin body of loop
	; Compare n to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump620 ; If n >= bound, ...
	mov qword [rsp + 8], 0 ; n = 0
	add qword [rsp + 0], 1 ; m++
.jump620:
	; Compare m to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jge .jump619 ; If m >= bound, break
.jump621:
	; Compute loop body
	mov rax, [rel const115] ; 600
	push rax
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment n
	add qword [rsp + 8], 1
	jmp .jump618
.jump619: ; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump622
	sub rsp, 8 ; Align stack
	lea rdi, [rel const5] ; negative array index
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump622:
	cmp rax, [rsp + 24]
	jl .jump623
	sub rsp, 8 ; Align stack
	lea rdi, [rel const6] ; index too large
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump623:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump624
	sub rsp, 8 ; Align stack
	lea rdi, [rel const5] ; negative array index
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump624:
	cmp rax, [rsp + 32]
	jl .jump625
	sub rsp, 8 ; Align stack
	lea rdi, [rel const6] ; index too large
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump625:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump626
	sub rsp, 8 ; Align stack
	lea rdi, [rel const5] ; negative array index
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump626:
	cmp rax, [rsp + 40]
	jl .jump627
	sub rsp, 8 ; Align stack
	lea rdi, [rel const6] ; index too large
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump627:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 16
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 16
	; Moving 16 bytes from rax to rsp
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	; Moving 8 bytes from rsp + 0 to rsp + 8
		mov r10, [rsp + 0 + 0]
		mov [rsp + 8 + 0], r10
	add rsp, 8
	pop rax
	cmp rax, 0
	jne .jump628
	lea rdi, [rel const109] ; m
	call _fail_assertion
.jump628:
	mov rax, [rel const116] ; 65.67
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	call _exp
	sub rsp, 8
	movsd [rsp], xmm0
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	xor rax, 1
	push rax
	pop rax
	add rsp, 8 ; Local variables
	pop rbp
	ret

jpl_main:
_jpl_main:
	push rbp
	mov rbp, rsp
	push r12
	mov r12, rbp
	mov rax, [rel const1] ; False
	push rax
	mov rax, [rel const46] ; 679
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rel const47] ; 121
	push rax
	pop rax
	pop r10
	cmp rax, r10
	setge al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump199
	mov rax, [rel const1] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump201
	mov rax, [rel const0] ; True
	push rax
	pop rax
.jump201:
	push rax
	jmp .jump200
.jump199:
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rel const48] ; 300
	push rax
	mov rax, [rel const49] ; 227
	push rax
	pop rax
	pop r10
	sub rax, r10
	push rax
	pop rax
	pop r10
	cmp rax, r10
	setl al
	and rax, 1
	push rax
.jump200:
	pop rax
	pop r10
	cmp rax, r10
	setne al
	and rax, 1
	push rax
	pop rax
	xor rax, 1
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for f
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for e
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump359
	lea rdi, [rel const2] ; non-positive loop bound
	call _fail_assertion
.jump359:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize e to 0
	mov rax, 0
	push rax
.jump360: ; Begin body of loop
	; Compare e to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jge .jump361 ; If e >= bound, break
.jump362:
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment e
	add qword [rsp + 0], 1
	jmp .jump360
.jump361: ; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump363
	sub rsp, 8 ; Align stack
	lea rdi, [rel const2] ; non-positive loop bound
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump363:
	; Computing bound for e
	sub rsp, 8 ; Align stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	pop rdi
	call _b
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump364
	lea rdi, [rel const2] ; non-positive loop bound
	call _fail_assertion
.jump364:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int
	imul rdi, [rsp + 0 + 0] ; multiply by b(c)
	jno .jump365
	lea rdi, [rel const3] ; overflow computing array size
	call _fail_assertion
.jump365:
imul rdi, [rsp + 0 + 8] ; multiply by (sum[e : argnum] e)
	jno .jump366
	lea rdi, [rel const3] ; overflow computing array size
	call _fail_assertion
.jump366:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize f to 0
	mov rax, 0
	push rax
	; Initialize e to 0
	mov rax, 0
	push rax
.jump367: ; Begin body of loop
	; Compare f to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump369 ; If f >= bound, ...
	mov qword [rsp + 8], 0 ; f = 0
	add qword [rsp + 0], 1 ; e++
.jump369:
	; Compare e to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jge .jump368 ; If e >= bound, break
.jump370:
	; Compute loop body
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for h
	mov rax, [rel const79] ; 345
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump371
	lea rdi, [rel const2] ; non-positive loop bound
	call _fail_assertion
.jump371:
	; Computing bound for g
	mov rax, [rel const80] ; 436
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump372
	sub rsp, 8 ; Align stack
	lea rdi, [rel const2] ; non-positive loop bound
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump372:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize h to 0
	mov rax, 0
	push rax
	; Initialize g to 0
	mov rax, 0
	push rax
.jump373: ; Begin body of loop
	; Compare h to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump375 ; If h >= bound, ...
	mov qword [rsp + 8], 0 ; h = 0
	add qword [rsp + 0], 1 ; g++
.jump375:
	; Compare g to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jge .jump374 ; If g >= bound, break
.jump376:
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 104 to rsp
		mov r10, [rbp - 104 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment h
	add qword [rsp + 8], 1
	jmp .jump373
.jump374: ; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment f
	add qword [rsp + 8], 1
	jmp .jump367
.jump368: ; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	mov rax, [rel const81] ; 57.12
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	call _sin
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	call _to_int
	push rax
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for f
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump377
	sub rsp, 8 ; Align stack
	lea rdi, [rel const2] ; non-positive loop bound
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump377:
	; Computing bound for e
	mov rax, [rel const82] ; 366
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump378
	lea rdi, [rel const2] ; non-positive loop bound
	call _fail_assertion
.jump378:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int
	imul rdi, [rsp + 0 + 0] ; multiply by 366
	jno .jump379
	lea rdi, [rel const3] ; overflow computing array size
	call _fail_assertion
.jump379:
	imul rdi, [rsp + 0 + 8] ; multiply by argnum
	jno .jump380
	lea rdi, [rel const3] ; overflow computing array size
	call _fail_assertion
.jump380:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize f to 0
	mov rax, 0
	push rax
	; Initialize e to 0
	mov rax, 0
	push rax
.jump381: ; Begin body of loop
	; Compare f to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump383 ; If f >= bound, ...
	mov qword [rsp + 8], 0 ; f = 0
	add qword [rsp + 0], 1 ; e++
.jump383:
	; Compare e to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jge .jump382 ; If e >= bound, break
.jump384:
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment f
	add qword [rsp + 8], 1
	jmp .jump381
.jump382: ; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for e
	mov rax, [rel const83] ; 991
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump385
	lea rdi, [rel const2] ; non-positive loop bound
	call _fail_assertion
.jump385:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize e to 0
	mov rax, 0
	push rax
.jump386: ; Begin body of loop
	; Compare e to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jge .jump387 ; If e >= bound, break
.jump388:
	; Compute loop body
	mov rax, [rel const84] ; 102
	push rax
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment e
	add qword [rsp + 0], 1
	jmp .jump386
.jump387: ; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump389
	lea rdi, [rel const5] ; negative array index
	call _fail_assertion
.jump389:
	cmp rax, [rsp + 16]
	jl .jump390
	lea rdi, [rel const6] ; index too large
	call _fail_assertion
.jump390:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump391
	lea rdi, [rel const5] ; negative array index
	call _fail_assertion
.jump391:
	cmp rax, [rsp + 24]
	jl .jump392
	lea rdi, [rel const6] ; index too large
	call _fail_assertion
.jump392:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 8
	; Moving 8 bytes from rax to rsp
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump393
	lea rdi, [rel const5] ; negative array index
	call _fail_assertion
.jump393:
	cmp rax, [rsp + 16]
	jl .jump394
	lea rdi, [rel const6] ; index too large
	call _fail_assertion
.jump394:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump395
	lea rdi, [rel const5] ; negative array index
	call _fail_assertion
.jump395:
	cmp rax, [rsp + 24]
	jl .jump396
	lea rdi, [rel const6] ; index too large
	call _fail_assertion
.jump396:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 8
	; Moving 8 bytes from rax to rsp
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	setl al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump397
	sub rsp, 16
	; Moving 16 bytes from rbp - -16 to rsp
		mov r10, [rbp - -16 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	jmp .jump398
.jump397:
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	sub rsp, 8 ; Align stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	pop rdi
	call _b
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rel const85] ; 1.32
	push rax
	mov rax, [rel const86] ; 70.04
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	addsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	call _to_int
	push rax
	mov rdi, 24
	sub rsp, 8 ; Align stack
	call _jpl_alloc
	add rsp, 8 ; Remove alignment
	; Moving 24 bytes from rsp to rax
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 24
	push rax
	mov rax, 3
	push rax
.jump398:
	call _g
	push rax
	pop rax
	cmp rax, 0
	je .jump568
	sub rsp, 16
	; Moving 16 bytes from rbp - -16 to rsp
		mov r10, [rbp - -16 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	jmp .jump569
.jump568:
	sub rsp, 16
	; Moving 16 bytes from rbp - 32 to rsp
		mov r10, [rbp - 32 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
.jump569:
	; Moving 16 bytes from rsp + 8 to rsp + 8
		mov r10, [rsp + 8 + 8]
		mov [rsp + 8 + 8], r10
		mov r10, [rsp + 8 + 0]
		mov [rsp + 8 + 0], r10
	add rsp, 8
	; Moving 16 bytes from rsp + 0 to rsp + 0
		mov r10, [rsp + 0 + 8]
		mov [rsp + 0 + 8], r10
		mov r10, [rsp + 0 + 0]
		mov [rsp + 0 + 0], r10
	add rsp, 0
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for n
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	add rax, r10
	push rax
	pop rax
	neg rax
	push rax
	call _l
	push rax
	pop rax
	cmp rax, 0
	je .jump629
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	jmp .jump630
.jump629:
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for m
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump631
	lea rdi, [rel const2] ; non-positive loop bound
	call _fail_assertion
.jump631:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize m to 0
	mov rax, 0
	push rax
.jump632: ; Begin body of loop
	; Compare m to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jge .jump633 ; If m >= bound, break
.jump634:
	; Compute loop body
	sub rsp, 8 ; Align stack
	mov rax, [rel const117] ; 39.49
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	call _to_int
	add rsp, 8 ; Remove alignment
	push rax
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment m
	add qword [rsp + 0], 1
	jmp .jump632
.jump633: ; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
.jump630:
	pop rax
	pop r10
	cmp r10, 0
	jne .jump635
	sub rsp, 8 ; Align stack
	lea rdi, [rel const41] ; mod by zero
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump635:
	cqo
	idiv r10
	mov rax, rdx
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump636
	lea rdi, [rel const2] ; non-positive loop bound
	call _fail_assertion
.jump636:
	; Computing bound for m
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for o
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump637
	lea rdi, [rel const2] ; non-positive loop bound
	call _fail_assertion
.jump637:
	; Computing bound for n
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump638
	sub rsp, 8 ; Align stack
	lea rdi, [rel const2] ; non-positive loop bound
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump638:
	; Computing bound for m
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump639
	lea rdi, [rel const2] ; non-positive loop bound
	call _fail_assertion
.jump639:
	; Computing total size of heap memory to allocate
	mov rdi, 16 ; sizeof int[]
	imul rdi, [rsp + 0 + 0] ; multiply by f
	jno .jump640
	lea rdi, [rel const3] ; overflow computing array size
	call _fail_assertion
.jump640:
	imul rdi, [rsp + 0 + 8] ; multiply by f
	jno .jump641
	lea rdi, [rel const3] ; overflow computing array size
	call _fail_assertion
.jump641:
	imul rdi, [rsp + 0 + 16] ; multiply by f
	jno .jump642
	lea rdi, [rel const3] ; overflow computing array size
	call _fail_assertion
.jump642:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize o to 0
	mov rax, 0
	push rax
	; Initialize n to 0
	mov rax, 0
	push rax
	; Initialize m to 0
	mov rax, 0
	push rax
.jump643: ; Begin body of loop
	; Compare o to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump645 ; If o >= bound, ...
	mov qword [rsp + 16], 0 ; o = 0
	add qword [rsp + 8], 1 ; n++
.jump645:
	; Compare n to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump646 ; If n >= bound, ...
	mov qword [rsp + 8], 0 ; n = 0
	add qword [rsp + 0], 1 ; m++
.jump646:
	; Compare m to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jge .jump644 ; If m >= bound, break
.jump647:
	; Compute loop body
	sub rsp, 16
	; Moving 16 bytes from rbp - 32 to rsp
		mov r10, [rbp - 32 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 16
	add rax, [rsp + 64]
	; Move body (16 bytes) to index
	; Moving 16 bytes from rsp to rax
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 16
	; Increment o
	add qword [rsp + 16], 1
	jmp .jump643
.jump644: ; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	mov rax, [rel const1] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump648
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	jmp .jump649
.jump648:
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
.jump649:
	sub rsp, 8 ; Align stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	pop rdi
	call _b
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rel const1] ; False
	push rax
	pop rdi
	call _b
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump650
	sub rsp, 8 ; Align stack
	lea rdi, [rel const5] ; negative array index
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump650:
	cmp rax, [rsp + 24]
	jl .jump651
	sub rsp, 8 ; Align stack
	lea rdi, [rel const6] ; index too large
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump651:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump652
	sub rsp, 8 ; Align stack
	lea rdi, [rel const5] ; negative array index
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump652:
	cmp rax, [rsp + 32]
	jl .jump653
	sub rsp, 8 ; Align stack
	lea rdi, [rel const6] ; index too large
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump653:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump654
	sub rsp, 8 ; Align stack
	lea rdi, [rel const5] ; negative array index
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump654:
	cmp rax, [rsp + 40]
	jl .jump655
	sub rsp, 8 ; Align stack
	lea rdi, [rel const6] ; index too large
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump655:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 16
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 16
	; Moving 16 bytes from rax to rsp
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	pop rax
	pop r10
	cmp r10, 0
	jne .jump656
	lea rdi, [rel const41] ; mod by zero
	call _fail_assertion
.jump656:
	cqo
	idiv r10
	mov rax, rdx
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump657
	sub rsp, 8 ; Align stack
	lea rdi, [rel const5] ; negative array index
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump657:
	cmp rax, [rsp + 8]
	jl .jump658
	sub rsp, 8 ; Align stack
	lea rdi, [rel const6] ; index too large
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump658:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	sub rsp, 8 ; Align stack
	call _l
	add rsp, 8 ; Remove alignment
	push rax
	pop rax
	cmp rax, 0
	je .jump659
	mov rax, [rel const1] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump661
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	pop rax
.jump661:
	push rax
	jmp .jump660
.jump659:
	sub rsp, 8 ; Align stack
	call _l
	add rsp, 8 ; Remove alignment
	push rax
	pop rax
	cmp rax, 0
	jne .jump662
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	pop rax
.jump662:
	push rax
.jump660:
	pop rax
	cmp rax, 0
	je .jump663
	sub rsp, 8 ; Align stack
	call _l
	add rsp, 8 ; Remove alignment
	push rax
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump665
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	jmp .jump666
.jump665:
	sub rsp, 8 ; Align stack
	mov rax, [rel const1] ; False
	push rax
	pop rdi
	call _b
	add rsp, 8 ; Remove alignment
	push rax
.jump666:
	jmp .jump664
.jump663:
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	; Moving 8 bytes from rsp + 0 to rsp + 0
		mov r10, [rsp + 0 + 0]
		mov [rsp + 0 + 0], r10
	add rsp, 0
.jump664:
	pop rax
	pop r10
	add rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump667
	sub rsp, 8 ; Align stack
	lea rdi, [rel const2] ; non-positive loop bound
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump667:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool
imul rdi, [rsp + 0 + 0] ; multiply by ((if (if l() then (false && c) else (l() || c)) then (if (! l()) then f else b(false)) else {f}{0}) + (array[m : f, n : f, o : f] e)[b(false), b(c), (if false then f else f)][((- argnum) % f)])
	jno .jump668
	sub rsp, 8 ; Align stack
	lea rdi, [rel const3] ; overflow computing array size
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump668:
imul rdi, [rsp + 0 + 8] ; multiply by ((if l() then argnum else (sum[m : argnum] to_int(39.49))) % (- (f + argnum)))
	jno .jump669
	sub rsp, 8 ; Align stack
	lea rdi, [rel const3] ; overflow computing array size
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump669:
	sub rsp, 8 ; Align stack
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize n to 0
	mov rax, 0
	push rax
	; Initialize m to 0
	mov rax, 0
	push rax
.jump670: ; Begin body of loop
	; Compare n to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump672 ; If n >= bound, ...
	mov qword [rsp + 8], 0 ; n = 0
	add qword [rsp + 0], 1 ; m++
.jump672:
	; Compare m to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jge .jump671 ; If m >= bound, break
.jump673:
	; Compute loop body
	sub rsp, 8 ; Align stack
	call _l
	add rsp, 8 ; Remove alignment
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment n
	add qword [rsp + 8], 1
	jmp .jump670
.jump671: ; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	sub rsp, 32
	sub rsp, 8 ; Align stack
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for r
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump674
	lea rdi, [rel const2] ; non-positive loop bound
	call _fail_assertion
.jump674:
	; Computing bound for q
	call _l
	push rax
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump675
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	jmp .jump676
.jump675:
	mov rax, [rel const118] ; 654
	push rax
.jump676:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump677
	sub rsp, 8 ; Align stack
	lea rdi, [rel const2] ; non-positive loop bound
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump677:
	; Computing bound for p
	sub rsp, 16
	; Moving 16 bytes from rbp - -16 to rsp
		mov r10, [rbp - -16 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for p
	sub rsp, 8
	; Moving 8 bytes from rbp - 64 to rsp
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump678
	sub rsp, 8 ; Align stack
	lea rdi, [rel const2] ; non-positive loop bound
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump678:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize p to 0
	mov rax, 0
	push rax
.jump679: ; Begin body of loop
	; Compare p to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jge .jump680 ; If p >= bound, break
.jump681:
	; Compute loop body
	mov rax, [rel const119] ; 83
	push rax
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment p
	add qword [rsp + 0], 1
	jmp .jump679
.jump680: ; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump682
	lea rdi, [rel const5] ; negative array index
	call _fail_assertion
.jump682:
	cmp rax, [rsp + 8]
	jl .jump683
	lea rdi, [rel const6] ; index too large
	call _fail_assertion
.jump683:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump684
	lea rdi, [rel const2] ; non-positive loop bound
	call _fail_assertion
.jump684:
	; Computing total size of heap memory to allocate
	mov rdi, 16 ; sizeof float[]
imul rdi, [rsp + 0 + 0] ; multiply by args[(sum[p : o] 83)]
	jno .jump685
	lea rdi, [rel const3] ; overflow computing array size
	call _fail_assertion
.jump685:
	imul rdi, [rsp + 0 + 8] ; multiply by (if (! l()) then n else 654)
	jno .jump686
	lea rdi, [rel const3] ; overflow computing array size
	call _fail_assertion
.jump686:
	imul rdi, [rsp + 0 + 16] ; multiply by argnum
	jno .jump687
	lea rdi, [rel const3] ; overflow computing array size
	call _fail_assertion
.jump687:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize r to 0
	mov rax, 0
	push rax
	; Initialize q to 0
	mov rax, 0
	push rax
	; Initialize p to 0
	mov rax, 0
	push rax
.jump688: ; Begin body of loop
	; Compare r to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump690 ; If r >= bound, ...
	mov qword [rsp + 16], 0 ; r = 0
	add qword [rsp + 8], 1 ; q++
.jump690:
	; Compare q to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump691 ; If q >= bound, ...
	mov qword [rsp + 8], 0 ; q = 0
	add qword [rsp + 0], 1 ; p++
.jump691:
	; Compare p to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jge .jump689 ; If p >= bound, break
.jump692:
	; Compute loop body
	sub rsp, 8 ; Align stack
	call _l
	add rsp, 8 ; Remove alignment
	push rax
	pop rax
	cmp rax, 0
	je .jump693
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for s
	sub rsp, 8
	; Moving 8 bytes from rbp - 160 to rsp
		mov r10, [rbp - 160 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump695
	sub rsp, 8 ; Align stack
	lea rdi, [rel const2] ; non-positive loop bound
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump695:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof float
	imul rdi, [rsp + 0 + 0] ; multiply by q
	jno .jump696
	sub rsp, 8 ; Align stack
	lea rdi, [rel const3] ; overflow computing array size
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump696:
	sub rsp, 8 ; Align stack
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize s to 0
	mov rax, 0
	push rax
.jump697: ; Begin body of loop
	; Compare s to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jge .jump698 ; If s >= bound, break
.jump699:
	; Compute loop body
	mov rax, [rel const120] ; 30.4
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 24]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment s
	add qword [rsp + 0], 1
	jmp .jump697
.jump698: ; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	jmp .jump694
.jump693:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for s
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump700
	sub rsp, 8 ; Align stack
	lea rdi, [rel const2] ; non-positive loop bound
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump700:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof float
	imul rdi, [rsp + 0 + 0] ; multiply by argnum
	jno .jump701
	sub rsp, 8 ; Align stack
	lea rdi, [rel const3] ; overflow computing array size
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump701:
	sub rsp, 8 ; Align stack
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize s to 0
	mov rax, 0
	push rax
.jump702: ; Begin body of loop
	; Compare s to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jge .jump703 ; If s >= bound, break
.jump704:
	; Compute loop body
	mov rax, [rel const121] ; 29.99
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 24]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment s
	add qword [rsp + 0], 1
	jmp .jump702
.jump703: ; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
.jump694:
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 16
	add rax, [rsp + 64]
	; Move body (16 bytes) to index
	; Moving 16 bytes from rsp to rax
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 16
	; Increment r
	add qword [rsp + 16], 1
	jmp .jump688
.jump689: ; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	call _l
	push rax
	pop rax
	cmp rax, 0
	je .jump705
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for r
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump707
	lea rdi, [rel const2] ; non-positive loop bound
	call _fail_assertion
.jump707:
	; Computing bound for q
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump708
	sub rsp, 8 ; Align stack
	lea rdi, [rel const2] ; non-positive loop bound
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump708:
	; Computing bound for p
	sub rsp, 8
	; Moving 8 bytes from rbp - 64 to rsp
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump709
	lea rdi, [rel const2] ; non-positive loop bound
	call _fail_assertion
.jump709:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int
	imul rdi, [rsp + 0 + 0] ; multiply by o
	jno .jump710
	lea rdi, [rel const3] ; overflow computing array size
	call _fail_assertion
.jump710:
	imul rdi, [rsp + 0 + 8] ; multiply by argnum
	jno .jump711
	lea rdi, [rel const3] ; overflow computing array size
	call _fail_assertion
.jump711:
	imul rdi, [rsp + 0 + 16] ; multiply by n
	jno .jump712
	lea rdi, [rel const3] ; overflow computing array size
	call _fail_assertion
.jump712:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize r to 0
	mov rax, 0
	push rax
	; Initialize q to 0
	mov rax, 0
	push rax
	; Initialize p to 0
	mov rax, 0
	push rax
.jump713: ; Begin body of loop
	; Compare r to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump715 ; If r >= bound, ...
	mov qword [rsp + 16], 0 ; r = 0
	add qword [rsp + 8], 1 ; q++
.jump715:
	; Compare q to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump716 ; If q >= bound, ...
	mov qword [rsp + 8], 0 ; q = 0
	add qword [rsp + 0], 1 ; p++
.jump716:
	; Compare p to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jge .jump714 ; If p >= bound, break
.jump717:
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment r
	add qword [rsp + 16], 1
	jmp .jump713
.jump714: ; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	jmp .jump706
.jump705:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for r
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump718
	lea rdi, [rel const2] ; non-positive loop bound
	call _fail_assertion
.jump718:
	; Computing bound for q
	mov rax, [rel const122] ; 20
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump719
	sub rsp, 8 ; Align stack
	lea rdi, [rel const2] ; non-positive loop bound
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump719:
	; Computing bound for p
	mov rax, [rel const123] ; 267
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump720
	lea rdi, [rel const2] ; non-positive loop bound
	call _fail_assertion
.jump720:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int
	imul rdi, [rsp + 0 + 0] ; multiply by 267
	jno .jump721
	lea rdi, [rel const3] ; overflow computing array size
	call _fail_assertion
.jump721:
	imul rdi, [rsp + 0 + 8] ; multiply by 20
	jno .jump722
	lea rdi, [rel const3] ; overflow computing array size
	call _fail_assertion
.jump722:
	imul rdi, [rsp + 0 + 16] ; multiply by argnum
	jno .jump723
	lea rdi, [rel const3] ; overflow computing array size
	call _fail_assertion
.jump723:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize r to 0
	mov rax, 0
	push rax
	; Initialize q to 0
	mov rax, 0
	push rax
	; Initialize p to 0
	mov rax, 0
	push rax
.jump724: ; Begin body of loop
	; Compare r to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump726 ; If r >= bound, ...
	mov qword [rsp + 16], 0 ; r = 0
	add qword [rsp + 8], 1 ; q++
.jump726:
	; Compare q to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump727 ; If q >= bound, ...
	mov qword [rsp + 8], 0 ; q = 0
	add qword [rsp + 0], 1 ; p++
.jump727:
	; Compare p to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jge .jump725 ; If p >= bound, break
.jump728:
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment r
	add qword [rsp + 16], 1
	jmp .jump724
.jump725: ; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
.jump706:
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 64 to rsp
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const124] ; 55.23
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	call _sin
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	call _to_int
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump729
	sub rsp, 8 ; Align stack
	lea rdi, [rel const5] ; negative array index
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump729:
	cmp rax, [rsp + 24]
	jl .jump730
	sub rsp, 8 ; Align stack
	lea rdi, [rel const6] ; index too large
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump730:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump731
	sub rsp, 8 ; Align stack
	lea rdi, [rel const5] ; negative array index
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump731:
	cmp rax, [rsp + 32]
	jl .jump732
	sub rsp, 8 ; Align stack
	lea rdi, [rel const6] ; index too large
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump732:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump733
	sub rsp, 8 ; Align stack
	lea rdi, [rel const5] ; negative array index
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump733:
	cmp rax, [rsp + 40]
	jl .jump734
	sub rsp, 8 ; Align stack
	lea rdi, [rel const6] ; index too large
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump734:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 8
	; Moving 8 bytes from rax to rsp
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump735
	sub rsp, 8 ; Align stack
	lea rdi, [rel const5] ; negative array index
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump735:
	cmp rax, [rsp + 24]
	jl .jump736
	sub rsp, 8 ; Align stack
	lea rdi, [rel const6] ; index too large
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump736:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump737
	sub rsp, 8 ; Align stack
	lea rdi, [rel const5] ; negative array index
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump737:
	cmp rax, [rsp + 32]
	jl .jump738
	sub rsp, 8 ; Align stack
	lea rdi, [rel const6] ; index too large
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump738:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump739
	sub rsp, 8 ; Align stack
	lea rdi, [rel const5] ; negative array index
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump739:
	cmp rax, [rsp + 40]
	jl .jump740
	sub rsp, 8 ; Align stack
	lea rdi, [rel const6] ; index too large
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump740:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 16
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 16
	; Moving 16 bytes from rax to rsp
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	lea rdi, [rsp + 24]
	call _h
	add rsp, 16
	add rsp, 8 ; Remove alignment
	add rsp, 96 ; Local variables
	pop r12
	pop rbp
	ret

