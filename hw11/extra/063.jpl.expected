global jpl_main
global _jpl_main
extern _fail_assertion
extern _jpl_alloc
extern _get_time
extern _show
extern _print
extern _print_time
extern _read_image
extern _write_image
extern _fmod
extern _sqrt
extern _exp
extern _sin
extern _cos
extern _tan
extern _asin
extern _acos
extern _atan
extern _log
extern _pow
extern _atan2
extern _to_int
extern _to_float

section .data
const0: db `non-positive loop bound`, 0
const1: db `overflow computing array size`, 0
const2: dq 445
const3: dq 0
const4: db `mod by zero`, 0
const5: db `negative array index`, 0
const6: db `index too large`, 0
const7: dq 1
const8: dq 62.31
const9: dq 39.83
const10: dq 331
const11: dq 5.92
const12: dq 27.64
const13: dq 741
const14: db `b`, 0
const15: dq 77.77
const16: dq 110
const17: dq 58
const18: dq 583
const19: dq 370
const20: dq 368
const21: dq 67
const22: db `divide by zero`, 0
const23: dq 802
const24: dq 29
const25: dq 430
const26: dq 790
const27: dq 355
const28: dq 667
const29: dq 930
const30: dq 269
const31: dq 194
const32: dq 415
const33: dq 602
const34: dq 312
const35: dq 16.61
const36: dq 6.55
const37: dq 14.62
const38: dq 532
const39: dq 981
const40: dq 918
const41: dq 96.3
const42: dq 92
const43: dq 784
const44: dq 47.07
const45: dq 78.94
const46: dq 25.63
const47: db `c`, 0
const48: dq 37.2
const49: dq 46.95
const50: dq 1.28
const51: dq 75.87
const52: dq 78.12
const53: dq 975
const54: dq 89.1
const55: dq 11.88
const56: dq 352
const57: dq 90.34
const58: dq 21.62
const59: dq 97
const60: dq 113
const61: dq 2
const62: dq 549
const63: dq 91.5
const64: dq 30.11
const65: db `k`, 0
const66: dq 510
const67: dq 43.04
const68: dq 530
const69: dq 359
const70: dq 768
const71: dq 873
const72: dq 117
const73: dq 59.59
const74: dq 708
const75: dq 281
const76: dq 78
const77: dq 482
const78: dq 63
const79: dq 648
const80: dq 766
const81: dq 365
const82: dq 206
const83: dq 99.48
const84: dq 42.8
const85: dq 35.05
const86: dq 55.92
const87: dq 2.97
const88: dq 778
const89: dq 833
const90: dq 76
const91: dq 737
const92: dq 828
const93: dq 55
const94: dq 947
const95: dq 511
const96: db `f`, 0
const97: dq 424
const98: dq 387
const99: dq 372
const100: dq 339
const101: dq 965
const102: dq 739
const103: dq 910
const104: dq 85.94
const105: dq 204
const106: dq 305
const107: dq 460
const108: dq 961
const109: dq 11
const110: dq 622
const111: dq 29.7
const112: dq 621
const113: dq 880
const114: dq 487
const115: dq 876
const116: dq 293
const117: dq 131
const118: dq 105
const119: dq 516
const120: dq 93.89
const121: dq 22
const122: dq 54.22
const123: dq 922
const124: dq 60.82
const125: dq 172
const126: dq 640
const127: dq 173
const128: dq 49.37
const129: dq 128
const130: dq 27.43
const131: dq 830
const132: dq 68
const133: dq 395
const134: dq 48.33
const135: dq 449
const136: dq 45
const137: dq 620
const138: dq 310
const139: dq 815
const140: dq 70.78
const141: dq 12.11
const142: dq 45.73
const143: dq 586
const144: dq 9.31
const145: dq 62.21
const146: db `j.png`, 0
const147: dq 28
const148: dq 14.89
const149: dq 59.1
const150: dq 86.34
const151: dq 90.56
const152: dq 76.42
const153: dq 70.74
const154: dq 7.75
const155: dq 73.68
const156: dq 120
const157: dq 11.08
const158: db `p`, 0
const159: dq 38
const160: dq 25.25
const161: dq 85.7
const162: dq 43.65
const163: dq 60.59
const164: db `k.png`, 0
const165: dq 970
const166: dq 721
const167: dq 4.7
const168: dq 564
const169: dq 59.89
const170: dq 94.92

section .text
a:
_a:
	push rbp
	mov rbp, rsp
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for p
	sub rsp, 8
	; Moving 8 bytes from rbp - -88 to rsp
		mov r10, [rbp - -88 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump1
	lea rdi, [rel const0] ; non-positive loop bound
	call _fail_assertion
.jump1:
	; Computing bound for o
	sub rsp, 8
	; Moving 8 bytes from rbp - -104 to rsp
		mov r10, [rbp - -104 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump2
	sub rsp, 8 ; Align stack
	lea rdi, [rel const0] ; non-positive loop bound
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump2:
	; Computing total size of heap memory to allocate
	mov rdi, 16 ; sizeof int[]
	imul rdi, [rsp + 0 + 0] ; multiply by n
	jno .jump3
	sub rsp, 8 ; Align stack
	lea rdi, [rel const1] ; overflow computing array size
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3:
	imul rdi, [rsp + 0 + 8] ; multiply by l
	jno .jump4
	sub rsp, 8 ; Align stack
	lea rdi, [rel const1] ; overflow computing array size
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump4:
	sub rsp, 8 ; Align stack
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize p to 0
	mov rax, 0
	push rax
	; Initialize o to 0
	mov rax, 0
	push rax
.jump5: ; Begin body of loop
	; Compare p to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump7 ; If p >= bound, ...
	mov qword [rsp + 8], 0 ; p = 0
	add qword [rsp + 0], 1 ; o++
.jump7:
	; Compare o to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jge .jump6 ; If o >= bound, break
.jump8:
	; Compute loop body
	sub rsp, 16
	; Moving 16 bytes from r12 - -16 to rsp
		mov r10, [r12 - -16 + 8]
		mov [rsp + 8], r10
		mov r10, [r12 - -16 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 16
	add rax, [rsp + 48]
	; Move body (16 bytes) to index
	; Moving 16 bytes from rsp to rax
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 16
	; Increment p
	add qword [rsp + 8], 1
	jmp .jump5
.jump6: ; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	; Moving 24 bytes from rsp + 0 to rsp + 0
		mov r10, [rsp + 0 + 16]
		mov [rsp + 0 + 16], r10
		mov r10, [rsp + 0 + 8]
		mov [rsp + 0 + 8], r10
		mov r10, [rsp + 0 + 0]
		mov [rsp + 0 + 0], r10
	add rsp, 0
	; Moving 24 bytes from rsp + 0 to rsp + 0
		mov r10, [rsp + 0 + 16]
		mov [rsp + 0 + 16], r10
		mov r10, [rsp + 0 + 8]
		mov [rsp + 0 + 8], r10
		mov r10, [rsp + 0 + 0]
		mov [rsp + 0 + 0], r10
	add rsp, 0
	sub rsp, 32
	; Moving 32 bytes from rbp - -88 to rsp
		mov r10, [rbp - -88 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - -88 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -88 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -88 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const2] ; 445
	push rax
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for s
	sub rsp, 8
	; Moving 8 bytes from rbp - -88 to rsp
		mov r10, [rbp - -88 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump9
	lea rdi, [rel const0] ; non-positive loop bound
	call _fail_assertion
.jump9:
	; Computing bound for r
	sub rsp, 8
	; Moving 8 bytes from rbp - -56 to rsp
		mov r10, [rbp - -56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump10
	sub rsp, 8 ; Align stack
	lea rdi, [rel const0] ; non-positive loop bound
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump10:
	; Computing total size of heap memory to allocate
	mov rdi, 32 ; sizeof bool[,,]
	imul rdi, [rsp + 0 + 0] ; multiply by h
	jno .jump11
	sub rsp, 8 ; Align stack
	lea rdi, [rel const1] ; overflow computing array size
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump11:
	imul rdi, [rsp + 0 + 8] ; multiply by l
	jno .jump12
	sub rsp, 8 ; Align stack
	lea rdi, [rel const1] ; overflow computing array size
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump12:
	sub rsp, 8 ; Align stack
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize s to 0
	mov rax, 0
	push rax
	; Initialize r to 0
	mov rax, 0
	push rax
.jump13: ; Begin body of loop
	; Compare s to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump15 ; If s >= bound, ...
	mov qword [rsp + 8], 0 ; s = 0
	add qword [rsp + 0], 1 ; r++
.jump15:
	; Compare r to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jge .jump14 ; If r >= bound, break
.jump16:
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for v
	sub rsp, 8
	; Moving 8 bytes from rbp - -96 to rsp
		mov r10, [rbp - -96 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump17
	sub rsp, 8 ; Align stack
	lea rdi, [rel const0] ; non-positive loop bound
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump17:
	; Computing bound for u
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump18
	lea rdi, [rel const0] ; non-positive loop bound
	call _fail_assertion
.jump18:
	; Computing bound for t
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump19
	sub rsp, 8 ; Align stack
	lea rdi, [rel const0] ; non-positive loop bound
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump19:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool
	imul rdi, [rsp + 0 + 0] ; multiply by q
	jno .jump20
	sub rsp, 8 ; Align stack
	lea rdi, [rel const1] ; overflow computing array size
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump20:
	imul rdi, [rsp + 0 + 8] ; multiply by p
	jno .jump21
	sub rsp, 8 ; Align stack
	lea rdi, [rel const1] ; overflow computing array size
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump21:
	imul rdi, [rsp + 0 + 16] ; multiply by m
	jno .jump22
	sub rsp, 8 ; Align stack
	lea rdi, [rel const1] ; overflow computing array size
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump22:
	sub rsp, 8 ; Align stack
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize v to 0
	mov rax, 0
	push rax
	; Initialize u to 0
	mov rax, 0
	push rax
	; Initialize t to 0
	mov rax, 0
	push rax
.jump23: ; Begin body of loop
	; Compare v to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump25 ; If v >= bound, ...
	mov qword [rsp + 16], 0 ; v = 0
	add qword [rsp + 8], 1 ; u++
.jump25:
	; Compare u to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump26 ; If u >= bound, ...
	mov qword [rsp + 8], 0 ; u = 0
	add qword [rsp + 0], 1 ; t++
.jump26:
	; Compare t to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jge .jump24 ; If t >= bound, break
.jump27:
	; Compute loop body
	mov rax, [rel const3] ; False
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment v
	add qword [rsp + 16], 1
	jmp .jump23
.jump24: ; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, 32
	add rax, [rsp + 64]
	; Move body (32 bytes) to index
	; Moving 32 bytes from rsp to rax
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	; Increment s
	add qword [rsp + 8], 1
	jmp .jump13
.jump14: ; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - -88 to rsp
		mov r10, [rbp - -88 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - -48 to rsp
		mov r10, [rbp - -48 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp r10, 0
	jne .jump28
	lea rdi, [rel const4] ; mod by zero
	call _fail_assertion
.jump28:
	cqo
	idiv r10
	mov rax, rdx
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump29
	sub rsp, 8 ; Align stack
	lea rdi, [rel const5] ; negative array index
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump29:
	cmp rax, [rsp + 16]
	jl .jump30
	sub rsp, 8 ; Align stack
	lea rdi, [rel const6] ; index too large
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump30:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump31
	sub rsp, 8 ; Align stack
	lea rdi, [rel const5] ; negative array index
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump31:
	cmp rax, [rsp + 24]
	jl .jump32
	sub rsp, 8 ; Align stack
	lea rdi, [rel const6] ; index too large
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump32:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 32
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 32
	; Moving 32 bytes from rax to rsp
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	; Moving 32 bytes from rsp + 0 to rsp + 40
		mov r10, [rsp + 0 + 24]
		mov [rsp + 40 + 24], r10
		mov r10, [rsp + 0 + 16]
		mov [rsp + 40 + 16], r10
		mov r10, [rsp + 0 + 8]
		mov [rsp + 40 + 8], r10
		mov r10, [rsp + 0 + 0]
		mov [rsp + 40 + 0], r10
	add rsp, 40
	mov rax, [rel const7] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump33
	mov rax, [rel const7] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump35
	mov rax, [rel const3] ; False
	push rax
	pop rax
.jump35:
	push rax
	sub rsp, 24
	; Moving 24 bytes from rbp - -16 to rsp
		mov r10, [rbp - -16 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -16 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - -24 to rsp
		mov r10, [rbp - -24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump36
	sub rsp, 8 ; Align stack
	lea rdi, [rel const5] ; negative array index
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump36:
	cmp rax, [rsp + 16]
	jl .jump37
	sub rsp, 8 ; Align stack
	lea rdi, [rel const6] ; index too large
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump37:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump38
	sub rsp, 8 ; Align stack
	lea rdi, [rel const5] ; negative array index
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump38:
	cmp rax, [rsp + 24]
	jl .jump39
	sub rsp, 8 ; Align stack
	lea rdi, [rel const6] ; index too large
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump39:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 8
	; Moving 8 bytes from rax to rsp
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	sub rsp, 16
	; Moving 16 bytes from rbp - -72 to rsp
		mov r10, [rbp - -72 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -72 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump40
	lea rdi, [rel const5] ; negative array index
	call _fail_assertion
.jump40:
	cmp rax, [rsp + 8]
	jl .jump41
	lea rdi, [rel const6] ; index too large
	call _fail_assertion
.jump41:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rdi, 24
	call _jpl_alloc
	; Moving 24 bytes from rsp to rax
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 24
	push rax
	mov rax, 3
	push rax
	jmp .jump34
.jump33:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for v
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for w
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump42
	lea rdi, [rel const0] ; non-positive loop bound
	call _fail_assertion
.jump42:
	; Computing bound for v
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump43
	sub rsp, 8 ; Align stack
	lea rdi, [rel const0] ; non-positive loop bound
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump43:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize w to 0
	mov rax, 0
	push rax
	; Initialize v to 0
	mov rax, 0
	push rax
.jump44: ; Begin body of loop
	; Compare w to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump46 ; If w >= bound, ...
	mov qword [rsp + 8], 0 ; w = 0
	add qword [rsp + 0], 1 ; v++
.jump46:
	; Compare v to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jge .jump45 ; If v >= bound, break
.jump47:
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - -88 to rsp
		mov r10, [rbp - -88 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment w
	add qword [rsp + 8], 1
	jmp .jump44
.jump45: ; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump48
	sub rsp, 8 ; Align stack
	lea rdi, [rel const0] ; non-positive loop bound
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump48:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool
imul rdi, [rsp + 0 + 0] ; multiply by (sum[v : t, w : p] l)
	jno .jump49
	sub rsp, 8 ; Align stack
	lea rdi, [rel const1] ; overflow computing array size
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump49:
	sub rsp, 8 ; Align stack
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize v to 0
	mov rax, 0
	push rax
.jump50: ; Begin body of loop
	; Compare v to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jge .jump51 ; If v >= bound, break
.jump52:
	; Compute loop body
	sub rsp, 16
	; Moving 16 bytes from rbp - -72 to rsp
		mov r10, [rbp - -72 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -72 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump53
	sub rsp, 8 ; Align stack
	lea rdi, [rel const5] ; negative array index
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump53:
	cmp rax, [rsp + 8]
	jl .jump54
	sub rsp, 8 ; Align stack
	lea rdi, [rel const6] ; index too large
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump54:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 24]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment v
	add qword [rsp + 0], 1
	jmp .jump50
.jump51: ; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
.jump34:
	sub rsp, 8
	; Moving 8 bytes from rbp - -96 to rsp
		mov r10, [rbp - -96 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump55
	lea rdi, [rel const5] ; negative array index
	call _fail_assertion
.jump55:
	cmp rax, [rsp + 8]
	jl .jump56
	lea rdi, [rel const6] ; index too large
	call _fail_assertion
.jump56:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump57
	sub rsp, 8 ; Align stack
	mov rax, [rel const8] ; 62.31
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	call _log
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	call _sqrt
	sub rsp, 8
	movsd [rsp], xmm0
	sub rsp, 8 ; Align stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	pop rdi
	call _to_float
	add rsp, 8 ; Remove alignment
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	call _pow
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	call _acos
	add rsp, 8 ; Remove alignment
	sub rsp, 8
	movsd [rsp], xmm0
	jmp .jump58
.jump57:
	sub rsp, 8 ; Align stack
	sub rsp, 8
	; Moving 8 bytes from rbp - -40 to rsp
		mov r10, [rbp - -40 + 0]
		mov [rsp + 0], r10
	pop rdi
	call _to_float
	add rsp, 8 ; Remove alignment
	sub rsp, 8
	movsd [rsp], xmm0
.jump58:
	movsd xmm0, [rsp]
	add rsp, 8
	add rsp, 56 ; Local variables
	pop rbp
	ret
	sub rsp, 8 ; Align stack
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for w
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump59
	lea rdi, [rel const0] ; non-positive loop bound
	call _fail_assertion
.jump59:
	; Computing bound for v
	sub rsp, 8
	; Moving 8 bytes from rbp - -40 to rsp
		mov r10, [rbp - -40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump60
	sub rsp, 8 ; Align stack
	lea rdi, [rel const0] ; non-positive loop bound
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump60:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool
	imul rdi, [rsp + 0 + 0] ; multiply by f
	jno .jump61
	sub rsp, 8 ; Align stack
	lea rdi, [rel const1] ; overflow computing array size
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump61:
	imul rdi, [rsp + 0 + 8] ; multiply by t
	jno .jump62
	sub rsp, 8 ; Align stack
	lea rdi, [rel const1] ; overflow computing array size
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump62:
	sub rsp, 8 ; Align stack
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize w to 0
	mov rax, 0
	push rax
	; Initialize v to 0
	mov rax, 0
	push rax
.jump63: ; Begin body of loop
	; Compare w to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump65 ; If w >= bound, ...
	mov qword [rsp + 8], 0 ; w = 0
	add qword [rsp + 0], 1 ; v++
.jump65:
	; Compare v to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jge .jump64 ; If v >= bound, break
.jump66:
	; Compute loop body
	mov rax, [rel const7] ; True
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment w
	add qword [rsp + 8], 1
	jmp .jump63
.jump64: ; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - -48 to rsp
		mov r10, [rbp - -48 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - -72 to rsp
		mov r10, [rbp - -72 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump67
	sub rsp, 8 ; Align stack
	lea rdi, [rel const5] ; negative array index
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump67:
	cmp rax, [rsp + 16]
	jl .jump68
	sub rsp, 8 ; Align stack
	lea rdi, [rel const6] ; index too large
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump68:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump69
	sub rsp, 8 ; Align stack
	lea rdi, [rel const5] ; negative array index
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump69:
	cmp rax, [rsp + 24]
	jl .jump70
	sub rsp, 8 ; Align stack
	lea rdi, [rel const6] ; index too large
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump70:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 8
	; Moving 8 bytes from rax to rsp
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump71
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - -24 to rsp
		mov r10, [rbp - -24 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	imul rax, r10
	push rax
	jmp .jump72
.jump71:
	sub rsp, 8
	; Moving 8 bytes from rbp - -48 to rsp
		mov r10, [rbp - -48 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
.jump72:
	pop rdi
	call _to_float
	add rsp, 8 ; Remove alignment
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	add rsp, 56 ; Local variables
	pop rbp
	ret
	sub rsp, 8 ; Align stack
	sub rsp, 8
	; Moving 8 bytes from rbp - -24 to rsp
		mov r10, [rbp - -24 + 0]
		mov [rsp + 0], r10
	pop rdi
	call _to_float
	sub rsp, 8
	movsd [rsp], xmm0
	sub rsp, 8 ; Align stack
	mov rax, [rel const9] ; 39.83
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	call _atan
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	call _sin
	add rsp, 8 ; Remove alignment
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmpeqsd xmm0, xmm1
	movq rax, xmm0
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump73
	mov rax, [rel const3] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump75
	sub rsp, 8
	; Moving 8 bytes from rbp - -48 to rsp
		mov r10, [rbp - -48 + 0]
		mov [rsp + 0], r10
	jmp .jump76
.jump75:
	sub rsp, 8
	; Moving 8 bytes from rbp - -40 to rsp
		mov r10, [rbp - -40 + 0]
		mov [rsp + 0], r10
.jump76:
	sub rsp, 8
	; Moving 8 bytes from rbp - -24 to rsp
		mov r10, [rbp - -24 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	imul rax, r10
	push rax
	jmp .jump74
.jump73:
	mov rax, [rel const10] ; 331
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - -88 to rsp
		mov r10, [rbp - -88 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	setle al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump77
	mov rax, [rel const11] ; 5.92
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	call _asin
	sub rsp, 8
	movsd [rsp], xmm0
	jmp .jump78
.jump77:
	mov rax, [rel const12] ; 27.64
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	call _log
	sub rsp, 8
	movsd [rsp], xmm0
.jump78:
	movsd xmm0, [rsp]
	add rsp, 8
	call _to_int
	push rax
.jump74:
	pop rdi
	call _to_float
	add rsp, 8 ; Remove alignment
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	add rsp, 56 ; Local variables
	pop rbp
	ret

b:
_b:
	push rbp
	mov rbp, rsp
	push rdi
	sub rsp, 8 ; Align stack
	mov rax, [rel const15] ; 77.77
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	call _sin
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	call _exp
	add rsp, 8 ; Remove alignment
	sub rsp, 8
	movsd [rsp], xmm0
	sub rsp, 8
	; Moving 8 bytes from r12 - -16 to rsp
		mov r10, [r12 - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const16] ; 110
	push rax
	; Moving 8 bytes from rsp + 8 to rsp + 8
		mov r10, [rsp + 8 + 0]
		mov [rsp + 8 + 0], r10
	add rsp, 8
	pop rdi
	call _to_float
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmpeqsd xmm0, xmm1
	movq rax, xmm0
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump80
	mov rax, [rel const7] ; True
	push rax
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	jne .jump82
	mov rax, [rel const17] ; 58
	push rax
	sub rsp, 8
	; Moving 8 bytes from r12 - -16 to rsp
		mov r10, [r12 - -16 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	sete al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	jne .jump83
	mov rax, [rel const7] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump84
	mov rax, [rel const3] ; False
	push rax
	pop rax
.jump84:
	push rax
	pop rax
.jump83:
	push rax
	pop rax
.jump82:
	push rax
	pop rax
	cmp rax, 0
	je .jump85
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for d
	mov rax, [rel const18] ; 583
	push rax
	sub rsp, 8
	; Moving 8 bytes from r12 - -16 to rsp
		mov r10, [r12 - -16 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	sub rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump87
	sub rsp, 8 ; Align stack
	lea rdi, [rel const0] ; non-positive loop bound
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump87:
	; Computing bound for c
	mov rax, [rel const19] ; 370
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump88
	lea rdi, [rel const0] ; non-positive loop bound
	call _fail_assertion
.jump88:
	; Computing total size of heap memory to allocate
	mov rdi, 32 ; sizeof int[,,]
	imul rdi, [rsp + 0 + 0] ; multiply by 370
	jno .jump89
	lea rdi, [rel const1] ; overflow computing array size
	call _fail_assertion
.jump89:
	imul rdi, [rsp + 0 + 8] ; multiply by (argnum - 583)
	jno .jump90
	lea rdi, [rel const1] ; overflow computing array size
	call _fail_assertion
.jump90:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize d to 0
	mov rax, 0
	push rax
	; Initialize c to 0
	mov rax, 0
	push rax
.jump91: ; Begin body of loop
	; Compare d to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump93 ; If d >= bound, ...
	mov qword [rsp + 8], 0 ; d = 0
	add qword [rsp + 0], 1 ; c++
.jump93:
	; Compare c to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jge .jump92 ; If c >= bound, break
.jump94:
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for g
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump95
	lea rdi, [rel const0] ; non-positive loop bound
	call _fail_assertion
.jump95:
	; Computing bound for f
	mov rax, [rel const20] ; 368
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump96
	sub rsp, 8 ; Align stack
	lea rdi, [rel const0] ; non-positive loop bound
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump96:
	; Computing bound for e
	mov rax, [rel const21] ; 67
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump97
	lea rdi, [rel const0] ; non-positive loop bound
	call _fail_assertion
.jump97:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int
	imul rdi, [rsp + 0 + 0] ; multiply by 67
	jno .jump98
	lea rdi, [rel const1] ; overflow computing array size
	call _fail_assertion
.jump98:
	imul rdi, [rsp + 0 + 8] ; multiply by 368
	jno .jump99
	lea rdi, [rel const1] ; overflow computing array size
	call _fail_assertion
.jump99:
	imul rdi, [rsp + 0 + 16] ; multiply by c
	jno .jump100
	lea rdi, [rel const1] ; overflow computing array size
	call _fail_assertion
.jump100:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize g to 0
	mov rax, 0
	push rax
	; Initialize f to 0
	mov rax, 0
	push rax
	; Initialize e to 0
	mov rax, 0
	push rax
.jump101: ; Begin body of loop
	; Compare g to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump103 ; If g >= bound, ...
	mov qword [rsp + 16], 0 ; g = 0
	add qword [rsp + 8], 1 ; f++
.jump103:
	; Compare f to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump104 ; If f >= bound, ...
	mov qword [rsp + 8], 0 ; f = 0
	add qword [rsp + 0], 1 ; e++
.jump104:
	; Compare e to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jge .jump102 ; If e >= bound, break
.jump105:
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment g
	add qword [rsp + 16], 1
	jmp .jump101
.jump102: ; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, 32
	add rax, [rsp + 64]
	; Move body (32 bytes) to index
	; Moving 32 bytes from rsp to rax
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	; Increment d
	add qword [rsp + 8], 1
	jmp .jump91
.jump92: ; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from r12 - -16 to rsp
		mov r10, [r12 - -16 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - -16 to rsp
		mov r10, [r12 - -16 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp r10, 0
	jne .jump106
	lea rdi, [rel const22] ; divide by zero
	call _fail_assertion
.jump106:
	cqo
	idiv r10
	push rax
	mov rax, [rel const23] ; 802
	push rax
	sub rsp, 8
	; Moving 8 bytes from r12 - -16 to rsp
		mov r10, [r12 - -16 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp r10, 0
	jne .jump107
	sub rsp, 8 ; Align stack
	lea rdi, [rel const4] ; mod by zero
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump107:
	cqo
	idiv r10
	mov rax, rdx
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump108
	lea rdi, [rel const5] ; negative array index
	call _fail_assertion
.jump108:
	cmp rax, [rsp + 16]
	jl .jump109
	lea rdi, [rel const6] ; index too large
	call _fail_assertion
.jump109:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump110
	lea rdi, [rel const5] ; negative array index
	call _fail_assertion
.jump110:
	cmp rax, [rsp + 24]
	jl .jump111
	lea rdi, [rel const6] ; index too large
	call _fail_assertion
.jump111:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 32
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 32
	; Moving 32 bytes from rax to rsp
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	jmp .jump86
.jump85:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for e
	mov rax, [rel const24] ; 29
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump112
	sub rsp, 8 ; Align stack
	lea rdi, [rel const0] ; non-positive loop bound
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump112:
	; Computing bound for d
	sub rsp, 16
	; Moving 16 bytes from r12 - -16 to rsp
		mov r10, [r12 - -16 + 8]
		mov [rsp + 8], r10
		mov r10, [r12 - -16 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - -16 to rsp
		mov r10, [r12 - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump113
	lea rdi, [rel const5] ; negative array index
	call _fail_assertion
.jump113:
	cmp rax, [rsp + 8]
	jl .jump114
	lea rdi, [rel const6] ; index too large
	call _fail_assertion
.jump114:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump115
	lea rdi, [rel const0] ; non-positive loop bound
	call _fail_assertion
.jump115:
	; Computing bound for c
	mov rax, [rel const25] ; 430
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump116
	sub rsp, 8 ; Align stack
	lea rdi, [rel const0] ; non-positive loop bound
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump116:
	; Computing total size of heap memory to allocate
	mov rdi, 32 ; sizeof int[,,]
	imul rdi, [rsp + 0 + 0] ; multiply by 430
	jno .jump117
	sub rsp, 8 ; Align stack
	lea rdi, [rel const1] ; overflow computing array size
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump117:
	imul rdi, [rsp + 0 + 8] ; multiply by args[argnum]
	jno .jump118
	sub rsp, 8 ; Align stack
	lea rdi, [rel const1] ; overflow computing array size
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump118:
	imul rdi, [rsp + 0 + 16] ; multiply by 29
	jno .jump119
	sub rsp, 8 ; Align stack
	lea rdi, [rel const1] ; overflow computing array size
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump119:
	sub rsp, 8 ; Align stack
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize e to 0
	mov rax, 0
	push rax
	; Initialize d to 0
	mov rax, 0
	push rax
	; Initialize c to 0
	mov rax, 0
	push rax
.jump120: ; Begin body of loop
	; Compare e to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump122 ; If e >= bound, ...
	mov qword [rsp + 16], 0 ; e = 0
	add qword [rsp + 8], 1 ; d++
.jump122:
	; Compare d to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump123 ; If d >= bound, ...
	mov qword [rsp + 8], 0 ; d = 0
	add qword [rsp + 0], 1 ; c++
.jump123:
	; Compare c to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jge .jump121 ; If c >= bound, break
.jump124:
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for h
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump125
	lea rdi, [rel const0] ; non-positive loop bound
	call _fail_assertion
.jump125:
	; Computing bound for g
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump126
	sub rsp, 8 ; Align stack
	lea rdi, [rel const0] ; non-positive loop bound
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump126:
	; Computing bound for f
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump127
	lea rdi, [rel const0] ; non-positive loop bound
	call _fail_assertion
.jump127:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int
	imul rdi, [rsp + 0 + 0] ; multiply by d
	jno .jump128
	lea rdi, [rel const1] ; overflow computing array size
	call _fail_assertion
.jump128:
	imul rdi, [rsp + 0 + 8] ; multiply by e
	jno .jump129
	lea rdi, [rel const1] ; overflow computing array size
	call _fail_assertion
.jump129:
	imul rdi, [rsp + 0 + 16] ; multiply by e
	jno .jump130
	lea rdi, [rel const1] ; overflow computing array size
	call _fail_assertion
.jump130:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize h to 0
	mov rax, 0
	push rax
	; Initialize g to 0
	mov rax, 0
	push rax
	; Initialize f to 0
	mov rax, 0
	push rax
.jump131: ; Begin body of loop
	; Compare h to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump133 ; If h >= bound, ...
	mov qword [rsp + 16], 0 ; h = 0
	add qword [rsp + 8], 1 ; g++
.jump133:
	; Compare g to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump134 ; If g >= bound, ...
	mov qword [rsp + 8], 0 ; g = 0
	add qword [rsp + 0], 1 ; f++
.jump134:
	; Compare f to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jge .jump132 ; If f >= bound, break
.jump135:
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 104 to rsp
		mov r10, [rbp - 104 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment h
	add qword [rsp + 16], 1
	jmp .jump131
.jump132: ; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, [rsp + 72] ; No overflow if indices in bounds
	add rax, [rsp + 48]
	imul rax, 32
	add rax, [rsp + 80]
	; Move body (32 bytes) to index
	; Moving 32 bytes from rsp to rax
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	; Increment e
	add qword [rsp + 16], 1
	jmp .jump120
.jump121: ; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for c
	mov rax, [rel const26] ; 790
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump136
	sub rsp, 8 ; Align stack
	lea rdi, [rel const0] ; non-positive loop bound
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump136:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int
	imul rdi, [rsp + 0 + 0] ; multiply by 790
	jno .jump137
	sub rsp, 8 ; Align stack
	lea rdi, [rel const1] ; overflow computing array size
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump137:
	sub rsp, 8 ; Align stack
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize c to 0
	mov rax, 0
	push rax
.jump138: ; Begin body of loop
	; Compare c to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jge .jump139 ; If c >= bound, break
.jump140:
	; Compute loop body
	mov rax, [rel const27] ; 355
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 24]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment c
	add qword [rsp + 0], 1
	jmp .jump138
.jump139: ; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	mov rax, [rel const28] ; 667
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump141
	lea rdi, [rel const5] ; negative array index
	call _fail_assertion
.jump141:
	cmp rax, [rsp + 8]
	jl .jump142
	lea rdi, [rel const6] ; index too large
	call _fail_assertion
.jump142:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rel const29] ; 930
	push rax
	; Moving 8 bytes from rsp + 0 to rsp + 0
		mov r10, [rsp + 0 + 0]
		mov [rsp + 0 + 0], r10
	add rsp, 0
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for c
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for d
	sub rsp, 8
	; Moving 8 bytes from r12 - -16 to rsp
		mov r10, [r12 - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump143
	lea rdi, [rel const0] ; non-positive loop bound
	call _fail_assertion
.jump143:
	; Computing bound for c
	mov rax, [rel const30] ; 269
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump144
	sub rsp, 8 ; Align stack
	lea rdi, [rel const0] ; non-positive loop bound
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump144:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize d to 0
	mov rax, 0
	push rax
	; Initialize c to 0
	mov rax, 0
	push rax
.jump145: ; Begin body of loop
	; Compare d to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump147 ; If d >= bound, ...
	mov qword [rsp + 8], 0 ; d = 0
	add qword [rsp + 0], 1 ; c++
.jump147:
	; Compare c to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jge .jump146 ; If c >= bound, break
.jump148:
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment d
	add qword [rsp + 8], 1
	jmp .jump145
.jump146: ; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump149
	sub rsp, 8 ; Align stack
	lea rdi, [rel const0] ; non-positive loop bound
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump149:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize c to 0
	mov rax, 0
	push rax
.jump150: ; Begin body of loop
	; Compare c to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jge .jump151 ; If c >= bound, break
.jump152:
	; Compute loop body
	mov rax, [rel const31] ; 194
	push rax
	sub rsp, 8
	; Moving 8 bytes from r12 - -16 to rsp
		mov r10, [r12 - -16 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp r10, 0
	jne .jump153
	lea rdi, [rel const22] ; divide by zero
	call _fail_assertion
.jump153:
	cqo
	idiv r10
	push rax
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment c
	add qword [rsp + 0], 1
	jmp .jump150
.jump151: ; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump154
	lea rdi, [rel const5] ; negative array index
	call _fail_assertion
.jump154:
	cmp rax, [rsp + 24]
	jl .jump155
	lea rdi, [rel const6] ; index too large
	call _fail_assertion
.jump155:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump156
	lea rdi, [rel const5] ; negative array index
	call _fail_assertion
.jump156:
	cmp rax, [rsp + 32]
	jl .jump157
	lea rdi, [rel const6] ; index too large
	call _fail_assertion
.jump157:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump158
	lea rdi, [rel const5] ; negative array index
	call _fail_assertion
.jump158:
	cmp rax, [rsp + 40]
	jl .jump159
	lea rdi, [rel const6] ; index too large
	call _fail_assertion
.jump159:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 32
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 32
	; Moving 32 bytes from rax to rsp
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
.jump86:
	jmp .jump81
.jump80:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for e
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for e
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for e
	mov rax, [rel const32] ; 415
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump160
	sub rsp, 8 ; Align stack
	lea rdi, [rel const0] ; non-positive loop bound
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump160:
	; Computing bound for d
	mov rax, [rel const33] ; 602
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump161
	lea rdi, [rel const0] ; non-positive loop bound
	call _fail_assertion
.jump161:
	; Computing bound for c
	sub rsp, 8
	; Moving 8 bytes from r12 - -16 to rsp
		mov r10, [r12 - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump162
	sub rsp, 8 ; Align stack
	lea rdi, [rel const0] ; non-positive loop bound
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump162:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize e to 0
	mov rax, 0
	push rax
	; Initialize d to 0
	mov rax, 0
	push rax
	; Initialize c to 0
	mov rax, 0
	push rax
.jump163: ; Begin body of loop
	; Compare e to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump165 ; If e >= bound, ...
	mov qword [rsp + 16], 0 ; e = 0
	add qword [rsp + 8], 1 ; d++
.jump165:
	; Compare d to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump166 ; If d >= bound, ...
	mov qword [rsp + 8], 0 ; d = 0
	add qword [rsp + 0], 1 ; c++
.jump166:
	; Compare c to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jge .jump164 ; If c >= bound, break
.jump167:
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 80 to rsp
		mov r10, [rbp - 80 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment e
	add qword [rsp + 16], 1
	jmp .jump163
.jump164: ; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump168
	lea rdi, [rel const0] ; non-positive loop bound
	call _fail_assertion
.jump168:
	; Computing bound for d
	sub rsp, 8
	; Moving 8 bytes from r12 - -16 to rsp
		mov r10, [r12 - -16 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump169
	sub rsp, 8 ; Align stack
	lea rdi, [rel const0] ; non-positive loop bound
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump169:
	; Computing bound for c
	mov rax, [rel const3] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump170
	sub rsp, 8
	; Moving 8 bytes from r12 - -16 to rsp
		mov r10, [r12 - -16 + 0]
		mov [rsp + 0], r10
	jmp .jump171
.jump170:
	sub rsp, 8
	; Moving 8 bytes from r12 - -16 to rsp
		mov r10, [r12 - -16 + 0]
		mov [rsp + 0], r10
.jump171:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump172
	lea rdi, [rel const0] ; non-positive loop bound
	call _fail_assertion
.jump172:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int
	imul rdi, [rsp + 0 + 0] ; multiply by (if false then argnum else argnum)
	jno .jump173
	lea rdi, [rel const1] ; overflow computing array size
	call _fail_assertion
.jump173:
	imul rdi, [rsp + 0 + 8] ; multiply by (- argnum)
	jno .jump174
	lea rdi, [rel const1] ; overflow computing array size
	call _fail_assertion
.jump174:
imul rdi, [rsp + 0 + 16] ; multiply by (sum[c : argnum, d : 602, e : 415] c)
	jno .jump175
	lea rdi, [rel const1] ; overflow computing array size
	call _fail_assertion
.jump175:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize e to 0
	mov rax, 0
	push rax
	; Initialize d to 0
	mov rax, 0
	push rax
	; Initialize c to 0
	mov rax, 0
	push rax
.jump176: ; Begin body of loop
	; Compare e to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump178 ; If e >= bound, ...
	mov qword [rsp + 16], 0 ; e = 0
	add qword [rsp + 8], 1 ; d++
.jump178:
	; Compare d to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump179 ; If d >= bound, ...
	mov qword [rsp + 8], 0 ; d = 0
	add qword [rsp + 0], 1 ; c++
.jump179:
	; Compare c to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jge .jump177 ; If c >= bound, break
.jump180:
	; Compute loop body
	mov rax, [rel const34] ; 312
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp r10, 0
	jne .jump181
	sub rsp, 8 ; Align stack
	lea rdi, [rel const22] ; divide by zero
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump181:
	cqo
	idiv r10
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment e
	add qword [rsp + 16], 1
	jmp .jump176
.jump177: ; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	mov rax, [rel const35] ; 16.61
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	call _exp
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	call _to_int
	push rax
	sub rsp, 8
	; Moving 8 bytes from r12 - -16 to rsp
		mov r10, [r12 - -16 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - -16 to rsp
		mov r10, [r12 - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump182
	sub rsp, 8 ; Align stack
	lea rdi, [rel const5] ; negative array index
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump182:
	cmp rax, [rsp + 24]
	jl .jump183
	sub rsp, 8 ; Align stack
	lea rdi, [rel const6] ; index too large
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump183:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump184
	sub rsp, 8 ; Align stack
	lea rdi, [rel const5] ; negative array index
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump184:
	cmp rax, [rsp + 32]
	jl .jump185
	sub rsp, 8 ; Align stack
	lea rdi, [rel const6] ; index too large
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump185:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump186
	sub rsp, 8 ; Align stack
	lea rdi, [rel const5] ; negative array index
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump186:
	cmp rax, [rsp + 40]
	jl .jump187
	sub rsp, 8 ; Align stack
	lea rdi, [rel const6] ; index too large
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump187:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 8
	; Moving 8 bytes from rax to rsp
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump188
	sub rsp, 8 ; Align stack
	lea rdi, [rel const0] ; non-positive loop bound
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump188:
	; Computing bound for d
	sub rsp, 8 ; Align stack
	mov rax, [rel const36] ; 6.55
	push rax
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	call _to_int
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump189
	lea rdi, [rel const0] ; non-positive loop bound
	call _fail_assertion
.jump189:
	; Computing bound for c
	mov rax, [rel const37] ; 14.62
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	call _cos
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	call _to_int
	push rax
	sub rsp, 8
	; Moving 8 bytes from r12 - -16 to rsp
		mov r10, [r12 - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const38] ; 532
	push rax
	mov rdi, 16
	sub rsp, 8 ; Align stack
	call _jpl_alloc
	add rsp, 8 ; Remove alignment
	; Moving 16 bytes from rsp to rax
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 16
	push rax
	mov rax, 2
	push rax
	sub rsp, 8
	; Moving 8 bytes from r12 - -16 to rsp
		mov r10, [r12 - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump190
	lea rdi, [rel const5] ; negative array index
	call _fail_assertion
.jump190:
	cmp rax, [rsp + 8]
	jl .jump191
	lea rdi, [rel const6] ; index too large
	call _fail_assertion
.jump191:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp r10, 0
	jne .jump192
	lea rdi, [rel const22] ; divide by zero
	call _fail_assertion
.jump192:
	cqo
	idiv r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump193
	sub rsp, 8 ; Align stack
	lea rdi, [rel const0] ; non-positive loop bound
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump193:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int
	imul rdi, [rsp + 0 + 0] ; multiply by ([532, argnum][argnum] / to_int(cos(14.62)))
	jno .jump194
	sub rsp, 8 ; Align stack
	lea rdi, [rel const1] ; overflow computing array size
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump194:
	imul rdi, [rsp + 0 + 8] ; multiply by to_int((- 6.55))
	jno .jump195
	sub rsp, 8 ; Align stack
	lea rdi, [rel const1] ; overflow computing array size
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump195:
imul rdi, [rsp + 0 + 16] ; multiply by (array[c : (if false then argnum else argnum), d : (- argnum), e : (sum[c : argnum, d : 602, e : 415] c)] (c / 312))[argnum, argnum, to_int(exp(16.61))]
	jno .jump196
	sub rsp, 8 ; Align stack
	lea rdi, [rel const1] ; overflow computing array size
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump196:
	sub rsp, 8 ; Align stack
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize e to 0
	mov rax, 0
	push rax
	; Initialize d to 0
	mov rax, 0
	push rax
	; Initialize c to 0
	mov rax, 0
	push rax
.jump197: ; Begin body of loop
	; Compare e to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump199 ; If e >= bound, ...
	mov qword [rsp + 16], 0 ; e = 0
	add qword [rsp + 8], 1 ; d++
.jump199:
	; Compare d to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump200 ; If d >= bound, ...
	mov qword [rsp + 8], 0 ; d = 0
	add qword [rsp + 0], 1 ; c++
.jump200:
	; Compare c to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jge .jump198 ; If c >= bound, break
.jump201:
	; Compute loop body
	mov rax, [rel const7] ; True
	push rax
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump202
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	mov rdi, 16
	call _jpl_alloc
	; Moving 16 bytes from rsp to rax
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 16
	push rax
	mov rax, 2
	push rax
	jmp .jump203
.jump202:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for f
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump204
	lea rdi, [rel const0] ; non-positive loop bound
	call _fail_assertion
.jump204:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int
	imul rdi, [rsp + 0 + 0] ; multiply by e
	jno .jump205
	lea rdi, [rel const1] ; overflow computing array size
	call _fail_assertion
.jump205:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize f to 0
	mov rax, 0
	push rax
.jump206: ; Begin body of loop
	; Compare f to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jge .jump207 ; If f >= bound, break
.jump208:
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - -16 to rsp
		mov r10, [r12 - -16 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 24]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment f
	add qword [rsp + 0], 1
	jmp .jump206
.jump207: ; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
.jump203:
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump209
	sub rsp, 8 ; Align stack
	lea rdi, [rel const5] ; negative array index
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump209:
	cmp rax, [rsp + 8]
	jl .jump210
	sub rsp, 8 ; Align stack
	lea rdi, [rel const6] ; index too large
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump210:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment e
	add qword [rsp + 16], 1
	jmp .jump197
.jump198: ; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
.jump81:
	sub rsp, 32
	; Moving 32 bytes from rbp - 40 to rsp
		mov r10, [rbp - 40 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - 40 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - 40 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for i
	sub rsp, 8
	; Moving 8 bytes from r12 - -16 to rsp
		mov r10, [r12 - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump211
	sub rsp, 8 ; Align stack
	lea rdi, [rel const0] ; non-positive loop bound
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump211:
	; Computing bound for h
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump212
	lea rdi, [rel const0] ; non-positive loop bound
	call _fail_assertion
.jump212:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool
	imul rdi, [rsp + 0 + 0] ; multiply by e
	jno .jump213
	lea rdi, [rel const1] ; overflow computing array size
	call _fail_assertion
.jump213:
	imul rdi, [rsp + 0 + 8] ; multiply by argnum
	jno .jump214
	lea rdi, [rel const1] ; overflow computing array size
	call _fail_assertion
.jump214:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize i to 0
	mov rax, 0
	push rax
	; Initialize h to 0
	mov rax, 0
	push rax
.jump215: ; Begin body of loop
	; Compare i to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump217 ; If i >= bound, ...
	mov qword [rsp + 8], 0 ; i = 0
	add qword [rsp + 0], 1 ; h++
.jump217:
	; Compare h to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jge .jump216 ; If h >= bound, break
.jump218:
	; Compute loop body
	mov rax, [rel const7] ; True
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment i
	add qword [rsp + 8], 1
	jmp .jump215
.jump216: ; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for i
	sub rsp, 8
	; Moving 8 bytes from r12 - -16 to rsp
		mov r10, [r12 - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump219
	lea rdi, [rel const0] ; non-positive loop bound
	call _fail_assertion
.jump219:
	; Computing bound for h
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump220
	sub rsp, 8 ; Align stack
	lea rdi, [rel const0] ; non-positive loop bound
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump220:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize i to 0
	mov rax, 0
	push rax
	; Initialize h to 0
	mov rax, 0
	push rax
.jump221: ; Begin body of loop
	; Compare i to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump223 ; If i >= bound, ...
	mov qword [rsp + 8], 0 ; i = 0
	add qword [rsp + 0], 1 ; h++
.jump223:
	; Compare h to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jge .jump222 ; If h >= bound, break
.jump224:
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment i
	add qword [rsp + 8], 1
	jmp .jump221
.jump222: ; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const39] ; 981
	push rax
	pop rax
	pop r10
	add rax, r10
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump225
	lea rdi, [rel const5] ; negative array index
	call _fail_assertion
.jump225:
	cmp rax, [rsp + 16]
	jl .jump226
	lea rdi, [rel const6] ; index too large
	call _fail_assertion
.jump226:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump227
	lea rdi, [rel const5] ; negative array index
	call _fail_assertion
.jump227:
	cmp rax, [rsp + 24]
	jl .jump228
	lea rdi, [rel const6] ; index too large
	call _fail_assertion
.jump228:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 8
	; Moving 8 bytes from rax to rsp
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump229
	sub rsp, 32
	; Moving 32 bytes from rbp - 40 to rsp
		mov r10, [rbp - 40 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - 40 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - 40 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	; Moving 32 bytes from rsp + 0 to rsp + 0
		mov r10, [rsp + 0 + 24]
		mov [rsp + 0 + 24], r10
		mov r10, [rsp + 0 + 16]
		mov [rsp + 0 + 16], r10
		mov r10, [rsp + 0 + 8]
		mov [rsp + 0 + 8], r10
		mov r10, [rsp + 0 + 0]
		mov [rsp + 0 + 0], r10
	add rsp, 0
	jmp .jump230
.jump229:
	sub rsp, 32
	; Moving 32 bytes from rbp - 40 to rsp
		mov r10, [rbp - 40 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - 40 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - 40 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - -16 to rsp
		mov r10, [r12 - -16 + 0]
		mov [rsp + 0], r10
	; Moving 32 bytes from rsp + 8 to rsp + 8
		mov r10, [rsp + 8 + 24]
		mov [rsp + 8 + 24], r10
		mov r10, [rsp + 8 + 16]
		mov [rsp + 8 + 16], r10
		mov r10, [rsp + 8 + 8]
		mov [rsp + 8 + 8], r10
		mov r10, [rsp + 8 + 0]
		mov [rsp + 8 + 0], r10
	add rsp, 8
.jump230:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for h
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for j
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump231
	lea rdi, [rel const0] ; non-positive loop bound
	call _fail_assertion
.jump231:
	; Computing bound for i
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump232
	sub rsp, 8 ; Align stack
	lea rdi, [rel const0] ; non-positive loop bound
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump232:
	; Computing bound for h
	mov rax, [rel const40] ; 918
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump233
	lea rdi, [rel const0] ; non-positive loop bound
	call _fail_assertion
.jump233:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int
	imul rdi, [rsp + 0 + 0] ; multiply by 918
	jno .jump234
	lea rdi, [rel const1] ; overflow computing array size
	call _fail_assertion
.jump234:
	imul rdi, [rsp + 0 + 8] ; multiply by e
	jno .jump235
	lea rdi, [rel const1] ; overflow computing array size
	call _fail_assertion
.jump235:
	imul rdi, [rsp + 0 + 16] ; multiply by e
	jno .jump236
	lea rdi, [rel const1] ; overflow computing array size
	call _fail_assertion
.jump236:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize j to 0
	mov rax, 0
	push rax
	; Initialize i to 0
	mov rax, 0
	push rax
	; Initialize h to 0
	mov rax, 0
	push rax
.jump237: ; Begin body of loop
	; Compare j to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump239 ; If j >= bound, ...
	mov qword [rsp + 16], 0 ; j = 0
	add qword [rsp + 8], 1 ; i++
.jump239:
	; Compare i to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump240 ; If i >= bound, ...
	mov qword [rsp + 8], 0 ; i = 0
	add qword [rsp + 0], 1 ; h++
.jump240:
	; Compare h to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jge .jump238 ; If h >= bound, break
.jump241:
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 160 to rsp
		mov r10, [rbp - 160 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment j
	add qword [rsp + 16], 1
	jmp .jump237
.jump238: ; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for j
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump242
	sub rsp, 8 ; Align stack
	lea rdi, [rel const0] ; non-positive loop bound
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump242:
	; Computing bound for i
	sub rsp, 8
	; Moving 8 bytes from r12 - -16 to rsp
		mov r10, [r12 - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump243
	lea rdi, [rel const0] ; non-positive loop bound
	call _fail_assertion
.jump243:
	; Computing bound for h
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump244
	sub rsp, 8 ; Align stack
	lea rdi, [rel const0] ; non-positive loop bound
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump244:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize j to 0
	mov rax, 0
	push rax
	; Initialize i to 0
	mov rax, 0
	push rax
	; Initialize h to 0
	mov rax, 0
	push rax
.jump245: ; Begin body of loop
	; Compare j to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump247 ; If j >= bound, ...
	mov qword [rsp + 16], 0 ; j = 0
	add qword [rsp + 8], 1 ; i++
.jump247:
	; Compare i to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump248 ; If i >= bound, ...
	mov qword [rsp + 8], 0 ; i = 0
	add qword [rsp + 0], 1 ; h++
.jump248:
	; Compare h to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jge .jump246 ; If h >= bound, break
.jump249:
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 208 to rsp
		mov r10, [rbp - 208 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment j
	add qword [rsp + 16], 1
	jmp .jump245
.jump246: ; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	mov rax, [rel const41] ; 96.3
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	call _to_int
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump250
	sub rsp, 8 ; Align stack
	lea rdi, [rel const5] ; negative array index
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump250:
	cmp rax, [rsp + 24]
	jl .jump251
	sub rsp, 8 ; Align stack
	lea rdi, [rel const6] ; index too large
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump251:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump252
	sub rsp, 8 ; Align stack
	lea rdi, [rel const5] ; negative array index
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump252:
	cmp rax, [rsp + 32]
	jl .jump253
	sub rsp, 8 ; Align stack
	lea rdi, [rel const6] ; index too large
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump253:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump254
	sub rsp, 8 ; Align stack
	lea rdi, [rel const5] ; negative array index
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump254:
	cmp rax, [rsp + 40]
	jl .jump255
	sub rsp, 8 ; Align stack
	lea rdi, [rel const6] ; index too large
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump255:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 8
	; Moving 8 bytes from rax to rsp
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump256
	sub rsp, 8 ; Align stack
	lea rdi, [rel const0] ; non-positive loop bound
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump256:
	; Computing total size of heap memory to allocate
	mov rdi, 16 ; sizeof int[][]
imul rdi, [rsp + 0 + 0] ; multiply by (array[h : 918, i : e, j : e] i)[to_int(96.3), (sum[h : f, i : argnum, j : f] h), d]
	jno .jump257
	sub rsp, 8 ; Align stack
	lea rdi, [rel const1] ; overflow computing array size
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump257:
	sub rsp, 8 ; Align stack
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize h to 0
	mov rax, 0
	push rax
.jump258: ; Begin body of loop
	; Compare h to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jge .jump259 ; If h >= bound, break
.jump260:
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for i
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump261
	lea rdi, [rel const0] ; non-positive loop bound
	call _fail_assertion
.jump261:
	; Computing total size of heap memory to allocate
	mov rdi, 16 ; sizeof int[]
	imul rdi, [rsp + 0 + 0] ; multiply by d
	jno .jump262
	lea rdi, [rel const1] ; overflow computing array size
	call _fail_assertion
.jump262:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize i to 0
	mov rax, 0
	push rax
.jump263: ; Begin body of loop
	; Compare i to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jge .jump264 ; If i >= bound, break
.jump265:
	; Compute loop body
	mov rax, [rel const42] ; 92
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 152 to rsp
		mov r10, [rbp - 152 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - -16 to rsp
		mov r10, [r12 - -16 + 0]
		mov [rsp + 0], r10
	mov rdi, 24
	call _jpl_alloc
	; Moving 24 bytes from rsp to rax
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 24
	push rax
	mov rax, 3
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 16
	add rax, [rsp + 32]
	; Move body (16 bytes) to index
	; Moving 16 bytes from rsp to rax
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 16
	; Increment i
	add qword [rsp + 0], 1
	jmp .jump263
.jump264: ; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 16
	add rax, [rsp + 32]
	; Move body (16 bytes) to index
	; Moving 16 bytes from rsp to rax
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 16
	; Increment h
	add qword [rsp + 0], 1
	jmp .jump258
.jump259: ; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	mov rax, [rel const43] ; 784
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump266
	lea rdi, [rel const5] ; negative array index
	call _fail_assertion
.jump266:
	cmp rax, [rsp + 8]
	jl .jump267
	lea rdi, [rel const6] ; index too large
	call _fail_assertion
.jump267:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 16
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 16
	; Moving 16 bytes from rax to rsp
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	sub rsp, 16
	; Moving 16 bytes from rbp - 120 to rsp
		mov r10, [rbp - 120 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 120 + 0]
		mov [rsp + 0], r10
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for p
	sub rsp, 8
	; Moving 8 bytes from rbp - 88 to rsp
		mov r10, [rbp - 88 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump268
	sub rsp, 8 ; Align stack
	lea rdi, [rel const0] ; non-positive loop bound
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump268:
	; Computing bound for o
	sub rsp, 8
	; Moving 8 bytes from rbp - 120 to rsp
		mov r10, [rbp - 120 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump269
	lea rdi, [rel const0] ; non-positive loop bound
	call _fail_assertion
.jump269:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof float
	imul rdi, [rsp + 0 + 0] ; multiply by i
	jno .jump270
	lea rdi, [rel const1] ; overflow computing array size
	call _fail_assertion
.jump270:
	imul rdi, [rsp + 0 + 8] ; multiply by m
	jno .jump271
	lea rdi, [rel const1] ; overflow computing array size
	call _fail_assertion
.jump271:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize p to 0
	mov rax, 0
	push rax
	; Initialize o to 0
	mov rax, 0
	push rax
.jump272: ; Begin body of loop
	; Compare p to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump274 ; If p >= bound, ...
	mov qword [rsp + 8], 0 ; p = 0
	add qword [rsp + 0], 1 ; o++
.jump274:
	; Compare o to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jge .jump273 ; If o >= bound, break
.jump275:
	; Compute loop body
	mov rax, [rel const44] ; 47.07
	push rax
	sub rsp, 24
	lea rdi, [rsp + 0]
	call _b
	sub rsp, 8
	; Moving 8 bytes from rbp - 88 to rsp
		mov r10, [rbp - 88 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 168 to rsp
		mov r10, [rbp - 168 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump276
	lea rdi, [rel const5] ; negative array index
	call _fail_assertion
.jump276:
	cmp rax, [rsp + 16]
	jl .jump277
	lea rdi, [rel const6] ; index too large
	call _fail_assertion
.jump277:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump278
	lea rdi, [rel const5] ; negative array index
	call _fail_assertion
.jump278:
	cmp rax, [rsp + 24]
	jl .jump279
	lea rdi, [rel const6] ; index too large
	call _fail_assertion
.jump279:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 8
	; Moving 8 bytes from rax to rsp
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	call _pow
	sub rsp, 8
	movsd [rsp], xmm0
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment p
	add qword [rsp + 8], 1
	jmp .jump272
.jump273: ; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for o
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump280
	lea rdi, [rel const0] ; non-positive loop bound
	call _fail_assertion
.jump280:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool
	imul rdi, [rsp + 0 + 0] ; multiply by f
	jno .jump281
	lea rdi, [rel const1] ; overflow computing array size
	call _fail_assertion
.jump281:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize o to 0
	mov rax, 0
	push rax
.jump282: ; Begin body of loop
	; Compare o to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jge .jump283 ; If o >= bound, break
.jump284:
	; Compute loop body
	mov rax, [rel const3] ; False
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 24]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment o
	add qword [rsp + 0], 1
	jmp .jump282
.jump283: ; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 88 to rsp
		mov r10, [rbp - 88 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump285
	sub rsp, 8 ; Align stack
	lea rdi, [rel const5] ; negative array index
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump285:
	cmp rax, [rsp + 8]
	jl .jump286
	sub rsp, 8 ; Align stack
	lea rdi, [rel const6] ; index too large
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump286:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump287
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for q
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump289
	lea rdi, [rel const0] ; non-positive loop bound
	call _fail_assertion
.jump289:
	; Computing bound for p
	sub rsp, 8
	; Moving 8 bytes from r12 - -16 to rsp
		mov r10, [r12 - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump290
	sub rsp, 8 ; Align stack
	lea rdi, [rel const0] ; non-positive loop bound
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump290:
	; Computing bound for o
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump291
	lea rdi, [rel const0] ; non-positive loop bound
	call _fail_assertion
.jump291:
	; Computing total size of heap memory to allocate
	mov rdi, 24 ; sizeof float[,]
	imul rdi, [rsp + 0 + 0] ; multiply by f
	jno .jump292
	lea rdi, [rel const1] ; overflow computing array size
	call _fail_assertion
.jump292:
	imul rdi, [rsp + 0 + 8] ; multiply by argnum
	jno .jump293
	lea rdi, [rel const1] ; overflow computing array size
	call _fail_assertion
.jump293:
	imul rdi, [rsp + 0 + 16] ; multiply by d
	jno .jump294
	lea rdi, [rel const1] ; overflow computing array size
	call _fail_assertion
.jump294:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize q to 0
	mov rax, 0
	push rax
	; Initialize p to 0
	mov rax, 0
	push rax
	; Initialize o to 0
	mov rax, 0
	push rax
.jump295: ; Begin body of loop
	; Compare q to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump297 ; If q >= bound, ...
	mov qword [rsp + 16], 0 ; q = 0
	add qword [rsp + 8], 1 ; p++
.jump297:
	; Compare p to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump298 ; If p >= bound, ...
	mov qword [rsp + 8], 0 ; p = 0
	add qword [rsp + 0], 1 ; o++
.jump298:
	; Compare o to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jge .jump296 ; If o >= bound, break
.jump299:
	; Compute loop body
	sub rsp, 24
	lea rdi, [rsp + 0]
	call _b
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, 24
	add rax, [rsp + 72]
	; Move body (24 bytes) to index
	; Moving 24 bytes from rsp to rax
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 24
	; Increment q
	add qword [rsp + 16], 1
	jmp .jump295
.jump296: ; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump300
	sub rsp, 8 ; Align stack
	lea rdi, [rel const5] ; negative array index
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump300:
	cmp rax, [rsp + 24]
	jl .jump301
	sub rsp, 8 ; Align stack
	lea rdi, [rel const6] ; index too large
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump301:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump302
	sub rsp, 8 ; Align stack
	lea rdi, [rel const5] ; negative array index
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump302:
	cmp rax, [rsp + 32]
	jl .jump303
	sub rsp, 8 ; Align stack
	lea rdi, [rel const6] ; index too large
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump303:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump304
	sub rsp, 8 ; Align stack
	lea rdi, [rel const5] ; negative array index
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump304:
	cmp rax, [rsp + 40]
	jl .jump305
	sub rsp, 8 ; Align stack
	lea rdi, [rel const6] ; index too large
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump305:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 24
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 24
	; Moving 24 bytes from rax to rsp
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	jmp .jump288
.jump287:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for p
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump306
	lea rdi, [rel const0] ; non-positive loop bound
	call _fail_assertion
.jump306:
	; Computing bound for o
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for q
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump307
	lea rdi, [rel const0] ; non-positive loop bound
	call _fail_assertion
.jump307:
	; Computing bound for p
	sub rsp, 8
	; Moving 8 bytes from rbp - 88 to rsp
		mov r10, [rbp - 88 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump308
	sub rsp, 8 ; Align stack
	lea rdi, [rel const0] ; non-positive loop bound
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump308:
	; Computing bound for o
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump309
	lea rdi, [rel const0] ; non-positive loop bound
	call _fail_assertion
.jump309:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize q to 0
	mov rax, 0
	push rax
	; Initialize p to 0
	mov rax, 0
	push rax
	; Initialize o to 0
	mov rax, 0
	push rax
.jump310: ; Begin body of loop
	; Compare q to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump312 ; If q >= bound, ...
	mov qword [rsp + 16], 0 ; q = 0
	add qword [rsp + 8], 1 ; p++
.jump312:
	; Compare p to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump313 ; If p >= bound, ...
	mov qword [rsp + 8], 0 ; p = 0
	add qword [rsp + 0], 1 ; o++
.jump313:
	; Compare o to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jge .jump311 ; If o >= bound, break
.jump314:
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 232 to rsp
		mov r10, [rbp - 232 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment q
	add qword [rsp + 16], 1
	jmp .jump310
.jump311: ; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump315
	sub rsp, 8 ; Align stack
	lea rdi, [rel const0] ; non-positive loop bound
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump315:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof float
imul rdi, [rsp + 0 + 0] ; multiply by (sum[o : l, p : m, q : e] o)
	jno .jump316
	sub rsp, 8 ; Align stack
	lea rdi, [rel const1] ; overflow computing array size
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump316:
	imul rdi, [rsp + 0 + 8] ; multiply by f
	jno .jump317
	sub rsp, 8 ; Align stack
	lea rdi, [rel const1] ; overflow computing array size
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump317:
	sub rsp, 8 ; Align stack
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize p to 0
	mov rax, 0
	push rax
	; Initialize o to 0
	mov rax, 0
	push rax
.jump318: ; Begin body of loop
	; Compare p to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump320 ; If p >= bound, ...
	mov qword [rsp + 8], 0 ; p = 0
	add qword [rsp + 0], 1 ; o++
.jump320:
	; Compare o to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jge .jump319 ; If o >= bound, break
.jump321:
	; Compute loop body
	mov rax, [rel const45] ; 78.94
	push rax
	mov rax, [rel const46] ; 25.63
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	mulsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment p
	add qword [rsp + 8], 1
	jmp .jump318
.jump319: ; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
.jump288:
	; Moving 24 bytes from rsp + 0 to rsp + 24
		mov r10, [rsp + 0 + 16]
		mov [rsp + 24 + 16], r10
		mov r10, [rsp + 0 + 8]
		mov [rsp + 24 + 8], r10
		mov r10, [rsp + 0 + 0]
		mov [rsp + 24 + 0], r10
	add rsp, 24
	mov rax, [rbp - 8] ; Address to write return value into
	; Moving 24 bytes from rsp to rax
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 160 ; Local variables
	pop rbp
	ret

d:
_d:
	push rbp
	mov rbp, rsp
	mov rax, [rel const7] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump322
	mov rax, [rel const48] ; 37.2
	push rax
	jmp .jump323
.jump322:
	mov rax, [rel const49] ; 46.95
	push rax
.jump323:
	movsd xmm0, [rsp]
	add rsp, 8
	call _sin
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	call _tan
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	call _exp
	sub rsp, 8
	movsd [rsp], xmm0
	sub rsp, 8 ; Align stack
	mov rax, [rel const50] ; 1.28
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	call _acos
	sub rsp, 8
	movsd [rsp], xmm0
	mov rax, [rel const51] ; 75.87
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	call _atan2
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	call _sqrt
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	call _sqrt
	add rsp, 8 ; Remove alignment
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmpltsd xmm1, xmm0
	movq rax, xmm1
	and rax, 1
	push rax
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for j
	mov rax, [rel const52] ; 78.12
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	call _cos
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	call _log
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	call _to_int
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump324
	sub rsp, 8 ; Align stack
	lea rdi, [rel const0] ; non-positive loop bound
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump324:
	; Computing bound for i
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for k
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump325
	sub rsp, 8 ; Align stack
	lea rdi, [rel const0] ; non-positive loop bound
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump325:
	; Computing bound for j
	sub rsp, 8
	; Moving 8 bytes from r12 - -16 to rsp
		mov r10, [r12 - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump326
	lea rdi, [rel const0] ; non-positive loop bound
	call _fail_assertion
.jump326:
	; Computing bound for i
	mov rax, [rel const53] ; 975
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump327
	sub rsp, 8 ; Align stack
	lea rdi, [rel const0] ; non-positive loop bound
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump327:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize k to 0
	mov rax, 0
	push rax
	; Initialize j to 0
	mov rax, 0
	push rax
	; Initialize i to 0
	mov rax, 0
	push rax
.jump328: ; Begin body of loop
	; Compare k to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump330 ; If k >= bound, ...
	mov qword [rsp + 16], 0 ; k = 0
	add qword [rsp + 8], 1 ; j++
.jump330:
	; Compare j to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump331 ; If j >= bound, ...
	mov qword [rsp + 8], 0 ; j = 0
	add qword [rsp + 0], 1 ; i++
.jump331:
	; Compare i to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jge .jump329 ; If i >= bound, break
.jump332:
	; Compute loop body
	mov rax, [rel const54] ; 89.1
	push rax
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	call _to_int
	push rax
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment k
	add qword [rsp + 16], 1
	jmp .jump328
.jump329: ; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump333
	lea rdi, [rel const0] ; non-positive loop bound
	call _fail_assertion
.jump333:
	; Computing total size of heap memory to allocate
	mov rdi, 16 ; sizeof int[]
imul rdi, [rsp + 0 + 0] ; multiply by (sum[i : (- 975), j : argnum, k : f] to_int((- 89.1)))
	jno .jump334
	lea rdi, [rel const1] ; overflow computing array size
	call _fail_assertion
.jump334:
	imul rdi, [rsp + 0 + 8] ; multiply by to_int(log(cos(78.12)))
	jno .jump335
	lea rdi, [rel const1] ; overflow computing array size
	call _fail_assertion
.jump335:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize j to 0
	mov rax, 0
	push rax
	; Initialize i to 0
	mov rax, 0
	push rax
.jump336: ; Begin body of loop
	; Compare j to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump338 ; If j >= bound, ...
	mov qword [rsp + 8], 0 ; j = 0
	add qword [rsp + 0], 1 ; i++
.jump338:
	; Compare i to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jge .jump337 ; If i >= bound, break
.jump339:
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for k
	sub rsp, 8 ; Align stack
	mov rax, [rel const55] ; 11.88
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	call _to_int
	add rsp, 8 ; Remove alignment
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump340
	lea rdi, [rel const0] ; non-positive loop bound
	call _fail_assertion
.jump340:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int
	imul rdi, [rsp + 0 + 0] ; multiply by (- to_int(11.88))
	jno .jump341
	lea rdi, [rel const1] ; overflow computing array size
	call _fail_assertion
.jump341:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize k to 0
	mov rax, 0
	push rax
.jump342: ; Begin body of loop
	; Compare k to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jge .jump343 ; If k >= bound, break
.jump344:
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 24]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment k
	add qword [rsp + 0], 1
	jmp .jump342
.jump343: ; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 16
	add rax, [rsp + 48]
	; Move body (16 bytes) to index
	; Moving 16 bytes from rsp to rax
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 16
	; Increment j
	add qword [rsp + 8], 1
	jmp .jump336
.jump337: ; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for k
	mov rax, [rel const56] ; 352
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump345
	lea rdi, [rel const0] ; non-positive loop bound
	call _fail_assertion
.jump345:
	; Computing bound for j
	mov rax, [rel const57] ; 90.34
	push rax
	mov rax, [rel const58] ; 21.62
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	call _fmod
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	call _exp
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	call _to_int
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump346
	sub rsp, 8 ; Align stack
	lea rdi, [rel const0] ; non-positive loop bound
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump346:
	; Computing bound for i
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for i
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for k
	mov rax, [rel const20] ; 368
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump347
	lea rdi, [rel const0] ; non-positive loop bound
	call _fail_assertion
.jump347:
	; Computing bound for j
	mov rax, [rel const59] ; 97
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump348
	sub rsp, 8 ; Align stack
	lea rdi, [rel const0] ; non-positive loop bound
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump348:
	; Computing bound for i
	mov rax, [rel const60] ; 113
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump349
	lea rdi, [rel const0] ; non-positive loop bound
	call _fail_assertion
.jump349:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize k to 0
	mov rax, 0
	push rax
	; Initialize j to 0
	mov rax, 0
	push rax
	; Initialize i to 0
	mov rax, 0
	push rax
.jump350: ; Begin body of loop
	; Compare k to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump352 ; If k >= bound, ...
	mov qword [rsp + 16], 0 ; k = 0
	add qword [rsp + 8], 1 ; j++
.jump352:
	; Compare j to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump353 ; If j >= bound, ...
	mov qword [rsp + 8], 0 ; j = 0
	add qword [rsp + 0], 1 ; i++
.jump353:
	; Compare i to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jge .jump351 ; If i >= bound, break
.jump354:
	; Compute loop body
	mov rax, [rel const61] ; 2
	push rax
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment k
	add qword [rsp + 16], 1
	jmp .jump350
.jump351: ; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump355
	sub rsp, 8 ; Align stack
	lea rdi, [rel const0] ; non-positive loop bound
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump355:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize i to 0
	mov rax, 0
	push rax
.jump356: ; Begin body of loop
	; Compare i to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jge .jump357 ; If i >= bound, break
.jump358:
	; Compute loop body
	mov rax, [rel const62] ; 549
	push rax
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment i
	add qword [rsp + 0], 1
	jmp .jump356
.jump357: ; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump359
	lea rdi, [rel const0] ; non-positive loop bound
	call _fail_assertion
.jump359:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize k to 0
	mov rax, 0
	push rax
	; Initialize j to 0
	mov rax, 0
	push rax
	; Initialize i to 0
	mov rax, 0
	push rax
.jump360: ; Begin body of loop
	; Compare k to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump362 ; If k >= bound, ...
	mov qword [rsp + 16], 0 ; k = 0
	add qword [rsp + 8], 1 ; j++
.jump362:
	; Compare j to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump363 ; If j >= bound, ...
	mov qword [rsp + 8], 0 ; j = 0
	add qword [rsp + 0], 1 ; i++
.jump363:
	; Compare i to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jge .jump361 ; If i >= bound, break
.jump364:
	; Compute loop body
	sub rsp, 8 ; Align stack
	mov rax, [rel const63] ; 91.5
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	call _exp
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	call _cos
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	call _to_int
	add rsp, 8 ; Remove alignment
	push rax
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment k
	add qword [rsp + 16], 1
	jmp .jump360
.jump361: ; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	sub rsp, 8 ; Align stack
	mov rax, [rel const64] ; 30.11
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	call _log
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	call _sin
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	call _sqrt
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	call _to_int
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump365
	lea rdi, [rel const5] ; negative array index
	call _fail_assertion
.jump365:
	cmp rax, [rsp + 16]
	jl .jump366
	lea rdi, [rel const6] ; index too large
	call _fail_assertion
.jump366:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump367
	lea rdi, [rel const5] ; negative array index
	call _fail_assertion
.jump367:
	cmp rax, [rsp + 24]
	jl .jump368
	lea rdi, [rel const6] ; index too large
	call _fail_assertion
.jump368:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 16
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 16
	; Moving 16 bytes from rax to rsp
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 8 to rsp
		mov r10, [rbp - 8 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	jne .jump369
	sub rsp, 8 ; Align stack
	lea rdi, [rel const65] ; k
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump369:
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for l
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump370
	sub rsp, 8 ; Align stack
	lea rdi, [rel const0] ; non-positive loop bound
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump370:
	; Computing bound for k
	mov rax, [rel const66] ; 510
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump371
	lea rdi, [rel const0] ; non-positive loop bound
	call _fail_assertion
.jump371:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize l to 0
	mov rax, 0
	push rax
	; Initialize k to 0
	mov rax, 0
	push rax
.jump372: ; Begin body of loop
	; Compare l to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump374 ; If l >= bound, ...
	mov qword [rsp + 8], 0 ; l = 0
	add qword [rsp + 0], 1 ; k++
.jump374:
	; Compare k to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jge .jump373 ; If k >= bound, break
.jump375:
	; Compute loop body
	mov rax, [rel const67] ; 43.04
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp + 32] ; Load sum
	addsd xmm0, xmm1 ; Add loop body
	movsd [rsp + 32], xmm0 ; Save sum
	; Increment l
	add qword [rsp + 8], 1
	jmp .jump372
.jump373: ; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	sub rsp, 24
	sub rsp, 8 ; Align stack
	lea rdi, [rsp + 8]
	call _b
	add rsp, 8 ; Remove alignment
	sub rsp, 8
	; Moving 8 bytes from r12 - -16 to rsp
		mov r10, [r12 - -16 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump376
	sub rsp, 8 ; Align stack
	lea rdi, [rel const5] ; negative array index
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump376:
	cmp rax, [rsp + 16]
	jl .jump377
	sub rsp, 8 ; Align stack
	lea rdi, [rel const6] ; index too large
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump377:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump378
	sub rsp, 8 ; Align stack
	lea rdi, [rel const5] ; negative array index
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump378:
	cmp rax, [rsp + 24]
	jl .jump379
	sub rsp, 8 ; Align stack
	lea rdi, [rel const6] ; index too large
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump379:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 8
	; Moving 8 bytes from rax to rsp
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmpneqsd xmm0, xmm1
	movq rax, xmm0
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump380
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for k
	mov rax, [rel const68] ; 530
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump382
	sub rsp, 8 ; Align stack
	lea rdi, [rel const0] ; non-positive loop bound
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump382:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool
	imul rdi, [rsp + 0 + 0] ; multiply by (- 530)
	jno .jump383
	sub rsp, 8 ; Align stack
	lea rdi, [rel const1] ; overflow computing array size
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump383:
	sub rsp, 8 ; Align stack
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize k to 0
	mov rax, 0
	push rax
.jump384: ; Begin body of loop
	; Compare k to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jge .jump385 ; If k >= bound, break
.jump386:
	; Compute loop body
	mov rax, [rel const3] ; False
	push rax
	mov rax, [rel const3] ; False
	push rax
	pop rax
	pop r10
	cmp rax, r10
	sete al
	and rax, 1
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 24]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment k
	add qword [rsp + 0], 1
	jmp .jump384
.jump385: ; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	jmp .jump381
.jump380:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for k
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump387
	sub rsp, 8 ; Align stack
	lea rdi, [rel const0] ; non-positive loop bound
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump387:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool
	imul rdi, [rsp + 0 + 0] ; multiply by f
	jno .jump388
	sub rsp, 8 ; Align stack
	lea rdi, [rel const1] ; overflow computing array size
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump388:
	sub rsp, 8 ; Align stack
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize k to 0
	mov rax, 0
	push rax
.jump389: ; Begin body of loop
	; Compare k to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jge .jump390 ; If k >= bound, break
.jump391:
	; Compute loop body
	mov rax, [rel const3] ; False
	push rax
	pop rax
	cmp rax, 0
	jne .jump392
	sub rsp, 8
	; Moving 8 bytes from rbp - 8 to rsp
		mov r10, [rbp - 8 + 0]
		mov [rsp + 0], r10
	pop rax
.jump392:
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 24]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment k
	add qword [rsp + 0], 1
	jmp .jump389
.jump390: ; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
.jump381:
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for m
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const69] ; 359
	push rax
	pop rax
	pop r10
	add rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump393
	sub rsp, 8 ; Align stack
	lea rdi, [rel const0] ; non-positive loop bound
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump393:
	; Computing bound for l
	sub rsp, 8
	; Moving 8 bytes from r12 - -16 to rsp
		mov r10, [r12 - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump394
	lea rdi, [rel const0] ; non-positive loop bound
	call _fail_assertion
.jump394:
	; Computing bound for k
	mov rax, [rel const70] ; 768
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - -24 to rsp
		mov r10, [rbp - -24 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp r10, 0
	jne .jump395
	lea rdi, [rel const4] ; mod by zero
	call _fail_assertion
.jump395:
	cqo
	idiv r10
	mov rax, rdx
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump396
	sub rsp, 8 ; Align stack
	lea rdi, [rel const0] ; non-positive loop bound
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump396:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize m to 0
	mov rax, 0
	push rax
	; Initialize l to 0
	mov rax, 0
	push rax
	; Initialize k to 0
	mov rax, 0
	push rax
.jump397: ; Begin body of loop
	; Compare m to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump399 ; If m >= bound, ...
	mov qword [rsp + 16], 0 ; m = 0
	add qword [rsp + 8], 1 ; l++
.jump399:
	; Compare l to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump400 ; If l >= bound, ...
	mov qword [rsp + 8], 0 ; l = 0
	add qword [rsp + 0], 1 ; k++
.jump400:
	; Compare k to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jge .jump398 ; If k >= bound, break
.jump401:
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 80 to rsp
		mov r10, [rbp - 80 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment m
	add qword [rsp + 16], 1
	jmp .jump397
.jump398: ; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	; Moving 8 bytes from rsp + 0 to rsp + 0
		mov r10, [rsp + 0 + 0]
		mov [rsp + 0 + 0], r10
	add rsp, 0
	pop rax
	pop r10
	sub rax, r10
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump402
	lea rdi, [rel const5] ; negative array index
	call _fail_assertion
.jump402:
	cmp rax, [rsp + 8]
	jl .jump403
	lea rdi, [rel const6] ; index too large
	call _fail_assertion
.jump403:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump404
	mov rax, [rel const7] ; True
	push rax
	jmp .jump405
.jump404:
	sub rsp, 8
	; Moving 8 bytes from rbp - 8 to rsp
		mov r10, [rbp - 8 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 8 to rsp
		mov r10, [rbp - 8 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 8 to rsp
		mov r10, [rbp - 8 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	sete al
	and rax, 1
	push rax
	mov rdi, 16
	sub rsp, 8 ; Align stack
	call _jpl_alloc
	add rsp, 8 ; Remove alignment
	; Moving 16 bytes from rsp to rax
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 16
	push rax
	mov rax, 2
	push rax
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for k
	mov rax, [rel const71] ; 873
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump406
	sub rsp, 8 ; Align stack
	lea rdi, [rel const0] ; non-positive loop bound
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump406:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize k to 0
	mov rax, 0
	push rax
.jump407: ; Begin body of loop
	; Compare k to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jge .jump408 ; If k >= bound, break
.jump409:
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - -16 to rsp
		mov r10, [r12 - -16 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 64 to rsp
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp r10, 0
	jne .jump410
	lea rdi, [rel const4] ; mod by zero
	call _fail_assertion
.jump410:
	cqo
	idiv r10
	mov rax, rdx
	push rax
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment k
	add qword [rsp + 0], 1
	jmp .jump407
.jump408: ; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump411
	lea rdi, [rel const5] ; negative array index
	call _fail_assertion
.jump411:
	cmp rax, [rsp + 8]
	jl .jump412
	lea rdi, [rel const6] ; index too large
	call _fail_assertion
.jump412:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	jne .jump413
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const72] ; 117
	push rax
	pop rdi
	call _to_float
	sub rsp, 8
	movsd [rsp], xmm0
	sub rsp, 8
	; Moving 8 bytes from rbp - 8 to rsp
		mov r10, [rbp - 8 + 0]
		mov [rsp + 0], r10
	; Moving 8 bytes from rsp + 0 to rsp + 16
		mov r10, [rsp + 0 + 0]
		mov [rsp + 16 + 0], r10
	add rsp, 16
	pop rax
.jump413:
	push rax
.jump405:
	pop rax
	cmp rax, 0
	jne .jump414
	sub rsp, 8 ; Align stack
	lea rdi, [rel const65] ; k
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump414:
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for l
	mov rax, [rel const7] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump415
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	jmp .jump416
.jump415:
	sub rsp, 8
	; Moving 8 bytes from rbp - -24 to rsp
		mov r10, [rbp - -24 + 0]
		mov [rsp + 0], r10
.jump416:
	sub rsp, 8
	; Moving 8 bytes from r12 - -16 to rsp
		mov r10, [r12 - -16 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	imul rax, r10
	push rax
	; Moving 8 bytes from rsp + 0 to rsp + 8
		mov r10, [rsp + 0 + 0]
		mov [rsp + 8 + 0], r10
	add rsp, 8
	mov rax, [rsp]
	cmp rax, 0
	jg .jump417
	sub rsp, 8 ; Align stack
	lea rdi, [rel const0] ; non-positive loop bound
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump417:
	; Computing bound for k
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump418
	lea rdi, [rel const0] ; non-positive loop bound
	call _fail_assertion
.jump418:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize l to 0
	mov rax, 0
	push rax
	; Initialize k to 0
	mov rax, 0
	push rax
.jump419: ; Begin body of loop
	; Compare l to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump421 ; If l >= bound, ...
	mov qword [rsp + 8], 0 ; l = 0
	add qword [rsp + 0], 1 ; k++
.jump421:
	; Compare k to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jge .jump420 ; If k >= bound, break
.jump422:
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment l
	add qword [rsp + 8], 1
	jmp .jump419
.jump420: ; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	sub rsp, 8 ; Align stack
	mov rax, [rel const73] ; 59.59
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	call _to_int
	add rsp, 8 ; Remove alignment
	push rax
	pop rax
	neg rax
	push rax
	pop rax
	pop r10
	cmp r10, 0
	jne .jump423
	lea rdi, [rel const22] ; divide by zero
	call _fail_assertion
.jump423:
	cqo
	idiv r10
	push rax
	pop rax
	pop r10
	cmp r10, 0
	jne .jump424
	sub rsp, 8 ; Align stack
	lea rdi, [rel const22] ; divide by zero
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump424:
	cqo
	idiv r10
	push rax
	pop rax
	add rsp, 24 ; Local variables
	pop rbp
	ret

e:
_e:
	push rbp
	mov rbp, rsp
	push rdi
	mov rax, [rel const3] ; False
	push rax
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump425
	; Moving 0 bytes from rsp + 0 to rsp + 0
	add rsp, 0
	jmp .jump426
.jump425:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for g
	mov rax, [rel const74] ; 708
	push rax
	mov rax, [rel const75] ; 281
	push rax
	pop rax
	pop r10
	cmp rax, r10
	setg al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump427
	sub rsp, 8
	; Moving 8 bytes from r12 - -16 to rsp
		mov r10, [r12 - -16 + 0]
		mov [rsp + 0], r10
	jmp .jump428
.jump427:
	sub rsp, 8
	; Moving 8 bytes from r12 - -16 to rsp
		mov r10, [r12 - -16 + 0]
		mov [rsp + 0], r10
.jump428:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump429
	sub rsp, 8 ; Align stack
	lea rdi, [rel const0] ; non-positive loop bound
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump429:
	; Computing bound for f
	sub rsp, 8
	; Moving 8 bytes from r12 - -16 to rsp
		mov r10, [r12 - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const76] ; 78
	push rax
	pop rax
	pop r10
	imul rax, r10
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump430
	lea rdi, [rel const0] ; non-positive loop bound
	call _fail_assertion
.jump430:
	; Computing total size of heap memory to allocate
	mov rdi, 0 ; sizeof {}
	imul rdi, [rsp + 0 + 0] ; multiply by (- (78 * argnum))
	jno .jump431
	lea rdi, [rel const1] ; overflow computing array size
	call _fail_assertion
.jump431:
	imul rdi, [rsp + 0 + 8] ; multiply by (if (281 > 708) then argnum else argnum)
	jno .jump432
	lea rdi, [rel const1] ; overflow computing array size
	call _fail_assertion
.jump432:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize g to 0
	mov rax, 0
	push rax
	; Initialize f to 0
	mov rax, 0
	push rax
.jump433: ; Begin body of loop
	; Compare g to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump435 ; If g >= bound, ...
	mov qword [rsp + 8], 0 ; g = 0
	add qword [rsp + 0], 1 ; f++
.jump435:
	; Compare f to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jge .jump434 ; If f >= bound, break
.jump436:
	; Compute loop body
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 0
	add rax, [rsp + 32]
	; Move body (0 bytes) to index
	; Moving 0 bytes from rsp to rax
	add rsp, 0
	; Increment g
	add qword [rsp + 8], 1
	jmp .jump433
.jump434: ; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	mov rax, [rel const77] ; 482
	push rax
	mov rax, [rel const78] ; 63
	push rax
	pop rax
	pop r10
	cmp r10, 0
	jne .jump437
	lea rdi, [rel const4] ; mod by zero
	call _fail_assertion
.jump437:
	cqo
	idiv r10
	mov rax, rdx
	push rax
	pop rax
	neg rax
	push rax
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for h
	sub rsp, 8
	; Moving 8 bytes from r12 - -16 to rsp
		mov r10, [r12 - -16 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump438
	sub rsp, 8 ; Align stack
	lea rdi, [rel const0] ; non-positive loop bound
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump438:
	; Computing bound for g
	mov rax, [rel const79] ; 648
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump439
	lea rdi, [rel const0] ; non-positive loop bound
	call _fail_assertion
.jump439:
	; Computing bound for f
	mov rax, [rel const80] ; 766
	push rax
	mov rax, [rel const81] ; 365
	push rax
	pop rax
	pop r10
	cmp r10, 0
	jne .jump440
	lea rdi, [rel const4] ; mod by zero
	call _fail_assertion
.jump440:
	cqo
	idiv r10
	mov rax, rdx
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump441
	sub rsp, 8 ; Align stack
	lea rdi, [rel const0] ; non-positive loop bound
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump441:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int
	imul rdi, [rsp + 0 + 0] ; multiply by (365 % 766)
	jno .jump442
	sub rsp, 8 ; Align stack
	lea rdi, [rel const1] ; overflow computing array size
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump442:
	imul rdi, [rsp + 0 + 8] ; multiply by 648
	jno .jump443
	sub rsp, 8 ; Align stack
	lea rdi, [rel const1] ; overflow computing array size
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump443:
	imul rdi, [rsp + 0 + 16] ; multiply by (- argnum)
	jno .jump444
	sub rsp, 8 ; Align stack
	lea rdi, [rel const1] ; overflow computing array size
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump444:
	sub rsp, 8 ; Align stack
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize h to 0
	mov rax, 0
	push rax
	; Initialize g to 0
	mov rax, 0
	push rax
	; Initialize f to 0
	mov rax, 0
	push rax
.jump445: ; Begin body of loop
	; Compare h to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump447 ; If h >= bound, ...
	mov qword [rsp + 16], 0 ; h = 0
	add qword [rsp + 8], 1 ; g++
.jump447:
	; Compare g to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump448 ; If g >= bound, ...
	mov qword [rsp + 8], 0 ; g = 0
	add qword [rsp + 0], 1 ; f++
.jump448:
	; Compare f to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jge .jump446 ; If f >= bound, break
.jump449:
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 88 to rsp
		mov r10, [rbp - 88 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment h
	add qword [rsp + 16], 1
	jmp .jump445
.jump446: ; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	mov rax, [rel const82] ; 206
	push rax
	mov rax, [rel const83] ; 99.48
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	call _to_int
	push rax
	pop rax
	neg rax
	push rax
	sub rsp, 8 ; Align stack
	mov rax, [rel const84] ; 42.8
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	call _tan
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	call _to_int
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump450
	lea rdi, [rel const5] ; negative array index
	call _fail_assertion
.jump450:
	cmp rax, [rsp + 24]
	jl .jump451
	lea rdi, [rel const6] ; index too large
	call _fail_assertion
.jump451:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump452
	lea rdi, [rel const5] ; negative array index
	call _fail_assertion
.jump452:
	cmp rax, [rsp + 32]
	jl .jump453
	lea rdi, [rel const6] ; index too large
	call _fail_assertion
.jump453:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump454
	lea rdi, [rel const5] ; negative array index
	call _fail_assertion
.jump454:
	cmp rax, [rsp + 40]
	jl .jump455
	lea rdi, [rel const6] ; index too large
	call _fail_assertion
.jump455:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 8
	; Moving 8 bytes from rax to rsp
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump456
	lea rdi, [rel const5] ; negative array index
	call _fail_assertion
.jump456:
	cmp rax, [rsp + 16]
	jl .jump457
	lea rdi, [rel const6] ; index too large
	call _fail_assertion
.jump457:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump458
	lea rdi, [rel const5] ; negative array index
	call _fail_assertion
.jump458:
	cmp rax, [rsp + 24]
	jl .jump459
	lea rdi, [rel const6] ; index too large
	call _fail_assertion
.jump459:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 0
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 0
	; Moving 0 bytes from rax to rsp
.jump426:
	mov rax, [rel const7] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump460
	mov rax, [rel const3] ; False
	push rax
	pop rax
.jump460:
	push rax
	pop rax
	cmp rax, 0
	je .jump461
	mov rax, [rel const85] ; 35.05
	push rax
	mov rax, [rel const86] ; 55.92
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmplesd xmm1, xmm0
	movq rax, xmm1
	and rax, 1
	push rax
	pop rax
.jump461:
	push rax
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump462
	mov rax, [rel const3] ; False
	push rax
	mov rax, [rel const3] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump464
	mov rax, [rel const7] ; True
	push rax
	jmp .jump465
.jump464:
	mov rax, [rel const7] ; True
	push rax
.jump465:
	pop rax
	cmp rax, 0
	je .jump466
	mov rax, [rel const3] ; False
	push rax
	pop rax
	xor rax, 1
	push rax
	pop rax
.jump466:
	push rax
	pop rax
	pop r10
	cmp rax, r10
	sete al
	and rax, 1
	push rax
	jmp .jump463
.jump462:
	mov rax, [rel const7] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump467
	mov rax, [rel const3] ; False
	push rax
	jmp .jump468
.jump467:
	mov rax, [rel const7] ; True
	push rax
.jump468:
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump469
	mov rax, [rel const3] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump471
	mov rax, [rel const3] ; False
	push rax
	pop rax
	xor rax, 1
	push rax
	jmp .jump472
.jump471:
	mov rax, [rel const7] ; True
	push rax
	pop rax
	xor rax, 1
	push rax
.jump472:
	jmp .jump470
.jump469:
	mov rax, [rel const3] ; False
	push rax
	pop rax
	xor rax, 1
	push rax
	mov rax, [rel const3] ; False
	push rax
	pop rax
	pop r10
	cmp rax, r10
	sete al
	and rax, 1
	push rax
.jump470:
.jump463:
	pop rax
	cmp rax, 0
	jne .jump473
	sub rsp, 8
	; Moving 8 bytes from r12 - -16 to rsp
		mov r10, [r12 - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const87] ; 2.97
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	call _to_int
	push rax
	pop rax
	pop r10
	cmp rax, r10
	setge al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump474
	sub rsp, 8
	; Moving 8 bytes from r12 - -16 to rsp
		mov r10, [r12 - -16 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rel const18] ; 583
	push rax
	pop rax
	pop r10
	add rax, r10
	push rax
	jmp .jump475
.jump474:
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for h
	sub rsp, 8
	; Moving 8 bytes from r12 - -16 to rsp
		mov r10, [r12 - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump476
	sub rsp, 8 ; Align stack
	lea rdi, [rel const0] ; non-positive loop bound
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump476:
	; Computing bound for g
	mov rax, [rel const88] ; 778
	push rax
	mov rax, [rel const89] ; 833
	push rax
	pop rax
	pop r10
	cmp r10, 0
	jne .jump477
	sub rsp, 8 ; Align stack
	lea rdi, [rel const22] ; divide by zero
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump477:
	cqo
	idiv r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump478
	lea rdi, [rel const0] ; non-positive loop bound
	call _fail_assertion
.jump478:
	; Computing bound for f
	mov rax, [rel const90] ; 76
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump479
	sub rsp, 8 ; Align stack
	lea rdi, [rel const0] ; non-positive loop bound
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump479:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize h to 0
	mov rax, 0
	push rax
	; Initialize g to 0
	mov rax, 0
	push rax
	; Initialize f to 0
	mov rax, 0
	push rax
.jump480: ; Begin body of loop
	; Compare h to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump482 ; If h >= bound, ...
	mov qword [rsp + 16], 0 ; h = 0
	add qword [rsp + 8], 1 ; g++
.jump482:
	; Compare g to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump483 ; If g >= bound, ...
	mov qword [rsp + 8], 0 ; g = 0
	add qword [rsp + 0], 1 ; f++
.jump483:
	; Compare f to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jge .jump481 ; If f >= bound, break
.jump484:
	; Compute loop body
	mov rax, [rel const91] ; 737
	push rax
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment h
	add qword [rsp + 16], 1
	jmp .jump480
.jump481: ; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
.jump475:
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for g
	mov rax, [rel const7] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump485
	mov rax, [rel const92] ; 828
	push rax
	jmp .jump486
.jump485:
	sub rsp, 8
	; Moving 8 bytes from r12 - -16 to rsp
		mov r10, [r12 - -16 + 0]
		mov [rsp + 0], r10
.jump486:
	sub rsp, 8
	; Moving 8 bytes from r12 - -16 to rsp
		mov r10, [r12 - -16 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	pop rax
	pop r10
	sub rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump487
	lea rdi, [rel const0] ; non-positive loop bound
	call _fail_assertion
.jump487:
	; Computing bound for f
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for g
	sub rsp, 8
	; Moving 8 bytes from r12 - -16 to rsp
		mov r10, [r12 - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const93] ; 55
	push rax
	pop rax
	pop r10
	cmp r10, 0
	jne .jump488
	sub rsp, 8 ; Align stack
	lea rdi, [rel const22] ; divide by zero
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump488:
	cqo
	idiv r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump489
	lea rdi, [rel const0] ; non-positive loop bound
	call _fail_assertion
.jump489:
	; Computing bound for f
	mov rax, [rel const7] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump490
	mov rax, [rel const94] ; 947
	push rax
	jmp .jump491
.jump490:
	sub rsp, 8
	; Moving 8 bytes from r12 - -16 to rsp
		mov r10, [r12 - -16 + 0]
		mov [rsp + 0], r10
.jump491:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump492
	sub rsp, 8 ; Align stack
	lea rdi, [rel const0] ; non-positive loop bound
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump492:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize g to 0
	mov rax, 0
	push rax
	; Initialize f to 0
	mov rax, 0
	push rax
.jump493: ; Begin body of loop
	; Compare g to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump495 ; If g >= bound, ...
	mov qword [rsp + 8], 0 ; g = 0
	add qword [rsp + 0], 1 ; f++
.jump495:
	; Compare f to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jge .jump494 ; If f >= bound, break
.jump496:
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 64 to rsp
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const95] ; 511
	push rax
	pop rax
	pop r10
	imul rax, r10
	push rax
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment g
	add qword [rsp + 8], 1
	jmp .jump493
.jump494: ; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump497
	sub rsp, 8 ; Align stack
	lea rdi, [rel const0] ; non-positive loop bound
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump497:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize g to 0
	mov rax, 0
	push rax
	; Initialize f to 0
	mov rax, 0
	push rax
.jump498: ; Begin body of loop
	; Compare g to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump500 ; If g >= bound, ...
	mov qword [rsp + 8], 0 ; g = 0
	add qword [rsp + 0], 1 ; f++
.jump500:
	; Compare f to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jge .jump499 ; If f >= bound, break
.jump501:
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment g
	add qword [rsp + 8], 1
	jmp .jump498
.jump499: ; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	pop rax
	pop r10
	cmp rax, r10
	setge al
	and rax, 1
	push rax
	pop rax
.jump473:
	push rax
	pop rax
	cmp rax, 0
	jne .jump502
	sub rsp, 8 ; Align stack
	lea rdi, [rel const96] ; f
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump502:
	mov rax, [rel const7] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump503
	mov rax, [rel const3] ; False
	push rax
	pop rax
	cmp rax, 0
	jne .jump505
	mov rax, [rel const3] ; False
	push rax
	pop rax
.jump505:
	push rax
	pop rax
	cmp rax, 0
	jne .jump506
	mov rax, [rel const7] ; True
	push rax
	pop rax
.jump506:
	push rax
	jmp .jump504
.jump503:
	sub rsp, 16
	sub rsp, 8 ; Align stack
	lea rdi, [rsp + 8]
	call _e
	add rsp, 8 ; Remove alignment
	mov rax, [rel const97] ; 424
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump507
	lea rdi, [rel const5] ; negative array index
	call _fail_assertion
.jump507:
	cmp rax, [rsp + 8]
	jl .jump508
	lea rdi, [rel const6] ; index too large
	call _fail_assertion
.jump508:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp
		mov r10, [rax + 0]
		mov [rsp + 0], r10
.jump504:
	pop rax
	cmp rax, 0
	je .jump509
	mov rax, [rel const98] ; 387
	push rax
	pop rax
	neg rax
	push rax
	sub rsp, 8
	; Moving 8 bytes from r12 - -16 to rsp
		mov r10, [r12 - -16 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	sub rax, r10
	push rax
	pop rax
	neg rax
	push rax
	jmp .jump510
.jump509:
	mov rax, [rel const99] ; 372
	push rax
.jump510:
	sub rsp, 16
	lea rdi, [rsp + 0]
	call _e
	mov rax, [rel const100] ; 339
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump511
	sub rsp, 8 ; Align stack
	lea rdi, [rel const5] ; negative array index
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump511:
	cmp rax, [rsp + 8]
	jl .jump512
	sub rsp, 8 ; Align stack
	lea rdi, [rel const6] ; index too large
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump512:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump513
	mov rax, [rel const7] ; True
	push rax
	jmp .jump514
.jump513:
	mov rax, [rel const101] ; 965
	push rax
	sub rsp, 8
	; Moving 8 bytes from r12 - -16 to rsp
		mov r10, [r12 - -16 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	sete al
	and rax, 1
	push rax
.jump514:
	pop rax
	cmp rax, 0
	je .jump515
	sub rsp, 24
	sub rsp, 8 ; Align stack
	lea rdi, [rsp + 8]
	call _b
	add rsp, 8 ; Remove alignment
	mov rax, [rel const3] ; False
	push rax
	sub rsp, 8
	; Moving 8 bytes from r12 - -16 to rsp
		mov r10, [r12 - -16 + 0]
		mov [rsp + 0], r10
	jmp .jump516
.jump515:
	sub rsp, 24
	sub rsp, 8 ; Align stack
	lea rdi, [rsp + 8]
	call _b
	add rsp, 8 ; Remove alignment
	mov rax, [rel const7] ; True
	push rax
	pop rax
	xor rax, 1
	push rax
	mov rax, [rel const102] ; 739
	push rax
	pop rax
	neg rax
	push rax
.jump516:
	; Moving 8 bytes from rsp + 0 to rsp + 32
		mov r10, [rsp + 0 + 0]
		mov [rsp + 32 + 0], r10
	add rsp, 32
	pop rax
	pop r10
	cmp rax, r10
	setne al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	jne .jump517
	sub rsp, 8 ; Align stack
	lea rdi, [rel const96] ; f
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump517:
	mov rax, [rel const7] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump518
	mov rax, [rel const7] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump520
	sub rsp, 8
	; Moving 8 bytes from r12 - -16 to rsp
		mov r10, [r12 - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const103] ; 910
	push rax
	pop rax
	pop r10
	cmp rax, r10
	setl al
	and rax, 1
	push rax
	jmp .jump521
.jump520:
	mov rax, [rel const7] ; True
	push rax
.jump521:
	pop rax
	cmp rax, 0
	je .jump522
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for h
	mov rax, [rel const104] ; 85.94
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	call _to_int
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump524
	sub rsp, 8 ; Align stack
	lea rdi, [rel const0] ; non-positive loop bound
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump524:
	; Computing bound for g
	mov rax, [rel const105] ; 204
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump525
	lea rdi, [rel const0] ; non-positive loop bound
	call _fail_assertion
.jump525:
	; Computing bound for f
	mov rax, [rel const106] ; 305
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump526
	sub rsp, 8 ; Align stack
	lea rdi, [rel const0] ; non-positive loop bound
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump526:
	; Computing total size of heap memory to allocate
	mov rdi, 16 ; sizeof bool[]
	imul rdi, [rsp + 0 + 0] ; multiply by 305
	jno .jump527
	sub rsp, 8 ; Align stack
	lea rdi, [rel const1] ; overflow computing array size
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump527:
	imul rdi, [rsp + 0 + 8] ; multiply by 204
	jno .jump528
	sub rsp, 8 ; Align stack
	lea rdi, [rel const1] ; overflow computing array size
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump528:
	imul rdi, [rsp + 0 + 16] ; multiply by to_int(85.94)
	jno .jump529
	sub rsp, 8 ; Align stack
	lea rdi, [rel const1] ; overflow computing array size
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump529:
	sub rsp, 8 ; Align stack
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize h to 0
	mov rax, 0
	push rax
	; Initialize g to 0
	mov rax, 0
	push rax
	; Initialize f to 0
	mov rax, 0
	push rax
.jump530: ; Begin body of loop
	; Compare h to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump532 ; If h >= bound, ...
	mov qword [rsp + 16], 0 ; h = 0
	add qword [rsp + 8], 1 ; g++
.jump532:
	; Compare g to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump533 ; If g >= bound, ...
	mov qword [rsp + 8], 0 ; g = 0
	add qword [rsp + 0], 1 ; f++
.jump533:
	; Compare f to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jge .jump531 ; If f >= bound, break
.jump534:
	; Compute loop body
	sub rsp, 16
	lea rdi, [rsp + 0]
	call _e
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 16
	add rax, [rsp + 64]
	; Move body (16 bytes) to index
	; Moving 16 bytes from rsp to rax
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 16
	; Increment h
	add qword [rsp + 16], 1
	jmp .jump530
.jump531: ; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	jmp .jump523
.jump522:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for h
	mov rax, [rel const107] ; 460
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump535
	sub rsp, 8 ; Align stack
	lea rdi, [rel const0] ; non-positive loop bound
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump535:
	; Computing bound for g
	mov rax, [rel const108] ; 961
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump536
	lea rdi, [rel const0] ; non-positive loop bound
	call _fail_assertion
.jump536:
	; Computing bound for f
	mov rax, [rel const109] ; 11
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump537
	sub rsp, 8 ; Align stack
	lea rdi, [rel const0] ; non-positive loop bound
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump537:
	; Computing total size of heap memory to allocate
	mov rdi, 16 ; sizeof bool[]
	imul rdi, [rsp + 0 + 0] ; multiply by 11
	jno .jump538
	sub rsp, 8 ; Align stack
	lea rdi, [rel const1] ; overflow computing array size
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump538:
	imul rdi, [rsp + 0 + 8] ; multiply by (- 961)
	jno .jump539
	sub rsp, 8 ; Align stack
	lea rdi, [rel const1] ; overflow computing array size
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump539:
	imul rdi, [rsp + 0 + 16] ; multiply by (- 460)
	jno .jump540
	sub rsp, 8 ; Align stack
	lea rdi, [rel const1] ; overflow computing array size
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump540:
	sub rsp, 8 ; Align stack
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize h to 0
	mov rax, 0
	push rax
	; Initialize g to 0
	mov rax, 0
	push rax
	; Initialize f to 0
	mov rax, 0
	push rax
.jump541: ; Begin body of loop
	; Compare h to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump543 ; If h >= bound, ...
	mov qword [rsp + 16], 0 ; h = 0
	add qword [rsp + 8], 1 ; g++
.jump543:
	; Compare g to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump544 ; If g >= bound, ...
	mov qword [rsp + 8], 0 ; g = 0
	add qword [rsp + 0], 1 ; f++
.jump544:
	; Compare f to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jge .jump542 ; If f >= bound, break
.jump545:
	; Compute loop body
	sub rsp, 16
	lea rdi, [rsp + 0]
	call _e
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 16
	add rax, [rsp + 64]
	; Move body (16 bytes) to index
	; Moving 16 bytes from rsp to rax
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 16
	; Increment h
	add qword [rsp + 16], 1
	jmp .jump541
.jump542: ; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
.jump523:
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for g
	mov rax, [rel const7] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump546
	mov rax, [rel const110] ; 622
	push rax
	pop rax
	neg rax
	push rax
	jmp .jump547
.jump546:
	mov rax, [rel const111] ; 29.7
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	call _to_int
	push rax
.jump547:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump548
	sub rsp, 8 ; Align stack
	lea rdi, [rel const0] ; non-positive loop bound
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump548:
	; Computing bound for f
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for f
	sub rsp, 8
	; Moving 8 bytes from r12 - -16 to rsp
		mov r10, [r12 - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump549
	sub rsp, 8 ; Align stack
	lea rdi, [rel const0] ; non-positive loop bound
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump549:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int
	imul rdi, [rsp + 0 + 0] ; multiply by argnum
	jno .jump550
	sub rsp, 8 ; Align stack
	lea rdi, [rel const1] ; overflow computing array size
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump550:
	sub rsp, 8 ; Align stack
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize f to 0
	mov rax, 0
	push rax
.jump551: ; Begin body of loop
	; Compare f to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jge .jump552 ; If f >= bound, break
.jump553:
	; Compute loop body
	mov rax, [rel const112] ; 621
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 24]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment f
	add qword [rsp + 0], 1
	jmp .jump551
.jump552: ; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	mov rax, [rel const113] ; 880
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump554
	lea rdi, [rel const5] ; negative array index
	call _fail_assertion
.jump554:
	cmp rax, [rsp + 8]
	jl .jump555
	lea rdi, [rel const6] ; index too large
	call _fail_assertion
.jump555:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump556
	lea rdi, [rel const0] ; non-positive loop bound
	call _fail_assertion
.jump556:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize g to 0
	mov rax, 0
	push rax
	; Initialize f to 0
	mov rax, 0
	push rax
.jump557: ; Begin body of loop
	; Compare g to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump559 ; If g >= bound, ...
	mov qword [rsp + 8], 0 ; g = 0
	add qword [rsp + 0], 1 ; f++
.jump559:
	; Compare f to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jge .jump558 ; If f >= bound, break
.jump560:
	; Compute loop body
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for j
	mov rax, [rel const3] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump561
	mov rax, [rel const114] ; 487
	push rax
	jmp .jump562
.jump561:
	sub rsp, 8
	; Moving 8 bytes from r12 - -16 to rsp
		mov r10, [r12 - -16 + 0]
		mov [rsp + 0], r10
.jump562:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump563
	lea rdi, [rel const0] ; non-positive loop bound
	call _fail_assertion
.jump563:
	; Computing bound for i
	mov rax, [rel const115] ; 876
	push rax
	sub rsp, 8
	; Moving 8 bytes from r12 - -16 to rsp
		mov r10, [r12 - -16 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp r10, 0
	jne .jump564
	lea rdi, [rel const22] ; divide by zero
	call _fail_assertion
.jump564:
	cqo
	idiv r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump565
	sub rsp, 8 ; Align stack
	lea rdi, [rel const0] ; non-positive loop bound
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump565:
	; Computing bound for h
	sub rsp, 8
	; Moving 8 bytes from rbp - 80 to rsp
		mov r10, [rbp - 80 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump566
	lea rdi, [rel const0] ; non-positive loop bound
	call _fail_assertion
.jump566:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize j to 0
	mov rax, 0
	push rax
	; Initialize i to 0
	mov rax, 0
	push rax
	; Initialize h to 0
	mov rax, 0
	push rax
.jump567: ; Begin body of loop
	; Compare j to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump569 ; If j >= bound, ...
	mov qword [rsp + 16], 0 ; j = 0
	add qword [rsp + 8], 1 ; i++
.jump569:
	; Compare i to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump570 ; If i >= bound, ...
	mov qword [rsp + 8], 0 ; i = 0
	add qword [rsp + 0], 1 ; h++
.jump570:
	; Compare h to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jge .jump568 ; If h >= bound, break
.jump571:
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 80 to rsp
		mov r10, [rbp - 80 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment j
	add qword [rsp + 16], 1
	jmp .jump567
.jump568: ; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment g
	add qword [rsp + 8], 1
	jmp .jump557
.jump558: ; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	sub rsp, 8
	; Moving 8 bytes from r12 - -16 to rsp
		mov r10, [r12 - -16 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - -16 to rsp
		mov r10, [r12 - -16 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp r10, 0
	jne .jump572
	lea rdi, [rel const22] ; divide by zero
	call _fail_assertion
.jump572:
	cqo
	idiv r10
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rel const116] ; 293
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump573
	lea rdi, [rel const5] ; negative array index
	call _fail_assertion
.jump573:
	cmp rax, [rsp + 24]
	jl .jump574
	lea rdi, [rel const6] ; index too large
	call _fail_assertion
.jump574:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump575
	lea rdi, [rel const5] ; negative array index
	call _fail_assertion
.jump575:
	cmp rax, [rsp + 32]
	jl .jump576
	lea rdi, [rel const6] ; index too large
	call _fail_assertion
.jump576:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump577
	lea rdi, [rel const5] ; negative array index
	call _fail_assertion
.jump577:
	cmp rax, [rsp + 40]
	jl .jump578
	lea rdi, [rel const6] ; index too large
	call _fail_assertion
.jump578:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 16
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 16
	; Moving 16 bytes from rax to rsp
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	jmp .jump519
.jump518:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for f
	mov rax, [rel const117] ; 131
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump579
	sub rsp, 8 ; Align stack
	lea rdi, [rel const0] ; non-positive loop bound
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump579:
	; Computing total size of heap memory to allocate
	mov rdi, 32 ; sizeof {{},bool[],bool[]}
	imul rdi, [rsp + 0 + 0] ; multiply by 131
	jno .jump580
	sub rsp, 8 ; Align stack
	lea rdi, [rel const1] ; overflow computing array size
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump580:
	sub rsp, 8 ; Align stack
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize f to 0
	mov rax, 0
	push rax
.jump581: ; Begin body of loop
	; Compare f to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jge .jump582 ; If f >= bound, break
.jump583:
	; Compute loop body
	sub rsp, 16
	lea rdi, [rsp + 0]
	call _e
	sub rsp, 16
	lea rdi, [rsp + 0]
	call _e
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 32
	add rax, [rsp + 48]
	; Move body (32 bytes) to index
	; Moving 32 bytes from rsp to rax
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	; Increment f
	add qword [rsp + 0], 1
	jmp .jump581
.jump582: ; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	mov rax, [rel const3] ; False
	push rax
	pop rax
	cmp rax, 0
	jne .jump584
	mov rax, [rel const3] ; False
	push rax
	pop rax
.jump584:
	push rax
	pop rax
	cmp rax, 0
	je .jump585
	sub rsp, 8
	; Moving 8 bytes from r12 - -16 to rsp
		mov r10, [r12 - -16 + 0]
		mov [rsp + 0], r10
	jmp .jump586
.jump585:
	mov rax, [rel const118] ; 105
	push rax
.jump586:
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump587
	lea rdi, [rel const5] ; negative array index
	call _fail_assertion
.jump587:
	cmp rax, [rsp + 8]
	jl .jump588
	lea rdi, [rel const6] ; index too large
	call _fail_assertion
.jump588:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 32
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 32
	; Moving 32 bytes from rax to rsp
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	; Moving 16 bytes from rsp + 16 to rsp + 16
		mov r10, [rsp + 16 + 8]
		mov [rsp + 16 + 8], r10
		mov r10, [rsp + 16 + 0]
		mov [rsp + 16 + 0], r10
	add rsp, 16
.jump519:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for h
	sub rsp, 8
	; Moving 8 bytes from r12 - -16 to rsp
		mov r10, [r12 - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump589
	sub rsp, 8 ; Align stack
	lea rdi, [rel const0] ; non-positive loop bound
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump589:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool
	imul rdi, [rsp + 0 + 0] ; multiply by argnum
	jno .jump590
	sub rsp, 8 ; Align stack
	lea rdi, [rel const1] ; overflow computing array size
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump590:
	sub rsp, 8 ; Align stack
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize h to 0
	mov rax, 0
	push rax
.jump591: ; Begin body of loop
	; Compare h to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jge .jump592 ; If h >= bound, break
.jump593:
	; Compute loop body
	mov rax, [rel const3] ; False
	push rax
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump594
	mov rax, [rel const7] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump596
	mov rax, [rel const119] ; 516
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	setne al
	and rax, 1
	push rax
	jmp .jump597
.jump596:
	mov rax, [rel const7] ; True
	push rax
.jump597:
	pop rax
	cmp rax, 0
	je .jump598
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const60] ; 113
	push rax
	pop rax
	pop r10
	cmp rax, r10
	setge al
	and rax, 1
	push rax
	pop rax
.jump598:
	push rax
	jmp .jump595
.jump594:
	mov rax, [rel const120] ; 93.89
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	call _sqrt
	sub rsp, 8
	movsd [rsp], xmm0
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for k
	mov rax, [rel const103] ; 910
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump599
	sub rsp, 8 ; Align stack
	lea rdi, [rel const0] ; non-positive loop bound
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump599:
	; Computing bound for j
	sub rsp, 8
	; Moving 8 bytes from r12 - -16 to rsp
		mov r10, [r12 - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const121] ; 22
	push rax
	pop rax
	pop r10
	cmp r10, 0
	jne .jump600
	sub rsp, 8 ; Align stack
	lea rdi, [rel const4] ; mod by zero
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump600:
	cqo
	idiv r10
	mov rax, rdx
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump601
	lea rdi, [rel const0] ; non-positive loop bound
	call _fail_assertion
.jump601:
	; Computing bound for i
	sub rsp, 8
	; Moving 8 bytes from r12 - -16 to rsp
		mov r10, [r12 - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump602
	sub rsp, 8 ; Align stack
	lea rdi, [rel const0] ; non-positive loop bound
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump602:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize k to 0
	mov rax, 0
	push rax
	; Initialize j to 0
	mov rax, 0
	push rax
	; Initialize i to 0
	mov rax, 0
	push rax
.jump603: ; Begin body of loop
	; Compare k to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump605 ; If k >= bound, ...
	mov qword [rsp + 16], 0 ; k = 0
	add qword [rsp + 8], 1 ; j++
.jump605:
	; Compare j to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump606 ; If j >= bound, ...
	mov qword [rsp + 8], 0 ; j = 0
	add qword [rsp + 0], 1 ; i++
.jump606:
	; Compare i to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jge .jump604 ; If i >= bound, break
.jump607:
	; Compute loop body
	mov rax, [rel const122] ; 54.22
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp + 48] ; Load sum
	addsd xmm0, xmm1 ; Add loop body
	movsd [rsp + 48], xmm0 ; Save sum
	; Increment k
	add qword [rsp + 16], 1
	jmp .jump603
.jump604: ; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmplesd xmm0, xmm1
	movq rax, xmm0
	and rax, 1
	push rax
.jump595:
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 24]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment h
	add qword [rsp + 0], 1
	jmp .jump591
.jump592: ; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	mov rax, [rbp - 8] ; Address to write return value into
	; Moving 16 bytes from rsp to rax
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 40 ; Local variables
	pop rbp
	ret

j:
_j:
	push rbp
	mov rbp, rsp
	push rdi
	push rsi
	sub rsp, 16
	; Moving 16 bytes from r12 - -16 to rsp
		mov r10, [r12 - -16 + 8]
		mov [rsp + 8], r10
		mov r10, [r12 - -16 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const147] ; 28
	push rax
	mov rdi, 8
	call _jpl_alloc
	; Moving 8 bytes from rsp to rax
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	push rax
	mov rax, 1
	push rax
	sub rsp, 8 ; Align stack
	mov rax, [rel const148] ; 14.89
	push rax
	mov rax, [rel const149] ; 59.1
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	call _atan2
	add rsp, 8 ; Remove alignment
	sub rsp, 8
	movsd [rsp], xmm0
	mov rax, [rel const150] ; 86.34
	push rax
	mov rdi, 16
	sub rsp, 8 ; Align stack
	call _jpl_alloc
	add rsp, 8 ; Remove alignment
	; Moving 16 bytes from rsp to rax
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 16
	push rax
	mov rax, 2
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump723
	lea rdi, [rel const5] ; negative array index
	call _fail_assertion
.jump723:
	cmp rax, [rsp + 8]
	jl .jump724
	lea rdi, [rel const6] ; index too large
	call _fail_assertion
.jump724:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rel const151] ; 90.56
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	call _log
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	call _sqrt
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmpltsd xmm1, xmm0
	movq rax, xmm1
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump725
	sub rsp, 8 ; Align stack
	mov rax, [rel const152] ; 76.42
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	call _atan
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	call _cos
	add rsp, 8 ; Remove alignment
	sub rsp, 8
	movsd [rsp], xmm0
	mov rax, [rel const3] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump726
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	jne .jump728
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	pop rax
.jump728:
	push rax
	pop rax
	cmp rax, 0
	je .jump729
	mov rax, [rel const153] ; 70.74
	push rax
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	jmp .jump730
.jump729:
	mov rax, [rel const154] ; 7.75
	push rax
	mov rax, [rel const155] ; 73.68
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	mulsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
.jump730:
	jmp .jump727
.jump726:
	mov rax, [rel const156] ; 120
	push rax
	pop rdi
	call _to_float
	sub rsp, 8
	movsd [rsp], xmm0
	sub rsp, 8 ; Align stack
	mov rax, [rel const157] ; 11.08
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	call _acos
	add rsp, 8 ; Remove alignment
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	call _pow
	sub rsp, 8
	movsd [rsp], xmm0
.jump727:
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmplesd xmm1, xmm0
	movq rax, xmm1
	and rax, 1
	push rax
	pop rax
.jump725:
	push rax
	pop rax
	cmp rax, 0
	jne .jump731
	sub rsp, 8 ; Align stack
	lea rdi, [rel const158] ; p
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump731:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for r
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump732
	sub rsp, 8 ; Align stack
	lea rdi, [rel const0] ; non-positive loop bound
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump732:
	; Computing bound for q
	sub rsp, 8
	; Moving 8 bytes from r12 - 32 to rsp
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump733
	lea rdi, [rel const0] ; non-positive loop bound
	call _fail_assertion
.jump733:
	; Computing bound for p
	sub rsp, 8
	; Moving 8 bytes from r12 - -16 to rsp
		mov r10, [r12 - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump734
	sub rsp, 8 ; Align stack
	lea rdi, [rel const0] ; non-positive loop bound
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump734:
	; Computing total size of heap memory to allocate
	mov rdi, 16 ; sizeof bool[]
	imul rdi, [rsp + 0 + 0] ; multiply by argnum
	jno .jump735
	sub rsp, 8 ; Align stack
	lea rdi, [rel const1] ; overflow computing array size
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump735:
	imul rdi, [rsp + 0 + 8] ; multiply by h
	jno .jump736
	sub rsp, 8 ; Align stack
	lea rdi, [rel const1] ; overflow computing array size
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump736:
	imul rdi, [rsp + 0 + 16] ; multiply by o
	jno .jump737
	sub rsp, 8 ; Align stack
	lea rdi, [rel const1] ; overflow computing array size
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump737:
	sub rsp, 8 ; Align stack
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize r to 0
	mov rax, 0
	push rax
	; Initialize q to 0
	mov rax, 0
	push rax
	; Initialize p to 0
	mov rax, 0
	push rax
.jump738: ; Begin body of loop
	; Compare r to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump740 ; If r >= bound, ...
	mov qword [rsp + 16], 0 ; r = 0
	add qword [rsp + 8], 1 ; q++
.jump740:
	; Compare q to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump741 ; If q >= bound, ...
	mov qword [rsp + 8], 0 ; q = 0
	add qword [rsp + 0], 1 ; p++
.jump741:
	; Compare p to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jge .jump739 ; If p >= bound, break
.jump742:
	; Compute loop body
	mov rax, [rel const7] ; True
	push rax
	; Moving 8 bytes from rsp + 0 to rsp + 0
		mov r10, [rsp + 0 + 0]
		mov [rsp + 0 + 0], r10
	add rsp, 0
	pop rax
	cmp rax, 0
	je .jump743
	mov rax, [rel const3] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump745
	sub rsp, 16
	lea rdi, [rsp + 0]
	call _e
	jmp .jump746
.jump745:
	sub rsp, 16
	lea rdi, [rsp + 0]
	call _e
.jump746:
	jmp .jump744
.jump743:
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump747
	sub rsp, 16
	lea rdi, [rsp + 0]
	call _e
	jmp .jump748
.jump747:
	sub rsp, 16
	lea rdi, [rsp + 0]
	call _e
.jump748:
.jump744:
	; Moving 16 bytes from rsp + 0 to rsp + 0
		mov r10, [rsp + 0 + 8]
		mov [rsp + 0 + 8], r10
		mov r10, [rsp + 0 + 0]
		mov [rsp + 0 + 0], r10
	add rsp, 0
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 16
	add rax, [rsp + 64]
	; Move body (16 bytes) to index
	; Moving 16 bytes from rsp to rax
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 16
	; Increment r
	add qword [rsp + 16], 1
	jmp .jump738
.jump739: ; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	mov rax, [rbp - 8] ; Address to write return value into
	; Moving 32 bytes from rsp to rax
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 88 ; Local variables
	pop rbp
	ret

k:
_k:
	push rbp
	mov rbp, rsp
	push rdi
	push rsi
	sub rsp, 16
	; Moving 16 bytes from r12 - -16 to rsp
		mov r10, [r12 - -16 + 8]
		mov [rsp + 8], r10
		mov r10, [r12 - -16 + 0]
		mov [rsp + 0], r10
	mov rdi, 16
	call _jpl_alloc
	; Moving 16 bytes from rsp to rax
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 16
	push rax
	mov rax, 1
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump765
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	pop rax
.jump765:
	push rax
	pop rax
	cmp rax, 0
	jne .jump766
	lea rdi, [rel const158] ; p
	call _fail_assertion
.jump766:
	sub rsp, 16
	; Moving 16 bytes from r12 - -16 to rsp
		mov r10, [r12 - -16 + 8]
		mov [rsp + 8], r10
		mov r10, [r12 - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const7] ; True
	push rax
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump767
	mov rax, [rel const165] ; 970
	push rax
	sub rsp, 16
	; Moving 16 bytes from r12 - -16 to rsp
		mov r10, [r12 - -16 + 8]
		mov [rsp + 8], r10
		mov r10, [r12 - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const7] ; True
	push rax
	; Moving 8 bytes from rsp + 0 to rsp + 24
		mov r10, [rsp + 0 + 0]
		mov [rsp + 24 + 0], r10
	add rsp, 24
	sub rsp, 32
	; Moving 32 bytes from rbp - -16 to rsp
		mov r10, [rbp - -16 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - -16 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -16 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	; Moving 8 bytes from rsp + 8 to rsp + 24
		mov r10, [rsp + 8 + 0]
		mov [rsp + 24 + 0], r10
	add rsp, 24
	mov rdi, 16
	call _jpl_alloc
	; Moving 16 bytes from rsp to rax
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 16
	push rax
	mov rax, 2
	push rax
	jmp .jump768
.jump767:
	sub rsp, 32
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	pop rsi
	lea rdi, [rsp + 0]
	call _j
	sub rsp, 8 ; Align stack
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for r
	sub rsp, 8
	; Moving 8 bytes from r12 - 40 to rsp
		mov r10, [r12 - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump769
	sub rsp, 8 ; Align stack
	lea rdi, [rel const0] ; non-positive loop bound
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump769:
	; Computing bound for q
	mov rax, [rel const166] ; 721
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump770
	lea rdi, [rel const0] ; non-positive loop bound
	call _fail_assertion
.jump770:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool
	imul rdi, [rsp + 0 + 0] ; multiply by 721
	jno .jump771
	lea rdi, [rel const1] ; overflow computing array size
	call _fail_assertion
.jump771:
	imul rdi, [rsp + 0 + 8] ; multiply by g
	jno .jump772
	lea rdi, [rel const1] ; overflow computing array size
	call _fail_assertion
.jump772:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize r to 0
	mov rax, 0
	push rax
	; Initialize q to 0
	mov rax, 0
	push rax
.jump773: ; Begin body of loop
	; Compare r to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump775 ; If r >= bound, ...
	mov qword [rsp + 8], 0 ; r = 0
	add qword [rsp + 0], 1 ; q++
.jump775:
	; Compare q to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jge .jump774 ; If q >= bound, break
.jump776:
	; Compute loop body
	mov rax, [rel const3] ; False
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment r
	add qword [rsp + 8], 1
	jmp .jump773
.jump774: ; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	call _d
	add rsp, 24
	add rsp, 8 ; Remove alignment
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 40 to rsp
		mov r10, [r12 - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump777
	sub rsp, 8 ; Align stack
	lea rdi, [rel const5] ; negative array index
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump777:
	cmp rax, [rsp + 24]
	jl .jump778
	sub rsp, 8 ; Align stack
	lea rdi, [rel const6] ; index too large
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump778:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump779
	sub rsp, 8 ; Align stack
	lea rdi, [rel const5] ; negative array index
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump779:
	cmp rax, [rsp + 32]
	jl .jump780
	sub rsp, 8 ; Align stack
	lea rdi, [rel const6] ; index too large
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump780:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump781
	sub rsp, 8 ; Align stack
	lea rdi, [rel const5] ; negative array index
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump781:
	cmp rax, [rsp + 40]
	jl .jump782
	sub rsp, 8 ; Align stack
	lea rdi, [rel const6] ; index too large
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump782:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 16
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 16
	; Moving 16 bytes from rax to rsp
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
.jump768:
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump783
	mov rax, [rel const3] ; False
	push rax
	pop rax
.jump783:
	push rax
	pop rax
	cmp rax, 0
	je .jump784
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	jmp .jump785
.jump784:
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump786
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	jmp .jump787
.jump786:
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
.jump787:
.jump785:
	pop rax
	cmp rax, 0
	je .jump788
	mov rax, [rel const7] ; True
	push rax
	jmp .jump789
.jump788:
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	pop rdi
	call _to_float
	sub rsp, 8
	movsd [rsp], xmm0
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for q
	sub rsp, 8
	; Moving 8 bytes from r12 - 40 to rsp
		mov r10, [r12 - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump790
	sub rsp, 8 ; Align stack
	lea rdi, [rel const0] ; non-positive loop bound
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump790:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize q to 0
	mov rax, 0
	push rax
.jump791: ; Begin body of loop
	; Compare q to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jge .jump792 ; If q >= bound, break
.jump793:
	; Compute loop body
	mov rax, [rel const167] ; 4.7
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp + 16] ; Load sum
	addsd xmm0, xmm1 ; Add loop body
	movsd [rsp + 16], xmm0 ; Save sum
	; Increment q
	add qword [rsp + 0], 1
	jmp .jump791
.jump792: ; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmplesd xmm1, xmm0
	movq rax, xmm1
	and rax, 1
	push rax
.jump789:
	mov rdi, 8
	sub rsp, 8 ; Align stack
	call _jpl_alloc
	add rsp, 8 ; Remove alignment
	; Moving 8 bytes from rsp to rax
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	push rax
	mov rax, 1
	push rax
	sub rsp, 16
	lea rdi, [rsp + 0]
	call _e
	mov rdi, 48
	call _jpl_alloc
	; Moving 48 bytes from rsp to rax
		mov r10, [rsp + 40]
		mov [rax + 40], r10
		mov r10, [rsp + 32]
		mov [rax + 32], r10
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 48
	push rax
	mov rax, 3
	push rax
	mov rax, [rel const168] ; 564
	push rax
	sub rsp, 8
	; Moving 8 bytes from r12 - 32 to rsp
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	setne al
	and rax, 1
	push rax
	mov rax, [rel const3] ; False
	push rax
	sub rsp, 8
	; Moving 8 bytes from r12 - -16 to rsp
		mov r10, [r12 - -16 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - -16 to rsp
		mov r10, [r12 - -16 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	pop rax
	xor rax, 1
	push rax
	; Moving 24 bytes from rsp + 8 to rsp + 16
		mov r10, [rsp + 8 + 16]
		mov [rsp + 16 + 16], r10
		mov r10, [rsp + 8 + 8]
		mov [rsp + 16 + 8], r10
		mov r10, [rsp + 8 + 0]
		mov [rsp + 16 + 0], r10
	add rsp, 16
	; Moving 8 bytes from rsp + 16 to rsp + 16
		mov r10, [rsp + 16 + 0]
		mov [rsp + 16 + 0], r10
	add rsp, 16
	pop rax
	cmp rax, 0
	je .jump794
	mov rax, [rel const169] ; 59.89
	push rax
	mov rax, [rel const170] ; 94.92
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmplesd xmm0, xmm1
	movq rax, xmm0
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump796
	sub rsp, 32
	; Moving 32 bytes from r12 - 40 to rsp
		mov r10, [r12 - 40 + 24]
		mov [rsp + 24], r10
		mov r10, [r12 - 40 + 16]
		mov [rsp + 16], r10
		mov r10, [r12 - 40 + 8]
		mov [rsp + 8], r10
		mov r10, [r12 - 40 + 0]
		mov [rsp + 0], r10
	jmp .jump797
.jump796:
	sub rsp, 32
	; Moving 32 bytes from r12 - 40 to rsp
		mov r10, [r12 - 40 + 24]
		mov [rsp + 24], r10
		mov r10, [r12 - 40 + 16]
		mov [rsp + 16], r10
		mov r10, [r12 - 40 + 8]
		mov [rsp + 8], r10
		mov r10, [r12 - 40 + 0]
		mov [rsp + 0], r10
.jump797:
	sub rsp, 32
	sub rsp, 32
	; Moving 32 bytes from rbp - -16 to rsp
		mov r10, [rbp - -16 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - -16 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -16 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	pop rsi
	lea rdi, [rsp + 32]
	call _k
	add rsp, 32
	sub rsp, 8
	; Moving 8 bytes from r12 - 40 to rsp
		mov r10, [r12 - 40 + 0]
		mov [rsp + 0], r10
	; Moving 32 bytes from rsp + 8 to rsp + 40
		mov r10, [rsp + 8 + 24]
		mov [rsp + 40 + 24], r10
		mov r10, [rsp + 8 + 16]
		mov [rsp + 40 + 16], r10
		mov r10, [rsp + 8 + 8]
		mov [rsp + 40 + 8], r10
		mov r10, [rsp + 8 + 0]
		mov [rsp + 40 + 0], r10
	add rsp, 40
	jmp .jump795
.jump794:
	mov rax, [rel const3] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump798
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	jmp .jump799
.jump798:
	mov rax, [rel const3] ; False
	push rax
.jump799:
	; Moving 8 bytes from rsp + 0 to rsp + 0
		mov r10, [rsp + 0 + 0]
		mov [rsp + 0 + 0], r10
	add rsp, 0
	pop rax
	cmp rax, 0
	je .jump800
	sub rsp, 32
	sub rsp, 16
	lea rdi, [rsp + 0]
	call _e
	mov rax, [rel const7] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump802
	mov rax, [rel const3] ; False
	push rax
	pop rax
.jump802:
	push rax
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for t
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump803
	sub rsp, 8 ; Align stack
	lea rdi, [rel const0] ; non-positive loop bound
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump803:
	; Computing bound for s
	sub rsp, 8
	; Moving 8 bytes from r12 - 40 to rsp
		mov r10, [r12 - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump804
	lea rdi, [rel const0] ; non-positive loop bound
	call _fail_assertion
.jump804:
	; Computing bound for r
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump805
	sub rsp, 8 ; Align stack
	lea rdi, [rel const0] ; non-positive loop bound
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump805:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize t to 0
	mov rax, 0
	push rax
	; Initialize s to 0
	mov rax, 0
	push rax
	; Initialize r to 0
	mov rax, 0
	push rax
.jump806: ; Begin body of loop
	; Compare t to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump808 ; If t >= bound, ...
	mov qword [rsp + 16], 0 ; t = 0
	add qword [rsp + 8], 1 ; s++
.jump808:
	; Compare s to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump809 ; If s >= bound, ...
	mov qword [rsp + 8], 0 ; s = 0
	add qword [rsp + 0], 1 ; r++
.jump809:
	; Compare r to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jge .jump807 ; If r >= bound, break
.jump810:
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 168 to rsp
		mov r10, [rbp - 168 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment t
	add qword [rsp + 16], 1
	jmp .jump806
.jump807: ; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	mov rax, [rel const3] ; False
	push rax
	pop rax
	xor rax, 1
	push rax
	pop rsi
	lea rdi, [rsp + 32]
	call _k
	add rsp, 32
	jmp .jump801
.jump800:
	mov rax, [rel const3] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump811
	sub rsp, 32
	sub rsp, 32
	; Moving 32 bytes from rbp - -16 to rsp
		mov r10, [rbp - -16 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - -16 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -16 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const3] ; False
	push rax
	pop rax
	xor rax, 1
	push rax
	pop rsi
	lea rdi, [rsp + 32]
	call _k
	add rsp, 32
	jmp .jump812
.jump811:
	sub rsp, 32
	mov rax, [rel const3] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump813
	sub rsp, 32
	; Moving 32 bytes from rbp - -16 to rsp
		mov r10, [rbp - -16 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - -16 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -16 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	jmp .jump814
.jump813:
	sub rsp, 32
	; Moving 32 bytes from rbp - -16 to rsp
		mov r10, [rbp - -16 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - -16 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -16 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
.jump814:
	sub rsp, 8
	; Moving 8 bytes from r12 - 40 to rsp
		mov r10, [r12 - 40 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 24 to rsp
		mov r10, [r12 - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	setle al
	and rax, 1
	push rax
	pop rsi
	lea rdi, [rsp + 32]
	call _k
	add rsp, 32
.jump812:
.jump801:
.jump795:
	mov rax, [rbp - 8] ; Address to write return value into
	; Moving 32 bytes from rsp to rax
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 96 ; Local variables
	pop rbp
	ret

jpl_main:
_jpl_main:
	push rbp
	mov rbp, rsp
	push r12
	mov r12, rbp
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const7] ; True
	push rax
	pop rax
	xor rax, 1
	push rax
	mov rax, [rel const13] ; 741
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	; Moving 24 bytes from rsp + 8 to rsp + 8
		mov r10, [rsp + 8 + 16]
		mov [rsp + 8 + 16], r10
		mov r10, [rsp + 8 + 8]
		mov [rsp + 8 + 8], r10
		mov r10, [rsp + 8 + 0]
		mov [rsp + 8 + 0], r10
	add rsp, 8
	; Moving 8 bytes from rsp + 8 to rsp + 16
		mov r10, [rsp + 8 + 0]
		mov [rsp + 16 + 0], r10
	add rsp, 16
	pop rax
	cmp rax, 0
	jne .jump79
	sub rsp, 8 ; Align stack
	lea rdi, [rel const14] ; b
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump79:
	lea rdi, [rel const47] ; c
	sub rsp, 8 ; Align stack
	call _print
	add rsp, 8 ; Remove alignment
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for f
	mov rax, [rel const123] ; 922
	push rax
	mov rax, [rel const61] ; 2
	push rax
	pop rax
	pop r10
	cmp r10, 0
	jne .jump608
	lea rdi, [rel const4] ; mod by zero
	call _fail_assertion
.jump608:
	cqo
	idiv r10
	mov rax, rdx
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump609
	sub rsp, 8 ; Align stack
	lea rdi, [rel const0] ; non-positive loop bound
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump609:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool
	imul rdi, [rsp + 0 + 0] ; multiply by (2 % 922)
	jno .jump610
	sub rsp, 8 ; Align stack
	lea rdi, [rel const1] ; overflow computing array size
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump610:
	sub rsp, 8 ; Align stack
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize f to 0
	mov rax, 0
	push rax
.jump611: ; Begin body of loop
	; Compare f to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jge .jump612 ; If f >= bound, break
.jump613:
	; Compute loop body
	mov rax, [rel const7] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump614
	mov rax, [rel const7] ; True
	push rax
	jmp .jump615
.jump614:
	mov rax, [rel const3] ; False
	push rax
.jump615:
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 24]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment f
	add qword [rsp + 0], 1
	jmp .jump611
.jump612: ; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	sub rsp, 8 ; Align stack
	mov rax, [rel const124] ; 60.82
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	call _to_int
	add rsp, 8 ; Remove alignment
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump616
	lea rdi, [rel const5] ; negative array index
	call _fail_assertion
.jump616:
	cmp rax, [rsp + 8]
	jl .jump617
	lea rdi, [rel const6] ; index too large
	call _fail_assertion
.jump617:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump618
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for h
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for f
	mov rax, [rel const125] ; 172
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump620
	lea rdi, [rel const0] ; non-positive loop bound
	call _fail_assertion
.jump620:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize f to 0
	mov rax, 0
	push rax
.jump621: ; Begin body of loop
	; Compare f to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jge .jump622 ; If f >= bound, break
.jump623:
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment f
	add qword [rsp + 0], 1
	jmp .jump621
.jump622: ; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump624
	sub rsp, 8 ; Align stack
	lea rdi, [rel const0] ; non-positive loop bound
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump624:
	; Computing bound for g
	mov rax, [rel const126] ; 640
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump625
	lea rdi, [rel const0] ; non-positive loop bound
	call _fail_assertion
.jump625:
	; Computing bound for f
	mov rax, [rel const127] ; 173
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump626
	sub rsp, 8 ; Align stack
	lea rdi, [rel const0] ; non-positive loop bound
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump626:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool
	imul rdi, [rsp + 0 + 0] ; multiply by 173
	jno .jump627
	sub rsp, 8 ; Align stack
	lea rdi, [rel const1] ; overflow computing array size
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump627:
	imul rdi, [rsp + 0 + 8] ; multiply by (- 640)
	jno .jump628
	sub rsp, 8 ; Align stack
	lea rdi, [rel const1] ; overflow computing array size
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump628:
imul rdi, [rsp + 0 + 16] ; multiply by (sum[f : 172] f)
	jno .jump629
	sub rsp, 8 ; Align stack
	lea rdi, [rel const1] ; overflow computing array size
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump629:
	sub rsp, 8 ; Align stack
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize h to 0
	mov rax, 0
	push rax
	; Initialize g to 0
	mov rax, 0
	push rax
	; Initialize f to 0
	mov rax, 0
	push rax
.jump630: ; Begin body of loop
	; Compare h to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump632 ; If h >= bound, ...
	mov qword [rsp + 16], 0 ; h = 0
	add qword [rsp + 8], 1 ; g++
.jump632:
	; Compare g to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump633 ; If g >= bound, ...
	mov qword [rsp + 8], 0 ; g = 0
	add qword [rsp + 0], 1 ; f++
.jump633:
	; Compare f to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jge .jump631 ; If f >= bound, break
.jump634:
	; Compute loop body
	mov rax, [rel const7] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump635
	mov rax, [rel const3] ; False
	push rax
	jmp .jump636
.jump635:
	mov rax, [rel const3] ; False
	push rax
.jump636:
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment h
	add qword [rsp + 16], 1
	jmp .jump630
.jump631: ; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	sub rsp, 8 ; Align stack
	mov rax, [rel const128] ; 49.37
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	call _to_int
	add rsp, 8 ; Remove alignment
	push rax
	sub rsp, 16
	; Moving 16 bytes from rbp - -16 to rsp
		mov r10, [rbp - -16 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump637
	sub rsp, 8 ; Align stack
	lea rdi, [rel const5] ; negative array index
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump637:
	cmp rax, [rsp + 8]
	jl .jump638
	sub rsp, 8 ; Align stack
	lea rdi, [rel const6] ; index too large
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump638:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump639
	lea rdi, [rel const5] ; negative array index
	call _fail_assertion
.jump639:
	cmp rax, [rsp + 24]
	jl .jump640
	lea rdi, [rel const6] ; index too large
	call _fail_assertion
.jump640:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump641
	lea rdi, [rel const5] ; negative array index
	call _fail_assertion
.jump641:
	cmp rax, [rsp + 32]
	jl .jump642
	lea rdi, [rel const6] ; index too large
	call _fail_assertion
.jump642:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump643
	lea rdi, [rel const5] ; negative array index
	call _fail_assertion
.jump643:
	cmp rax, [rsp + 40]
	jl .jump644
	lea rdi, [rel const6] ; index too large
	call _fail_assertion
.jump644:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 8
	; Moving 8 bytes from rax to rsp
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump645
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for f
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump647
	sub rsp, 8 ; Align stack
	lea rdi, [rel const0] ; non-positive loop bound
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump647:
	; Computing total size of heap memory to allocate
	mov rdi, 32 ; sizeof float[,,]
	imul rdi, [rsp + 0 + 0] ; multiply by (- argnum)
	jno .jump648
	sub rsp, 8 ; Align stack
	lea rdi, [rel const1] ; overflow computing array size
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump648:
	sub rsp, 8 ; Align stack
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize f to 0
	mov rax, 0
	push rax
.jump649: ; Begin body of loop
	; Compare f to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jge .jump650 ; If f >= bound, break
.jump651:
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for i
	mov rax, [rel const129] ; 128
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump652
	lea rdi, [rel const0] ; non-positive loop bound
	call _fail_assertion
.jump652:
	; Computing bound for h
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump653
	sub rsp, 8 ; Align stack
	lea rdi, [rel const0] ; non-positive loop bound
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump653:
	; Computing bound for g
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump654
	lea rdi, [rel const0] ; non-positive loop bound
	call _fail_assertion
.jump654:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof float
	imul rdi, [rsp + 0 + 0] ; multiply by argnum
	jno .jump655
	lea rdi, [rel const1] ; overflow computing array size
	call _fail_assertion
.jump655:
	imul rdi, [rsp + 0 + 8] ; multiply by f
	jno .jump656
	lea rdi, [rel const1] ; overflow computing array size
	call _fail_assertion
.jump656:
	imul rdi, [rsp + 0 + 16] ; multiply by 128
	jno .jump657
	lea rdi, [rel const1] ; overflow computing array size
	call _fail_assertion
.jump657:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize i to 0
	mov rax, 0
	push rax
	; Initialize h to 0
	mov rax, 0
	push rax
	; Initialize g to 0
	mov rax, 0
	push rax
.jump658: ; Begin body of loop
	; Compare i to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump660 ; If i >= bound, ...
	mov qword [rsp + 16], 0 ; i = 0
	add qword [rsp + 8], 1 ; h++
.jump660:
	; Compare h to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump661 ; If h >= bound, ...
	mov qword [rsp + 8], 0 ; h = 0
	add qword [rsp + 0], 1 ; g++
.jump661:
	; Compare g to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jge .jump659 ; If g >= bound, break
.jump662:
	; Compute loop body
	mov rax, [rel const130] ; 27.43
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment i
	add qword [rsp + 16], 1
	jmp .jump658
.jump659: ; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, 32
	add rax, [rsp + 48]
	; Move body (32 bytes) to index
	; Moving 32 bytes from rsp to rax
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	; Increment f
	add qword [rsp + 0], 1
	jmp .jump649
.jump650: ; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	mov rax, [rel const131] ; 830
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump663
	lea rdi, [rel const5] ; negative array index
	call _fail_assertion
.jump663:
	cmp rax, [rsp + 8]
	jl .jump664
	lea rdi, [rel const6] ; index too large
	call _fail_assertion
.jump664:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 32
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 32
	; Moving 32 bytes from rax to rsp
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	jmp .jump646
.jump645:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for h
	mov rax, [rel const132] ; 68
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump665
	sub rsp, 8 ; Align stack
	lea rdi, [rel const0] ; non-positive loop bound
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump665:
	; Computing bound for g
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump666
	lea rdi, [rel const0] ; non-positive loop bound
	call _fail_assertion
.jump666:
	; Computing bound for f
	mov rax, [rel const133] ; 395
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump667
	sub rsp, 8 ; Align stack
	lea rdi, [rel const0] ; non-positive loop bound
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump667:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof float
	imul rdi, [rsp + 0 + 0] ; multiply by 395
	jno .jump668
	sub rsp, 8 ; Align stack
	lea rdi, [rel const1] ; overflow computing array size
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump668:
	imul rdi, [rsp + 0 + 8] ; multiply by (- argnum)
	jno .jump669
	sub rsp, 8 ; Align stack
	lea rdi, [rel const1] ; overflow computing array size
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump669:
	imul rdi, [rsp + 0 + 16] ; multiply by 68
	jno .jump670
	sub rsp, 8 ; Align stack
	lea rdi, [rel const1] ; overflow computing array size
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump670:
	sub rsp, 8 ; Align stack
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize h to 0
	mov rax, 0
	push rax
	; Initialize g to 0
	mov rax, 0
	push rax
	; Initialize f to 0
	mov rax, 0
	push rax
.jump671: ; Begin body of loop
	; Compare h to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump673 ; If h >= bound, ...
	mov qword [rsp + 16], 0 ; h = 0
	add qword [rsp + 8], 1 ; g++
.jump673:
	; Compare g to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump674 ; If g >= bound, ...
	mov qword [rsp + 8], 0 ; g = 0
	add qword [rsp + 0], 1 ; f++
.jump674:
	; Compare f to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jge .jump672 ; If f >= bound, break
.jump675:
	; Compute loop body
	mov rax, [rel const134] ; 48.33
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	call _asin
	sub rsp, 8
	movsd [rsp], xmm0
	sub rsp, 8 ; Align stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	pop rdi
	call _to_float
	add rsp, 8 ; Remove alignment
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	call _pow
	sub rsp, 8
	movsd [rsp], xmm0
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment h
	add qword [rsp + 16], 1
	jmp .jump671
.jump672: ; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
.jump646:
	jmp .jump619
.jump618:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for h
	mov rax, [rel const135] ; 449
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rel const136] ; 45
	push rax
	pop rax
	pop r10
	cmp rax, r10
	setge al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump676
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for g
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump678
	lea rdi, [rel const0] ; non-positive loop bound
	call _fail_assertion
.jump678:
	; Computing bound for f
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump679
	sub rsp, 8 ; Align stack
	lea rdi, [rel const0] ; non-positive loop bound
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump679:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize g to 0
	mov rax, 0
	push rax
	; Initialize f to 0
	mov rax, 0
	push rax
.jump680: ; Begin body of loop
	; Compare g to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump682 ; If g >= bound, ...
	mov qword [rsp + 8], 0 ; g = 0
	add qword [rsp + 0], 1 ; f++
.jump682:
	; Compare f to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jge .jump681 ; If f >= bound, break
.jump683:
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment g
	add qword [rsp + 8], 1
	jmp .jump680
.jump681: ; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	jmp .jump677
.jump676:
	mov rax, [rel const137] ; 620
	push rax
.jump677:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump684
	sub rsp, 8 ; Align stack
	lea rdi, [rel const0] ; non-positive loop bound
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump684:
	; Computing bound for g
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for g
	mov rax, [rel const138] ; 310
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump685
	sub rsp, 8 ; Align stack
	lea rdi, [rel const0] ; non-positive loop bound
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump685:
	; Computing bound for f
	mov rax, [rel const139] ; 815
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump686
	lea rdi, [rel const0] ; non-positive loop bound
	call _fail_assertion
.jump686:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool
	imul rdi, [rsp + 0 + 0] ; multiply by 815
	jno .jump687
	lea rdi, [rel const1] ; overflow computing array size
	call _fail_assertion
.jump687:
	imul rdi, [rsp + 0 + 8] ; multiply by (- 310)
	jno .jump688
	lea rdi, [rel const1] ; overflow computing array size
	call _fail_assertion
.jump688:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize g to 0
	mov rax, 0
	push rax
	; Initialize f to 0
	mov rax, 0
	push rax
.jump689: ; Begin body of loop
	; Compare g to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump691 ; If g >= bound, ...
	mov qword [rsp + 8], 0 ; g = 0
	add qword [rsp + 0], 1 ; f++
.jump691:
	; Compare f to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jge .jump690 ; If f >= bound, break
.jump692:
	; Compute loop body
	mov rax, [rel const3] ; False
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 8
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment g
	add qword [rsp + 8], 1
	jmp .jump689
.jump690: ; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	call _d
	add rsp, 24
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump693
	lea rdi, [rel const0] ; non-positive loop bound
	call _fail_assertion
.jump693:
	; Computing bound for f
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump694
	sub rsp, 8 ; Align stack
	lea rdi, [rel const0] ; non-positive loop bound
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump694:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof float
	imul rdi, [rsp + 0 + 0] ; multiply by argnum
	jno .jump695
	sub rsp, 8 ; Align stack
	lea rdi, [rel const1] ; overflow computing array size
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump695:
imul rdi, [rsp + 0 + 8] ; multiply by d((array[f : 815, g : (- 310)] false))
	jno .jump696
	sub rsp, 8 ; Align stack
	lea rdi, [rel const1] ; overflow computing array size
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump696:
imul rdi, [rsp + 0 + 16] ; multiply by (if (45 >= (- 449)) then (sum[f : (- argnum), g : argnum] g) else 620)
	jno .jump697
	sub rsp, 8 ; Align stack
	lea rdi, [rel const1] ; overflow computing array size
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump697:
	sub rsp, 8 ; Align stack
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize h to 0
	mov rax, 0
	push rax
	; Initialize g to 0
	mov rax, 0
	push rax
	; Initialize f to 0
	mov rax, 0
	push rax
.jump698: ; Begin body of loop
	; Compare h to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump700 ; If h >= bound, ...
	mov qword [rsp + 16], 0 ; h = 0
	add qword [rsp + 8], 1 ; g++
.jump700:
	; Compare g to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump701 ; If g >= bound, ...
	mov qword [rsp + 8], 0 ; g = 0
	add qword [rsp + 0], 1 ; f++
.jump701:
	; Compare f to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jge .jump699 ; If f >= bound, break
.jump702:
	; Compute loop body
	mov rax, [rel const140] ; 70.78
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	call _cos
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	call _tan
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	call _tan
	sub rsp, 8
	movsd [rsp], xmm0
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 8
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment h
	add qword [rsp + 16], 1
	jmp .jump698
.jump699: ; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
.jump619:
	sub rsp, 8 ; Align stack
	call _get_time
	add rsp, 8 ; Remove alignment
	sub rsp, 8
	movsd [rsp], xmm0
	sub rsp, 8 ; Align stack
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for k
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump703
	sub rsp, 8 ; Align stack
	lea rdi, [rel const0] ; non-positive loop bound
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump703:
	; Computing bound for j
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump704
	lea rdi, [rel const0] ; non-positive loop bound
	call _fail_assertion
.jump704:
	; Computing total size of heap memory to allocate
	mov rdi, 32 ; sizeof {float,float,float,float}
	imul rdi, [rsp + 0 + 0] ; multiply by g
	jno .jump705
	lea rdi, [rel const1] ; overflow computing array size
	call _fail_assertion
.jump705:
	imul rdi, [rsp + 0 + 8] ; multiply by argnum
	jno .jump706
	lea rdi, [rel const1] ; overflow computing array size
	call _fail_assertion
.jump706:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize k to 0
	mov rax, 0
	push rax
	; Initialize j to 0
	mov rax, 0
	push rax
.jump707: ; Begin body of loop
	; Compare k to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump709 ; If k >= bound, ...
	mov qword [rsp + 8], 0 ; k = 0
	add qword [rsp + 0], 1 ; j++
.jump709:
	; Compare j to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jge .jump708 ; If j >= bound, break
.jump710:
	; Compute loop body
	mov rax, [rel const141] ; 12.11
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	call _log
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	call _log
	sub rsp, 8
	movsd [rsp], xmm0
	sub rsp, 8 ; Align stack
	mov rax, [rel const142] ; 45.73
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	call _acos
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	call _log
	add rsp, 8 ; Remove alignment
	sub rsp, 8
	movsd [rsp], xmm0
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	pop rdi
	call _to_float
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for l
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for n
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump711
	lea rdi, [rel const0] ; non-positive loop bound
	call _fail_assertion
.jump711:
	; Computing bound for m
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump712
	sub rsp, 8 ; Align stack
	lea rdi, [rel const0] ; non-positive loop bound
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump712:
	; Computing bound for l
	mov rax, [rel const143] ; 586
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump713
	lea rdi, [rel const0] ; non-positive loop bound
	call _fail_assertion
.jump713:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize n to 0
	mov rax, 0
	push rax
	; Initialize m to 0
	mov rax, 0
	push rax
	; Initialize l to 0
	mov rax, 0
	push rax
.jump714: ; Begin body of loop
	; Compare n to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump716 ; If n >= bound, ...
	mov qword [rsp + 16], 0 ; n = 0
	add qword [rsp + 8], 1 ; m++
.jump716:
	; Compare m to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump717 ; If m >= bound, ...
	mov qword [rsp + 8], 0 ; m = 0
	add qword [rsp + 0], 1 ; l++
.jump717:
	; Compare l to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jge .jump715 ; If l >= bound, break
.jump718:
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 168 to rsp
		mov r10, [rbp - 168 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment n
	add qword [rsp + 16], 1
	jmp .jump714
.jump715: ; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump719
	sub rsp, 8 ; Align stack
	lea rdi, [rel const0] ; non-positive loop bound
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump719:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize l to 0
	mov rax, 0
	push rax
.jump720: ; Begin body of loop
	; Compare l to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jge .jump721 ; If l >= bound, break
.jump722:
	; Compute loop body
	mov rax, [rel const144] ; 9.31
	push rax
	mov rax, [rel const145] ; 62.21
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	call _fmod
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp + 16] ; Load sum
	addsd xmm0, xmm1 ; Add loop body
	movsd [rsp + 16], xmm0 ; Save sum
	; Increment l
	add qword [rsp + 0], 1
	jmp .jump720
.jump721: ; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, 32
	add rax, [rsp + 64]
	; Move body (32 bytes) to index
	; Moving 32 bytes from rsp to rax
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	; Increment k
	add qword [rsp + 8], 1
	jmp .jump707
.jump708: ; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	lea rdi, [rel const146] ; j.png
	call _write_image
	add rsp, 24
	add rsp, 8 ; Remove alignment
	call _get_time
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp + 0]
	subsd xmm0, xmm1
	call _print_time
	sub rsp, 8 ; Align stack
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for l
	mov rax, [rel const159] ; 38
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump749
	sub rsp, 8 ; Align stack
	lea rdi, [rel const0] ; non-positive loop bound
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump749:
	; Computing bound for k
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump750
	lea rdi, [rel const0] ; non-positive loop bound
	call _fail_assertion
.jump750:
	; Computing total size of heap memory to allocate
	mov rdi, 32 ; sizeof {float,float,float,float}
	imul rdi, [rsp + 0 + 0] ; multiply by h
	jno .jump751
	lea rdi, [rel const1] ; overflow computing array size
	call _fail_assertion
.jump751:
	imul rdi, [rsp + 0 + 8] ; multiply by 38
	jno .jump752
	lea rdi, [rel const1] ; overflow computing array size
	call _fail_assertion
.jump752:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize l to 0
	mov rax, 0
	push rax
	; Initialize k to 0
	mov rax, 0
	push rax
.jump753: ; Begin body of loop
	; Compare l to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump755 ; If l >= bound, ...
	mov qword [rsp + 8], 0 ; l = 0
	add qword [rsp + 0], 1 ; k++
.jump755:
	; Compare k to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jge .jump754 ; If k >= bound, break
.jump756:
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 88 to rsp
		mov r10, [rbp - 88 + 0]
		mov [rsp + 0], r10
	pop rdi
	call _to_float
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	call _log
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	sub rsp, 8 ; Align stack
	sub rsp, 24
	sub rsp, 8 ; Align stack
	lea rdi, [rsp + 8]
	call _b
	add rsp, 8 ; Remove alignment
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump757
	sub rsp, 8 ; Align stack
	lea rdi, [rel const5] ; negative array index
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump757:
	cmp rax, [rsp + 16]
	jl .jump758
	sub rsp, 8 ; Align stack
	lea rdi, [rel const6] ; index too large
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump758:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump759
	sub rsp, 8 ; Align stack
	lea rdi, [rel const5] ; negative array index
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump759:
	cmp rax, [rsp + 24]
	jl .jump760
	sub rsp, 8 ; Align stack
	lea rdi, [rel const6] ; index too large
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump760:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 8
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 8
	; Moving 8 bytes from rax to rsp
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	movsd xmm0, [rsp]
	add rsp, 8
	call _sin
	sub rsp, 8
	movsd [rsp], xmm0
	sub rsp, 16
	sub rsp, 8 ; Align stack
	lea rdi, [rsp + 8]
	call _e
	add rsp, 8 ; Remove alignment
	sub rsp, 8
	; Moving 8 bytes from rbp - 88 to rsp
		mov r10, [rbp - 88 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump761
	lea rdi, [rel const5] ; negative array index
	call _fail_assertion
.jump761:
	cmp rax, [rsp + 8]
	jl .jump762
	lea rdi, [rel const6] ; index too large
	call _fail_assertion
.jump762:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 8
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump763
	sub rsp, 8 ; Align stack
	mov rax, [rel const160] ; 25.25
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	call _cos
	add rsp, 8 ; Remove alignment
	sub rsp, 8
	movsd [rsp], xmm0
	jmp .jump764
.jump763:
	mov rax, [rel const161] ; 85.7
	push rax
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
.jump764:
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	call _pow
	add rsp, 8 ; Remove alignment
	sub rsp, 8
	movsd [rsp], xmm0
	mov rax, [rel const162] ; 43.65
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	call _sin
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	call _exp
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	sub rsp, 8 ; Align stack
	mov rax, [rel const163] ; 60.59
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	call _sqrt
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	call _sqrt
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	call _exp
	add rsp, 8 ; Remove alignment
	sub rsp, 8
	movsd [rsp], xmm0
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, 32
	add rax, [rsp + 64]
	; Move body (32 bytes) to index
	; Moving 32 bytes from rsp to rax
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	; Increment l
	add qword [rsp + 8], 1
	jmp .jump753
.jump754: ; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	lea rdi, [rel const164] ; k.png
	call _write_image
	add rsp, 24
	add rsp, 8 ; Remove alignment
	add rsp, 40 ; Local variables
	pop r12
	pop rbp
	ret

