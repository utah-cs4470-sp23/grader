global jpl_main
global _jpl_main
extern _fail_assertion
extern _jpl_alloc
extern _get_time
extern _show
extern _print
extern _print_time
extern _read_image
extern _write_image
extern _fmod
extern _sqrt
extern _exp
extern _sin
extern _cos
extern _tan
extern _asin
extern _acos
extern _atan
extern _log
extern _pow
extern _atan2
extern _to_int
extern _to_float

section .data
const0: dq 87.66
const1: db `non-positive loop bound`, 0
const2: dq 852
const3: db `overflow computing array size`, 0
const4: dq 668
const5: dq 207
const6: dq 1
const7: db `mod by zero`, 0
const8: dq 148
const9: db `negative array index`, 0
const10: db `index too large`, 0
const11: dq 604
const12: dq 0
const13: dq 56.85
const14: dq 920
const15: dq 612
const16: dq 117
const17: dq 91.88
const18: dq 445
const19: dq 863
const20: dq 740
const21: dq 39.57
const22: dq 964
const23: dq 70.66
const24: dq 763
const25: db `divide by zero`, 0
const26: dq 42.06
const27: dq 89.95
const28: dq 3.21
const29: dq 24.16
const30: db `c`, 0
const31: db `(FloatType)`, 0
const32: dq 898
const33: dq 10.55
const34: dq 61.37
const35: dq 789
const36: dq 944
const37: dq 741
const38: dq 804
const39: dq 80.06
const40: dq 68.92
const41: dq 519
const42: dq 3.41
const43: dq 9.53
const44: dq 19.37
const45: db `c.png`, 0
const46: dq 8.83
const47: dq 782
const48: dq 941
const49: dq 334
const50: dq 659
const51: dq 736
const52: dq 31
const53: dq 10
const54: dq 890
const55: dq 122
const56: dq 496
const57: dq 943
const58: dq 99
const59: dq 272
const60: dq 608
const61: dq 337
const62: dq 73
const63: dq 38.38
const64: dq 41.41
const65: dq 802
const66: dq 681
const67: dq 28.7
const68: dq 138
const69: dq 79
const70: dq 120
const71: dq 847
const72: dq 639
const73: dq 74.95
const74: dq 107
const75: dq 226
const76: dq 48.35
const77: db `q`, 0
const78: dq 72.0
const79: dq 897
const80: dq 26.78
const81: dq 74.84
const82: dq 330
const83: dq 746
const84: dq 30.89
const85: dq 24.6
const86: dq 78.38
const87: dq 814
const88: dq 22
const89: dq 564
const90: dq 398
const91: dq 854
const92: dq 483
const93: dq 124
const94: dq 39
const95: dq 52
const96: db `i`, 0
const97: dq 587
const98: dq 64.16
const99: dq 700
const100: dq 363
const101: db `l`, 0
const102: dq 606
const103: dq 23
const104: dq 723
const105: dq 60
const106: dq 414
const107: dq 655
const108: dq 498
const109: dq 364
const110: dq 24
const111: dq 2.02
const112: dq 925

section .text
a:
_a:
	push rbp
	mov rbp, rsp
	push rdi
	sub rsp, 16
	; Moving 16 bytes from r12 - -16 to rsp
		mov r10, [r12 - -16 + 8]
		mov [rsp + 8], r10
		mov r10, [r12 - -16 + 0]
		mov [rsp + 0], r10
	sub rsp, 8 ; Align stack
	sub rsp, 8
	; Moving 8 bytes from r12 - -16 to rsp
		mov r10, [r12 - -16 + 0]
		mov [rsp + 0], r10
	pop rdi
	call _to_float
	add rsp, 8 ; Remove alignment
	sub rsp, 8
	movsd [rsp], xmm0
	mov rax, [rel const0] ; 87.66
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmpeqsd xmm0, xmm1
	movq rax, xmm0
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump1
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for e
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump3
	sub rsp, 8 ; Align stack
	lea rdi, [rel const1] ; non-positive loop bound
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump3:
	; Computing bound for d
	mov rax, [rel const2] ; 852
	push rax
	mov rax, [rsp]
	; Computing total size of heap memory to allocate
	mov rdi, 16 ; sizeof int[]
	imul rdi, [rsp + 0 + 0] ; multiply by 852
	jno .jump4
	lea rdi, [rel const3] ; overflow computing array size
	call _fail_assertion
.jump4:
	imul rdi, [rsp + 0 + 8] ; multiply by c
	jno .jump5
	lea rdi, [rel const3] ; overflow computing array size
	call _fail_assertion
.jump5:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize e to 0
	mov rax, 0
	push rax
	; Initialize d to 0
	mov rax, 0
	push rax
.jump6: ; Begin body of loop
	; Compare e to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump8 ; If e >= bound, ...
	mov qword [rsp + 8], 0 ; e = 0
	add qword [rsp + 0], 1 ; d++
.jump8:
	; Compare d to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jge .jump7 ; If d >= bound, break
.jump9:
	; Compute loop body
	sub rsp, 16
	; Moving 16 bytes from r12 - -16 to rsp
		mov r10, [r12 - -16 + 8]
		mov [rsp + 8], r10
		mov r10, [r12 - -16 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	shl rax, 4
	add rax, [rsp + 48]
	; Move body (16 bytes) to index
	; Moving 16 bytes from rsp to rax
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 16
	; Increment e
	add qword [rsp + 8], 1
	jmp .jump6
.jump7: ; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	jmp .jump2
.jump1:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for e
	mov rax, [rel const4] ; 668
	push rax
	mov rax, [rsp]
	; Computing bound for d
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump10
	lea rdi, [rel const1] ; non-positive loop bound
	call _fail_assertion
.jump10:
	; Computing total size of heap memory to allocate
	mov rdi, 16 ; sizeof int[]
	imul rdi, [rsp + 0 + 0] ; multiply by c
	jno .jump11
	lea rdi, [rel const3] ; overflow computing array size
	call _fail_assertion
.jump11:
	imul rdi, [rsp + 0 + 8] ; multiply by 668
	jno .jump12
	lea rdi, [rel const3] ; overflow computing array size
	call _fail_assertion
.jump12:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize e to 0
	mov rax, 0
	push rax
	; Initialize d to 0
	mov rax, 0
	push rax
.jump13: ; Begin body of loop
	; Compare e to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump15 ; If e >= bound, ...
	mov qword [rsp + 8], 0 ; e = 0
	add qword [rsp + 0], 1 ; d++
.jump15:
	; Compare d to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jge .jump14 ; If d >= bound, break
.jump16:
	; Compute loop body
	sub rsp, 16
	; Moving 16 bytes from r12 - -16 to rsp
		mov r10, [r12 - -16 + 8]
		mov [rsp + 8], r10
		mov r10, [r12 - -16 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	shl rax, 4
	add rax, [rsp + 48]
	; Move body (16 bytes) to index
	; Moving 16 bytes from rsp to rax
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 16
	; Increment e
	add qword [rsp + 8], 1
	jmp .jump13
.jump14: ; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
.jump2:
	; Moving 24 bytes from rsp + 0 to rsp + 0
		mov r10, [rsp + 0 + 16]
		mov [rsp + 0 + 16], r10
		mov r10, [rsp + 0 + 8]
		mov [rsp + 0 + 8], r10
		mov r10, [rsp + 0 + 0]
		mov [rsp + 0 + 0], r10
	add rsp, 0
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for f
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump17
	lea rdi, [rel const1] ; non-positive loop bound
	call _fail_assertion
.jump17:
	; Computing bound for e
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump18
	sub rsp, 8 ; Align stack
	lea rdi, [rel const1] ; non-positive loop bound
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump18:
	; Computing bound for d
	mov rax, [rel const5] ; 207
	push rax
	mov rax, [rsp]
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int
	imul rdi, [rsp + 0 + 0] ; multiply by 207
	jno .jump19
	lea rdi, [rel const3] ; overflow computing array size
	call _fail_assertion
.jump19:
	imul rdi, [rsp + 0 + 8] ; multiply by c
	jno .jump20
	lea rdi, [rel const3] ; overflow computing array size
	call _fail_assertion
.jump20:
	imul rdi, [rsp + 0 + 16] ; multiply by c
	jno .jump21
	lea rdi, [rel const3] ; overflow computing array size
	call _fail_assertion
.jump21:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize f to 0
	mov rax, 0
	push rax
	; Initialize e to 0
	mov rax, 0
	push rax
	; Initialize d to 0
	mov rax, 0
	push rax
.jump22: ; Begin body of loop
	; Compare f to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump24 ; If f >= bound, ...
	mov qword [rsp + 16], 0 ; f = 0
	add qword [rsp + 8], 1 ; e++
.jump24:
	; Compare e to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump25 ; If e >= bound, ...
	mov qword [rsp + 8], 0 ; e = 0
	add qword [rsp + 0], 1 ; d++
.jump25:
	; Compare d to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jge .jump23 ; If d >= bound, break
.jump26:
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - -16 to rsp
		mov r10, [r12 - -16 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	shl rax, 3
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment f
	add qword [rsp + 16], 1
	jmp .jump22
.jump23: ; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	; Moving 32 bytes from rsp + 0 to rsp + 0
		mov r10, [rsp + 0 + 24]
		mov [rsp + 0 + 24], r10
		mov r10, [rsp + 0 + 16]
		mov [rsp + 0 + 16], r10
		mov r10, [rsp + 0 + 8]
		mov [rsp + 0 + 8], r10
		mov r10, [rsp + 0 + 0]
		mov [rsp + 0 + 0], r10
	add rsp, 0
	mov rax, [rel const6] ; True
	push rax
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump27
	sub rsp, 8
	; Moving 8 bytes from r12 - -16 to rsp
		mov r10, [r12 - -16 + 0]
		mov [rsp + 0], r10
	jmp .jump28
.jump27:
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	sub rsp, 8
	; Moving 8 bytes from r12 - -16 to rsp
		mov r10, [r12 - -16 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	pop rax
	pop r10
	cmp r10, 0
	jne .jump29
	lea rdi, [rel const7] ; mod by zero
	call _fail_assertion
.jump29:
	cqo
	idiv r10
	mov rax, rdx
	push rax
.jump28:
	sub rsp, 8
	; Moving 8 bytes from r12 - -16 to rsp
		mov r10, [r12 - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const8] ; 148
	push rax
	; Moving 8 bytes from rsp + 0 to rsp + 0
		mov r10, [rsp + 0 + 0]
		mov [rsp + 0 + 0], r10
	add rsp, 0
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump30
	sub rsp, 8 ; Align stack
	lea rdi, [rel const9] ; negative array index
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump30:
	cmp rax, [rsp + 24]
	jl .jump31
	sub rsp, 8 ; Align stack
	lea rdi, [rel const10] ; index too large
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump31:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump32
	sub rsp, 8 ; Align stack
	lea rdi, [rel const9] ; negative array index
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump32:
	cmp rax, [rsp + 32]
	jl .jump33
	sub rsp, 8 ; Align stack
	lea rdi, [rel const10] ; index too large
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump33:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump34
	sub rsp, 8 ; Align stack
	lea rdi, [rel const9] ; negative array index
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump34:
	cmp rax, [rsp + 40]
	jl .jump35
	sub rsp, 8 ; Align stack
	lea rdi, [rel const10] ; index too large
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump35:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	shl rax, 3
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 8
	; Moving 8 bytes from rax to rsp
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rel const11] ; 604
	push rax
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for d
	sub rsp, 8 ; Align stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	pop rdi
	call _to_float
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	call _to_int
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump36
	lea rdi, [rel const1] ; non-positive loop bound
	call _fail_assertion
.jump36:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize d to 0
	mov rax, 0
	push rax
.jump37: ; Begin body of loop
	; Compare d to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jge .jump38 ; If d >= bound, break
.jump39:
	; Compute loop body
	mov rax, [rel const12] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump40
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	jmp .jump41
.jump40:
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
.jump41:
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment d
	add qword [rsp + 0], 1
	jmp .jump37
.jump38: ; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	pop rax
	pop r10
	sub rax, r10
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump42
	lea rdi, [rel const9] ; negative array index
	call _fail_assertion
.jump42:
	cmp rax, [rsp + 16]
	jl .jump43
	lea rdi, [rel const10] ; index too large
	call _fail_assertion
.jump43:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump44
	lea rdi, [rel const9] ; negative array index
	call _fail_assertion
.jump44:
	cmp rax, [rsp + 24]
	jl .jump45
	lea rdi, [rel const10] ; index too large
	call _fail_assertion
.jump45:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	shl rax, 4
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 16
	; Moving 16 bytes from rax to rsp
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	sub rsp, 8 ; Align stack
	mov rax, [rel const13] ; 56.85
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	call _log
	add rsp, 8 ; Remove alignment
	sub rsp, 8
	movsd [rsp], xmm0
	mov rax, [rel const12] ; False
	push rax
	pop rax
	cmp rax, 0
	jne .jump46
	mov rax, [rel const12] ; False
	push rax
	pop rax
.jump46:
	push rax
	; Moving 8 bytes from rsp + 0 to rsp + 8
		mov r10, [rsp + 0 + 0]
		mov [rsp + 8 + 0], r10
	add rsp, 8
	pop rax
	cmp rax, 0
	je .jump47
	mov rax, [rel const14] ; 920
	push rax
	mov rax, [rel const15] ; 612
	push rax
	pop rax
	pop r10
	cmp rax, r10
	setl al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump49
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for g
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump51
	sub rsp, 8 ; Align stack
	lea rdi, [rel const1] ; non-positive loop bound
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump51:
	; Computing bound for f
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump52
	lea rdi, [rel const1] ; non-positive loop bound
	call _fail_assertion
.jump52:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int
	imul rdi, [rsp + 0 + 0] ; multiply by c
	jno .jump53
	lea rdi, [rel const3] ; overflow computing array size
	call _fail_assertion
.jump53:
	imul rdi, [rsp + 0 + 8] ; multiply by c
	jno .jump54
	lea rdi, [rel const3] ; overflow computing array size
	call _fail_assertion
.jump54:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize g to 0
	mov rax, 0
	push rax
	; Initialize f to 0
	mov rax, 0
	push rax
.jump55: ; Begin body of loop
	; Compare g to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump57 ; If g >= bound, ...
	mov qword [rsp + 8], 0 ; g = 0
	add qword [rsp + 0], 1 ; f++
.jump57:
	; Compare f to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jge .jump56 ; If f >= bound, break
.jump58:
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	shl rax, 3
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment g
	add qword [rsp + 8], 1
	jmp .jump55
.jump56: ; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	jmp .jump50
.jump49:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for g
	sub rsp, 8
	; Moving 8 bytes from r12 - -16 to rsp
		mov r10, [r12 - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump59
	sub rsp, 8 ; Align stack
	lea rdi, [rel const1] ; non-positive loop bound
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump59:
	; Computing bound for f
	sub rsp, 8
	; Moving 8 bytes from r12 - -16 to rsp
		mov r10, [r12 - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump60
	lea rdi, [rel const1] ; non-positive loop bound
	call _fail_assertion
.jump60:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int
	imul rdi, [rsp + 0 + 0] ; multiply by argnum
	jno .jump61
	lea rdi, [rel const3] ; overflow computing array size
	call _fail_assertion
.jump61:
	imul rdi, [rsp + 0 + 8] ; multiply by argnum
	jno .jump62
	lea rdi, [rel const3] ; overflow computing array size
	call _fail_assertion
.jump62:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize g to 0
	mov rax, 0
	push rax
	; Initialize f to 0
	mov rax, 0
	push rax
.jump63: ; Begin body of loop
	; Compare g to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump65 ; If g >= bound, ...
	mov qword [rsp + 8], 0 ; g = 0
	add qword [rsp + 0], 1 ; f++
.jump65:
	; Compare f to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jge .jump64 ; If f >= bound, break
.jump66:
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	shl rax, 3
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment g
	add qword [rsp + 8], 1
	jmp .jump63
.jump64: ; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
.jump50:
	mov rax, [rel const6] ; True
	push rax
	sub rsp, 8 ; Align stack
	mov rax, [rel const16] ; 117
	push rax
	pop rdi
	call _to_float
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	call _acos
	add rsp, 8 ; Remove alignment
	sub rsp, 8
	movsd [rsp], xmm0
	jmp .jump48
.jump47:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for g
	mov rax, [rel const17] ; 91.88
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	call _to_int
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump67
	sub rsp, 8 ; Align stack
	lea rdi, [rel const1] ; non-positive loop bound
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump67:
	; Computing bound for f
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump68
	lea rdi, [rel const1] ; non-positive loop bound
	call _fail_assertion
.jump68:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int
	imul rdi, [rsp + 0 + 0] ; multiply by (- e)
	jno .jump69
	lea rdi, [rel const3] ; overflow computing array size
	call _fail_assertion
.jump69:
	imul rdi, [rsp + 0 + 8] ; multiply by to_int(91.88)
	jno .jump70
	lea rdi, [rel const3] ; overflow computing array size
	call _fail_assertion
.jump70:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize g to 0
	mov rax, 0
	push rax
	; Initialize f to 0
	mov rax, 0
	push rax
.jump71: ; Begin body of loop
	; Compare g to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump73 ; If g >= bound, ...
	mov qword [rsp + 8], 0 ; g = 0
	add qword [rsp + 0], 1 ; f++
.jump73:
	; Compare f to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jge .jump72 ; If f >= bound, break
.jump74:
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	shl rax, 3
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment g
	add qword [rsp + 8], 1
	jmp .jump71
.jump72: ; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	mov rax, [rel const18] ; 445
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rel const19] ; 863
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp r10, 0
	jne .jump75
	sub rsp, 8 ; Align stack
	lea rdi, [rel const7] ; mod by zero
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump75:
	cqo
	idiv r10
	mov rax, rdx
	push rax
	pop rax
	pop r10
	cmp rax, r10
	setne al
	and rax, 1
	push rax
	sub rsp, 8 ; Align stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	pop rdi
	call _to_float
	sub rsp, 8
	movsd [rsp], xmm0
	sub rsp, 8 ; Align stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	pop rdi
	call _to_float
	add rsp, 8 ; Remove alignment
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	call _atan2
	add rsp, 8 ; Remove alignment
	sub rsp, 8
	movsd [rsp], xmm0
.jump48:
	; Moving 24 bytes from rsp + 16 to rsp + 16
		mov r10, [rsp + 16 + 16]
		mov [rsp + 16 + 16], r10
		mov r10, [rsp + 16 + 8]
		mov [rsp + 16 + 8], r10
		mov r10, [rsp + 16 + 0]
		mov [rsp + 16 + 0], r10
	add rsp, 16
	mov rax, [rel const6] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump76
	sub rsp, 24
	sub rsp, 8 ; Align stack
	lea rdi, [rsp + 8]
	call _a
	add rsp, 8 ; Remove alignment
	mov rdi, 24
	sub rsp, 8 ; Align stack
	call _jpl_alloc
	add rsp, 8 ; Remove alignment
	; Moving 24 bytes from rsp to rax
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 24
	push rax
	mov rax, 1
	push rax
	sub rsp, 24
	sub rsp, 8 ; Align stack
	lea rdi, [rsp + 8]
	call _a
	add rsp, 8 ; Remove alignment
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - -16 to rsp
		mov r10, [r12 - -16 + 0]
		mov [rsp + 0], r10
	jmp .jump77
.jump76:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for i
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump78
	lea rdi, [rel const1] ; non-positive loop bound
	call _fail_assertion
.jump78:
	; Computing total size of heap memory to allocate
	mov rdi, 24 ; sizeof {bool,int,bool}
	imul rdi, [rsp + 0 + 0] ; multiply by c
	jno .jump79
	lea rdi, [rel const3] ; overflow computing array size
	call _fail_assertion
.jump79:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize i to 0
	mov rax, 0
	push rax
.jump80: ; Begin body of loop
	; Compare i to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jge .jump81 ; If i >= bound, break
.jump82:
	; Compute loop body
	sub rsp, 24
	lea rdi, [rsp + 0]
	call _a
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, 24
	add rax, [rsp + 40]
	; Move body (24 bytes) to index
	; Moving 24 bytes from rsp to rax
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 24
	; Increment i
	add qword [rsp + 0], 1
	jmp .jump80
.jump81: ; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	sub rsp, 24
	sub rsp, 8 ; Align stack
	lea rdi, [rsp + 8]
	call _a
	add rsp, 8 ; Remove alignment
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
.jump77:
	; Moving 16 bytes from rsp + 40 to rsp + 40
		mov r10, [rsp + 40 + 8]
		mov [rsp + 40 + 8], r10
		mov r10, [rsp + 40 + 0]
		mov [rsp + 40 + 0], r10
	add rsp, 40
	sub rsp, 16
	; Moving 16 bytes from rbp - 24 to rsp
		mov r10, [rbp - 24 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	sub rsp, 24
	sub rsp, 8 ; Align stack
	lea rdi, [rsp + 8]
	call _a
	add rsp, 8 ; Remove alignment
	; Moving 8 bytes from rsp + 16 to rsp + 16
		mov r10, [rsp + 16 + 0]
		mov [rsp + 16 + 0], r10
	add rsp, 16
	pop rax
	cmp rax, 0
	jne .jump83
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 64 to rsp
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	sete al
	and rax, 1
	push rax
	pop rax
.jump83:
	push rax
	pop rax
	cmp rax, 0
	je .jump84
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	jmp .jump85
.jump84:
	sub rsp, 8
	; Moving 8 bytes from rbp - 64 to rsp
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
.jump85:
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump86
	sub rsp, 8 ; Align stack
	lea rdi, [rel const9] ; negative array index
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump86:
	cmp rax, [rsp + 8]
	jl .jump87
	sub rsp, 8 ; Align stack
	lea rdi, [rel const10] ; index too large
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump87:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	shl rax, 3
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump88
	sub rsp, 8 ; Align stack
	lea rdi, [rel const9] ; negative array index
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump88:
	cmp rax, [rsp + 8]
	jl .jump89
	sub rsp, 8 ; Align stack
	lea rdi, [rel const10] ; index too large
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump89:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, 24
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 24
	; Moving 24 bytes from rax to rsp
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rbp - 8] ; Address to write return value into
	; Moving 24 bytes from rsp to rax
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 88 ; Local variables
	pop rbp
	ret
	mov rax, [rel const6] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump90
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	setl al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump92
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for k
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump94
	sub rsp, 8 ; Align stack
	lea rdi, [rel const1] ; non-positive loop bound
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump94:
	; Computing bound for j
	sub rsp, 8
	; Moving 8 bytes from r12 - -16 to rsp
		mov r10, [r12 - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump95
	lea rdi, [rel const1] ; non-positive loop bound
	call _fail_assertion
.jump95:
	; Computing bound for i
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump96
	sub rsp, 8 ; Align stack
	lea rdi, [rel const1] ; non-positive loop bound
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump96:
	; Computing total size of heap memory to allocate
	mov rdi, 24 ; sizeof {bool,int,bool}
	imul rdi, [rsp + 0 + 0] ; multiply by h
	jno .jump97
	sub rsp, 8 ; Align stack
	lea rdi, [rel const3] ; overflow computing array size
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump97:
	imul rdi, [rsp + 0 + 8] ; multiply by argnum
	jno .jump98
	sub rsp, 8 ; Align stack
	lea rdi, [rel const3] ; overflow computing array size
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump98:
	imul rdi, [rsp + 0 + 16] ; multiply by e
	jno .jump99
	sub rsp, 8 ; Align stack
	lea rdi, [rel const3] ; overflow computing array size
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump99:
	sub rsp, 8 ; Align stack
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize k to 0
	mov rax, 0
	push rax
	; Initialize j to 0
	mov rax, 0
	push rax
	; Initialize i to 0
	mov rax, 0
	push rax
.jump100: ; Begin body of loop
	; Compare k to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump102 ; If k >= bound, ...
	mov qword [rsp + 16], 0 ; k = 0
	add qword [rsp + 8], 1 ; j++
.jump102:
	; Compare j to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump103 ; If j >= bound, ...
	mov qword [rsp + 8], 0 ; j = 0
	add qword [rsp + 0], 1 ; i++
.jump103:
	; Compare i to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jge .jump101 ; If i >= bound, break
.jump104:
	; Compute loop body
	sub rsp, 24
	sub rsp, 8 ; Align stack
	lea rdi, [rsp + 8]
	call _a
	add rsp, 8 ; Remove alignment
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, 24
	add rax, [rsp + 72]
	; Move body (24 bytes) to index
	; Moving 24 bytes from rsp to rax
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 24
	; Increment k
	add qword [rsp + 16], 1
	jmp .jump100
.jump101: ; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	jmp .jump93
.jump92:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for k
	sub rsp, 8
	; Moving 8 bytes from r12 - -16 to rsp
		mov r10, [r12 - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump105
	sub rsp, 8 ; Align stack
	lea rdi, [rel const1] ; non-positive loop bound
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump105:
	; Computing bound for j
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump106
	lea rdi, [rel const1] ; non-positive loop bound
	call _fail_assertion
.jump106:
	; Computing bound for i
	mov rax, [rel const20] ; 740
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 64 to rsp
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	add rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump107
	sub rsp, 8 ; Align stack
	lea rdi, [rel const1] ; non-positive loop bound
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump107:
	; Computing total size of heap memory to allocate
	mov rdi, 24 ; sizeof {bool,int,bool}
	imul rdi, [rsp + 0 + 0] ; multiply by (g + 740)
	jno .jump108
	sub rsp, 8 ; Align stack
	lea rdi, [rel const3] ; overflow computing array size
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump108:
	imul rdi, [rsp + 0 + 8] ; multiply by c
	jno .jump109
	sub rsp, 8 ; Align stack
	lea rdi, [rel const3] ; overflow computing array size
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump109:
	imul rdi, [rsp + 0 + 16] ; multiply by argnum
	jno .jump110
	sub rsp, 8 ; Align stack
	lea rdi, [rel const3] ; overflow computing array size
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump110:
	sub rsp, 8 ; Align stack
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize k to 0
	mov rax, 0
	push rax
	; Initialize j to 0
	mov rax, 0
	push rax
	; Initialize i to 0
	mov rax, 0
	push rax
.jump111: ; Begin body of loop
	; Compare k to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump113 ; If k >= bound, ...
	mov qword [rsp + 16], 0 ; k = 0
	add qword [rsp + 8], 1 ; j++
.jump113:
	; Compare j to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump114 ; If j >= bound, ...
	mov qword [rsp + 8], 0 ; j = 0
	add qword [rsp + 0], 1 ; i++
.jump114:
	; Compare i to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jge .jump112 ; If i >= bound, break
.jump115:
	; Compute loop body
	sub rsp, 24
	sub rsp, 8 ; Align stack
	lea rdi, [rsp + 8]
	call _a
	add rsp, 8 ; Remove alignment
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, 24
	add rax, [rsp + 72]
	; Move body (24 bytes) to index
	; Moving 24 bytes from rsp to rax
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 24
	; Increment k
	add qword [rsp + 16], 1
	jmp .jump111
.jump112: ; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
.jump93:
	jmp .jump91
.jump90:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for k
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump116
	sub rsp, 8 ; Align stack
	lea rdi, [rel const1] ; non-positive loop bound
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump116:
	; Computing bound for j
	sub rsp, 8
	; Moving 8 bytes from r12 - -16 to rsp
		mov r10, [r12 - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const21] ; 39.57
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	call _to_int
	push rax
	pop rax
	pop r10
	sub rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump117
	lea rdi, [rel const1] ; non-positive loop bound
	call _fail_assertion
.jump117:
	; Computing bound for i
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump118
	sub rsp, 8 ; Align stack
	lea rdi, [rel const1] ; non-positive loop bound
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump118:
	; Computing total size of heap memory to allocate
	mov rdi, 24 ; sizeof {bool,int,bool}
	imul rdi, [rsp + 0 + 0] ; multiply by e
	jno .jump119
	sub rsp, 8 ; Align stack
	lea rdi, [rel const3] ; overflow computing array size
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump119:
	imul rdi, [rsp + 0 + 8] ; multiply by (to_int(39.57) - argnum)
	jno .jump120
	sub rsp, 8 ; Align stack
	lea rdi, [rel const3] ; overflow computing array size
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump120:
	imul rdi, [rsp + 0 + 16] ; multiply by e
	jno .jump121
	sub rsp, 8 ; Align stack
	lea rdi, [rel const3] ; overflow computing array size
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump121:
	sub rsp, 8 ; Align stack
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize k to 0
	mov rax, 0
	push rax
	; Initialize j to 0
	mov rax, 0
	push rax
	; Initialize i to 0
	mov rax, 0
	push rax
.jump122: ; Begin body of loop
	; Compare k to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump124 ; If k >= bound, ...
	mov qword [rsp + 16], 0 ; k = 0
	add qword [rsp + 8], 1 ; j++
.jump124:
	; Compare j to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump125 ; If j >= bound, ...
	mov qword [rsp + 8], 0 ; j = 0
	add qword [rsp + 0], 1 ; i++
.jump125:
	; Compare i to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jge .jump123 ; If i >= bound, break
.jump126:
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 64 to rsp
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 136 to rsp
		mov r10, [rbp - 136 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	setl al
	and rax, 1
	push rax
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for m
	sub rsp, 8
	; Moving 8 bytes from rbp - 136 to rsp
		mov r10, [rbp - 136 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump127
	sub rsp, 8 ; Align stack
	lea rdi, [rel const1] ; non-positive loop bound
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump127:
	; Computing bound for l
	sub rsp, 8
	; Moving 8 bytes from rbp - 136 to rsp
		mov r10, [rbp - 136 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump128
	lea rdi, [rel const1] ; non-positive loop bound
	call _fail_assertion
.jump128:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize m to 0
	mov rax, 0
	push rax
	; Initialize l to 0
	mov rax, 0
	push rax
.jump129: ; Begin body of loop
	; Compare m to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump131 ; If m >= bound, ...
	mov qword [rsp + 8], 0 ; m = 0
	add qword [rsp + 0], 1 ; l++
.jump131:
	; Compare l to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jge .jump130 ; If l >= bound, break
.jump132:
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment m
	add qword [rsp + 8], 1
	jmp .jump129
.jump130: ; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const22] ; 964
	push rax
	pop rax
	pop r10
	cmp rax, r10
	setg al
	and rax, 1
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, 24
	add rax, [rsp + 72]
	; Move body (24 bytes) to index
	; Moving 24 bytes from rsp to rax
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 24
	; Increment k
	add qword [rsp + 16], 1
	jmp .jump122
.jump123: ; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
.jump91:
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for k
	sub rsp, 8
	; Moving 8 bytes from r12 - -16 to rsp
		mov r10, [r12 - -16 + 0]
		mov [rsp + 0], r10
	sub rsp, 8 ; Align stack
	mov rax, [rel const23] ; 70.66
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	call _sqrt
	add rsp, 8 ; Remove alignment
	sub rsp, 8
	movsd [rsp], xmm0
	sub rsp, 8
	; Moving 8 bytes from r12 - -16 to rsp
		mov r10, [r12 - -16 + 0]
		mov [rsp + 0], r10
	; Moving 8 bytes from rsp + 0 to rsp + 16
		mov r10, [rsp + 0 + 0]
		mov [rsp + 16 + 0], r10
	add rsp, 16
	mov rax, [rsp]
	cmp rax, 0
	jg .jump133
	sub rsp, 8 ; Align stack
	lea rdi, [rel const1] ; non-positive loop bound
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump133:
	; Computing bound for j
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for j
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump134
	sub rsp, 8 ; Align stack
	lea rdi, [rel const1] ; non-positive loop bound
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump134:
	; Computing bound for i
	sub rsp, 8
	; Moving 8 bytes from rbp - 64 to rsp
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump135
	lea rdi, [rel const1] ; non-positive loop bound
	call _fail_assertion
.jump135:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int
	imul rdi, [rsp + 0 + 0] ; multiply by g
	jno .jump136
	lea rdi, [rel const3] ; overflow computing array size
	call _fail_assertion
.jump136:
	imul rdi, [rsp + 0 + 8] ; multiply by c
	jno .jump137
	lea rdi, [rel const3] ; overflow computing array size
	call _fail_assertion
.jump137:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize j to 0
	mov rax, 0
	push rax
	; Initialize i to 0
	mov rax, 0
	push rax
.jump138: ; Begin body of loop
	; Compare j to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump140 ; If j >= bound, ...
	mov qword [rsp + 8], 0 ; j = 0
	add qword [rsp + 0], 1 ; i++
.jump140:
	; Compare i to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jge .jump139 ; If i >= bound, break
.jump141:
	; Compute loop body
	mov rax, [rel const24] ; 763
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	shl rax, 3
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment j
	add qword [rsp + 8], 1
	jmp .jump138
.jump139: ; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 64 to rsp
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump142
	lea rdi, [rel const9] ; negative array index
	call _fail_assertion
.jump142:
	cmp rax, [rsp + 16]
	jl .jump143
	lea rdi, [rel const10] ; index too large
	call _fail_assertion
.jump143:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump144
	lea rdi, [rel const9] ; negative array index
	call _fail_assertion
.jump144:
	cmp rax, [rsp + 24]
	jl .jump145
	lea rdi, [rel const10] ; index too large
	call _fail_assertion
.jump145:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	shl rax, 3
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 8
	; Moving 8 bytes from rax to rsp
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump146
	lea rdi, [rel const1] ; non-positive loop bound
	call _fail_assertion
.jump146:
	; Computing bound for i
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp r10, 0
	jne .jump147
	lea rdi, [rel const25] ; divide by zero
	call _fail_assertion
.jump147:
	cqo
	idiv r10
	push rax
	sub rsp, 8 ; Align stack
	mov rax, [rel const26] ; 42.06
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	call _acos
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	call _to_int
	add rsp, 8 ; Remove alignment
	push rax
	pop rax
	pop r10
	cmp r10, 0
	jne .jump148
	lea rdi, [rel const25] ; divide by zero
	call _fail_assertion
.jump148:
	cqo
	idiv r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump149
	sub rsp, 8 ; Align stack
	lea rdi, [rel const1] ; non-positive loop bound
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump149:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize k to 0
	mov rax, 0
	push rax
	; Initialize j to 0
	mov rax, 0
	push rax
	; Initialize i to 0
	mov rax, 0
	push rax
.jump150: ; Begin body of loop
	; Compare k to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump152 ; If k >= bound, ...
	mov qword [rsp + 16], 0 ; k = 0
	add qword [rsp + 8], 1 ; j++
.jump152:
	; Compare j to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump153 ; If j >= bound, ...
	mov qword [rsp + 8], 0 ; j = 0
	add qword [rsp + 0], 1 ; i++
.jump153:
	; Compare i to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jge .jump151 ; If i >= bound, break
.jump154:
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 176 to rsp
		mov r10, [rbp - 176 + 0]
		mov [rsp + 0], r10
	sub rsp, 16
	; Moving 16 bytes from rbp - 24 to rsp
		mov r10, [rbp - 24 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 64 to rsp
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
	; Moving 8 bytes from rsp + 0 to rsp + 24
		mov r10, [rsp + 0 + 0]
		mov [rsp + 24 + 0], r10
	add rsp, 24
	pop rax
	pop r10
	imul rax, r10
	push rax
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment k
	add qword [rsp + 16], 1
	jmp .jump150
.jump151: ; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for k
	mov rax, [rel const12] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump155
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	jmp .jump156
.jump155:
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for j
	sub rsp, 8
	; Moving 8 bytes from r12 - -16 to rsp
		mov r10, [r12 - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump157
	sub rsp, 8 ; Align stack
	lea rdi, [rel const1] ; non-positive loop bound
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump157:
	; Computing bound for i
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump158
	lea rdi, [rel const1] ; non-positive loop bound
	call _fail_assertion
.jump158:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize j to 0
	mov rax, 0
	push rax
	; Initialize i to 0
	mov rax, 0
	push rax
.jump159: ; Begin body of loop
	; Compare j to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump161 ; If j >= bound, ...
	mov qword [rsp + 8], 0 ; j = 0
	add qword [rsp + 0], 1 ; i++
.jump161:
	; Compare i to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jge .jump160 ; If i >= bound, break
.jump162:
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment j
	add qword [rsp + 8], 1
	jmp .jump159
.jump160: ; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	pop rax
	neg rax
	push rax
.jump156:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump163
	lea rdi, [rel const1] ; non-positive loop bound
	call _fail_assertion
.jump163:
	; Computing bound for j
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump164
	sub rsp, 8 ; Align stack
	lea rdi, [rel const1] ; non-positive loop bound
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump164:
	; Computing bound for i
	sub rsp, 8
	; Moving 8 bytes from rbp - 64 to rsp
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump165
	lea rdi, [rel const1] ; non-positive loop bound
	call _fail_assertion
.jump165:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize k to 0
	mov rax, 0
	push rax
	; Initialize j to 0
	mov rax, 0
	push rax
	; Initialize i to 0
	mov rax, 0
	push rax
.jump166: ; Begin body of loop
	; Compare k to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump168 ; If k >= bound, ...
	mov qword [rsp + 16], 0 ; k = 0
	add qword [rsp + 8], 1 ; j++
.jump168:
	; Compare j to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump169 ; If j >= bound, ...
	mov qword [rsp + 8], 0 ; j = 0
	add qword [rsp + 0], 1 ; i++
.jump169:
	; Compare i to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jge .jump167 ; If i >= bound, break
.jump170:
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 176 to rsp
		mov r10, [rbp - 176 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment k
	add qword [rsp + 16], 1
	jmp .jump166
.jump167: ; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump171
	lea rdi, [rel const9] ; negative array index
	call _fail_assertion
.jump171:
	cmp rax, [rsp + 24]
	jl .jump172
	lea rdi, [rel const10] ; index too large
	call _fail_assertion
.jump172:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump173
	lea rdi, [rel const9] ; negative array index
	call _fail_assertion
.jump173:
	cmp rax, [rsp + 32]
	jl .jump174
	lea rdi, [rel const10] ; index too large
	call _fail_assertion
.jump174:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump175
	lea rdi, [rel const9] ; negative array index
	call _fail_assertion
.jump175:
	cmp rax, [rsp + 40]
	jl .jump176
	lea rdi, [rel const10] ; index too large
	call _fail_assertion
.jump176:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 24
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 24
	; Moving 24 bytes from rax to rsp
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rbp - 8] ; Address to write return value into
	; Moving 24 bytes from rsp to rax
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 112 ; Local variables
	pop rbp
	ret

c:
_c:
	push rbp
	mov rbp, rsp
	push rdi
	mov rax, [rel const46] ; 8.83
	push rax
	sub rsp, 8
	; Moving 8 bytes from r12 - -16 to rsp
		mov r10, [r12 - -16 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	; Moving 8 bytes from rsp + 8 to rsp + 8
		mov r10, [rsp + 8 + 0]
		mov [rsp + 8 + 0], r10
	add rsp, 8
	pop rax
	neg rax
	push rax
	pop rax
	neg rax
	push rax
	pop rax
	neg rax
	push rax
	sub rsp, 8 ; Align stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	movsd xmm0, [rsp]
	add rsp, 8
	call _cos
	add rsp, 8 ; Remove alignment
	sub rsp, 8
	movsd [rsp], xmm0
	mov rax, [rel const6] ; True
	push rax
	pop rax
	xor rax, 1
	push rax
	; Moving 8 bytes from rsp + 0 to rsp + 8
		mov r10, [rsp + 0 + 0]
		mov [rsp + 8 + 0], r10
	add rsp, 8
	mov rax, [rel const6] ; True
	push rax
	pop rax
	cmp rax, 0
	jne .jump225
	mov rax, [rel const6] ; True
	push rax
	pop rax
.jump225:
	push rax
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	jne .jump226
	mov rax, [rel const12] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump227
	mov rax, [rel const6] ; True
	push rax
	pop rax
.jump227:
	push rax
	pop rax
	cmp rax, 0
	je .jump228
	mov rax, [rel const12] ; False
	push rax
	pop rax
.jump228:
	push rax
	pop rax
.jump226:
	push rax
	pop rax
	pop r10
	cmp rax, r10
	sete al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump229
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for f
	mov rax, [rel const12] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump231
	mov rax, [rel const47] ; 782
	push rax
	jmp .jump232
.jump231:
	sub rsp, 8
	; Moving 8 bytes from r12 - -16 to rsp
		mov r10, [r12 - -16 + 0]
		mov [rsp + 0], r10
.jump232:
	; Moving 8 bytes from rsp + 0 to rsp + 0
		mov r10, [rsp + 0 + 0]
		mov [rsp + 0 + 0], r10
	add rsp, 0
	mov rax, [rsp]
	cmp rax, 0
	jg .jump233
	sub rsp, 8 ; Align stack
	lea rdi, [rel const1] ; non-positive loop bound
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump233:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof float
	imul rdi, [rsp + 0 + 0] ; multiply by (if false then {782} else {argnum}){0}
	jno .jump234
	sub rsp, 8 ; Align stack
	lea rdi, [rel const3] ; overflow computing array size
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump234:
	sub rsp, 8 ; Align stack
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize f to 0
	mov rax, 0
	push rax
.jump235: ; Begin body of loop
	; Compare f to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jge .jump236 ; If f >= bound, break
.jump237:
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for g
	mov rax, [rel const48] ; 941
	push rax
	mov rax, [rsp]
	mov rdi, 7528
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize g to 0
	mov rax, 0
	push rax
.jump238: ; Begin body of loop
	; Compare g to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jge .jump239 ; If g >= bound, break
.jump240:
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	shl rax, 3
	add rax, [rsp + 24]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment g
	add qword [rsp + 0], 1
	jmp .jump238
.jump239: ; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for h
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump241
	lea rdi, [rel const1] ; non-positive loop bound
	call _fail_assertion
.jump241:
	; Computing bound for g
	mov rax, [rel const49] ; 334
	push rax
	mov rax, [rsp]
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize h to 0
	mov rax, 0
	push rax
	; Initialize g to 0
	mov rax, 0
	push rax
.jump242: ; Begin body of loop
	; Compare h to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump244 ; If h >= bound, ...
	mov qword [rsp + 8], 0 ; h = 0
	add qword [rsp + 0], 1 ; g++
.jump244:
	; Compare g to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jge .jump243 ; If g >= bound, break
.jump245:
	; Compute loop body
	mov rax, [rel const50] ; 659
	push rax
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment h
	add qword [rsp + 8], 1
	jmp .jump242
.jump243: ; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump246
	sub rsp, 8 ; Align stack
	lea rdi, [rel const9] ; negative array index
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump246:
	cmp rax, [rsp + 8]
	jl .jump247
	sub rsp, 8 ; Align stack
	lea rdi, [rel const10] ; index too large
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump247:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	shl rax, 3
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	shl rax, 3
	add rax, [rsp + 24]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment f
	add qword [rsp + 0], 1
	jmp .jump235
.jump236: ; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	jmp .jump230
.jump229:
	mov rax, [rel const12] ; False
	push rax
	pop rax
	cmp rax, 0
	jne .jump248
	mov rax, [rel const12] ; False
	push rax
	pop rax
.jump248:
	push rax
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump249
	sub rsp, 16
	sub rsp, 8 ; Align stack
	lea rdi, [rsp + 8]
	call _c
	add rsp, 8 ; Remove alignment
	mov rdi, 16
	sub rsp, 8 ; Align stack
	call _jpl_alloc
	add rsp, 8 ; Remove alignment
	; Moving 16 bytes from rsp to rax
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 16
	push rax
	mov rax, 1
	push rax
	jmp .jump250
.jump249:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for f
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for h
	mov rax, [rel const51] ; 736
	push rax
	mov rax, [rsp]
	; Computing bound for g
	mov rax, [rel const52] ; 31
	push rax
	mov rax, [rsp]
	; Computing bound for f
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump251
	lea rdi, [rel const1] ; non-positive loop bound
	call _fail_assertion
.jump251:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize h to 0
	mov rax, 0
	push rax
	; Initialize g to 0
	mov rax, 0
	push rax
	; Initialize f to 0
	mov rax, 0
	push rax
.jump252: ; Begin body of loop
	; Compare h to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump254 ; If h >= bound, ...
	mov qword [rsp + 16], 0 ; h = 0
	add qword [rsp + 8], 1 ; g++
.jump254:
	; Compare g to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump255 ; If g >= bound, ...
	mov qword [rsp + 8], 0 ; g = 0
	add qword [rsp + 0], 1 ; f++
.jump255:
	; Compare f to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jge .jump253 ; If f >= bound, break
.jump256:
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 80 to rsp
		mov r10, [rbp - 80 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment h
	add qword [rsp + 16], 1
	jmp .jump252
.jump253: ; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump257
	sub rsp, 8 ; Align stack
	lea rdi, [rel const1] ; non-positive loop bound
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump257:
	; Computing total size of heap memory to allocate
	mov rdi, 16 ; sizeof float[]
imul rdi, [rsp + 0 + 0] ; multiply by (sum[f : e, g : 31, h : 736] g)
	jno .jump258
	sub rsp, 8 ; Align stack
	lea rdi, [rel const3] ; overflow computing array size
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump258:
	sub rsp, 8 ; Align stack
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize f to 0
	mov rax, 0
	push rax
.jump259: ; Begin body of loop
	; Compare f to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jge .jump260 ; If f >= bound, break
.jump261:
	; Compute loop body
	mov rax, [rel const12] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump262
	sub rsp, 16
	lea rdi, [rsp + 0]
	call _c
	jmp .jump263
.jump262:
	sub rsp, 16
	lea rdi, [rsp + 0]
	call _c
.jump263:
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	shl rax, 4
	add rax, [rsp + 32]
	; Move body (16 bytes) to index
	; Moving 16 bytes from rsp to rax
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 16
	; Increment f
	add qword [rsp + 0], 1
	jmp .jump259
.jump260: ; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
.jump250:
	sub rsp, 8 ; Align stack
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	movsd xmm0, [rsp]
	add rsp, 8
	call _to_int
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump264
	lea rdi, [rel const9] ; negative array index
	call _fail_assertion
.jump264:
	cmp rax, [rsp + 8]
	jl .jump265
	lea rdi, [rel const10] ; index too large
	call _fail_assertion
.jump265:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	shl rax, 4
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 16
	; Moving 16 bytes from rax to rsp
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
.jump230:
	mov rax, [rbp - 8] ; Address to write return value into
	; Moving 16 bytes from rsp to rax
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 40 ; Local variables
	pop rbp
	ret
	mov rax, [rel const53] ; 10
	push rax
	mov rax, [rel const54] ; 890
	push rax
	sub rsp, 8
	; Moving 8 bytes from r12 - -16 to rsp
		mov r10, [r12 - -16 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp r10, 0
	jne .jump266
	sub rsp, 8 ; Align stack
	lea rdi, [rel const7] ; mod by zero
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump266:
	cqo
	idiv r10
	mov rax, rdx
	push rax
	pop rax
	pop r10
	cmp rax, r10
	sete al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump267
	sub rsp, 24
	sub rsp, 8 ; Align stack
	lea rdi, [rsp + 8]
	call _a
	add rsp, 8 ; Remove alignment
	; Moving 8 bytes from rsp + 0 to rsp + 16
		mov r10, [rsp + 0 + 0]
		mov [rsp + 16 + 0], r10
	add rsp, 16
	mov rax, [rel const6] ; True
	push rax
	jmp .jump268
.jump267:
	sub rsp, 8
	; Moving 8 bytes from r12 - -16 to rsp
		mov r10, [r12 - -16 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	setle al
	and rax, 1
	push rax
	sub rsp, 8
	; Moving 8 bytes from r12 - -16 to rsp
		mov r10, [r12 - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const55] ; 122
	push rax
	pop rax
	pop r10
	cmp rax, r10
	setge al
	and rax, 1
	push rax
.jump268:
	; Moving 8 bytes from rsp + 8 to rsp + 8
		mov r10, [rsp + 8 + 0]
		mov [rsp + 8 + 0], r10
	add rsp, 8
	pop rax
	cmp rax, 0
	je .jump269
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for i
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for h
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump271
	sub rsp, 8 ; Align stack
	lea rdi, [rel const1] ; non-positive loop bound
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump271:
	; Computing bound for g
	sub rsp, 8
	; Moving 8 bytes from r12 - -16 to rsp
		mov r10, [r12 - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump272
	lea rdi, [rel const1] ; non-positive loop bound
	call _fail_assertion
.jump272:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize h to 0
	mov rax, 0
	push rax
	; Initialize g to 0
	mov rax, 0
	push rax
.jump273: ; Begin body of loop
	; Compare h to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump275 ; If h >= bound, ...
	mov qword [rsp + 8], 0 ; h = 0
	add qword [rsp + 0], 1 ; g++
.jump275:
	; Compare g to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jge .jump274 ; If g >= bound, break
.jump276:
	; Compute loop body
	mov rax, [rel const56] ; 496
	push rax
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment h
	add qword [rsp + 8], 1
	jmp .jump273
.jump274: ; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump277
	lea rdi, [rel const1] ; non-positive loop bound
	call _fail_assertion
.jump277:
	; Computing bound for h
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump278
	sub rsp, 8 ; Align stack
	lea rdi, [rel const1] ; non-positive loop bound
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump278:
	; Computing bound for g
	sub rsp, 8
	; Moving 8 bytes from r12 - -16 to rsp
		mov r10, [r12 - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump279
	lea rdi, [rel const1] ; non-positive loop bound
	call _fail_assertion
.jump279:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool
	imul rdi, [rsp + 0 + 0] ; multiply by argnum
	jno .jump280
	lea rdi, [rel const3] ; overflow computing array size
	call _fail_assertion
.jump280:
	imul rdi, [rsp + 0 + 8] ; multiply by e
	jno .jump281
	lea rdi, [rel const3] ; overflow computing array size
	call _fail_assertion
.jump281:
imul rdi, [rsp + 0 + 16] ; multiply by (sum[g : argnum, h : e] 496)
	jno .jump282
	lea rdi, [rel const3] ; overflow computing array size
	call _fail_assertion
.jump282:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize i to 0
	mov rax, 0
	push rax
	; Initialize h to 0
	mov rax, 0
	push rax
	; Initialize g to 0
	mov rax, 0
	push rax
.jump283: ; Begin body of loop
	; Compare i to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump285 ; If i >= bound, ...
	mov qword [rsp + 16], 0 ; i = 0
	add qword [rsp + 8], 1 ; h++
.jump285:
	; Compare h to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump286 ; If h >= bound, ...
	mov qword [rsp + 8], 0 ; h = 0
	add qword [rsp + 0], 1 ; g++
.jump286:
	; Compare g to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jge .jump284 ; If g >= bound, break
.jump287:
	; Compute loop body
	mov rax, [rel const12] ; False
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	shl rax, 3
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment i
	add qword [rsp + 16], 1
	jmp .jump283
.jump284: ; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for g
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump288
	sub rsp, 8 ; Align stack
	lea rdi, [rel const1] ; non-positive loop bound
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump288:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize g to 0
	mov rax, 0
	push rax
.jump289: ; Begin body of loop
	; Compare g to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jge .jump290 ; If g >= bound, break
.jump291:
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - -16 to rsp
		mov r10, [r12 - -16 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment g
	add qword [rsp + 0], 1
	jmp .jump289
.jump290: ; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	movsd xmm0, [rsp]
	add rsp, 8
	call _atan
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	call _to_int
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump292
	sub rsp, 8 ; Align stack
	lea rdi, [rel const9] ; negative array index
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump292:
	cmp rax, [rsp + 24]
	jl .jump293
	sub rsp, 8 ; Align stack
	lea rdi, [rel const10] ; index too large
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump293:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump294
	sub rsp, 8 ; Align stack
	lea rdi, [rel const9] ; negative array index
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump294:
	cmp rax, [rsp + 32]
	jl .jump295
	sub rsp, 8 ; Align stack
	lea rdi, [rel const10] ; index too large
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump295:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump296
	sub rsp, 8 ; Align stack
	lea rdi, [rel const9] ; negative array index
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump296:
	cmp rax, [rsp + 40]
	jl .jump297
	sub rsp, 8 ; Align stack
	lea rdi, [rel const10] ; index too large
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump297:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	shl rax, 3
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 8
	; Moving 8 bytes from rax to rsp
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump298
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for i
	sub rsp, 8
	; Moving 8 bytes from r12 - -16 to rsp
		mov r10, [r12 - -16 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump300
	lea rdi, [rel const1] ; non-positive loop bound
	call _fail_assertion
.jump300:
	; Computing bound for h
	mov rax, [rel const57] ; 943
	push rax
	mov rax, [rsp]
	; Computing bound for g
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - -16 to rsp
		mov r10, [r12 - -16 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp r10, 0
	jne .jump301
	sub rsp, 8 ; Align stack
	lea rdi, [rel const25] ; divide by zero
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump301:
	cqo
	idiv r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump302
	lea rdi, [rel const1] ; non-positive loop bound
	call _fail_assertion
.jump302:
	; Computing total size of heap memory to allocate
	mov rdi, 16 ; sizeof float[]
	imul rdi, [rsp + 0 + 0] ; multiply by (argnum / f)
	jno .jump303
	lea rdi, [rel const3] ; overflow computing array size
	call _fail_assertion
.jump303:
	imul rdi, [rsp + 0 + 8] ; multiply by 943
	jno .jump304
	lea rdi, [rel const3] ; overflow computing array size
	call _fail_assertion
.jump304:
	imul rdi, [rsp + 0 + 16] ; multiply by (- argnum)
	jno .jump305
	lea rdi, [rel const3] ; overflow computing array size
	call _fail_assertion
.jump305:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize i to 0
	mov rax, 0
	push rax
	; Initialize h to 0
	mov rax, 0
	push rax
	; Initialize g to 0
	mov rax, 0
	push rax
.jump306: ; Begin body of loop
	; Compare i to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump308 ; If i >= bound, ...
	mov qword [rsp + 16], 0 ; i = 0
	add qword [rsp + 8], 1 ; h++
.jump308:
	; Compare h to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump309 ; If h >= bound, ...
	mov qword [rsp + 8], 0 ; h = 0
	add qword [rsp + 0], 1 ; g++
.jump309:
	; Compare g to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jge .jump307 ; If g >= bound, break
.jump310:
	; Compute loop body
	sub rsp, 16
	sub rsp, 8 ; Align stack
	lea rdi, [rsp + 8]
	call _c
	add rsp, 8 ; Remove alignment
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	shl rax, 4
	add rax, [rsp + 64]
	; Move body (16 bytes) to index
	; Moving 16 bytes from rsp to rax
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 16
	; Increment i
	add qword [rsp + 16], 1
	jmp .jump306
.jump307: ; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from r12 - -16 to rsp
		mov r10, [r12 - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const58] ; 99
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rel const6] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump311
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	jmp .jump312
.jump311:
	mov rax, [rel const59] ; 272
	push rax
.jump312:
	pop rax
	pop r10
	sub rax, r10
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	setg al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump313
	sub rsp, 8
	; Moving 8 bytes from r12 - -16 to rsp
		mov r10, [r12 - -16 + 0]
		mov [rsp + 0], r10
	jmp .jump314
.jump313:
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
.jump314:
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump315
	sub rsp, 8 ; Align stack
	lea rdi, [rel const9] ; negative array index
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump315:
	cmp rax, [rsp + 24]
	jl .jump316
	sub rsp, 8 ; Align stack
	lea rdi, [rel const10] ; index too large
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump316:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump317
	sub rsp, 8 ; Align stack
	lea rdi, [rel const9] ; negative array index
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump317:
	cmp rax, [rsp + 32]
	jl .jump318
	sub rsp, 8 ; Align stack
	lea rdi, [rel const10] ; index too large
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump318:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump319
	sub rsp, 8 ; Align stack
	lea rdi, [rel const9] ; negative array index
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump319:
	cmp rax, [rsp + 40]
	jl .jump320
	sub rsp, 8 ; Align stack
	lea rdi, [rel const10] ; index too large
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump320:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	shl rax, 4
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 16
	; Moving 16 bytes from rax to rsp
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	jmp .jump299
.jump298:
	sub rsp, 16
	lea rdi, [rsp + 0]
	call _c
.jump299:
	jmp .jump270
.jump269:
	sub rsp, 16
	lea rdi, [rsp + 0]
	call _c
.jump270:
	mov rax, [rbp - 8] ; Address to write return value into
	; Moving 16 bytes from rsp to rax
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 64 ; Local variables
	pop rbp
	ret

d:
_d:
	push rbp
	mov rbp, rsp
	sub rsp, 16
	lea rdi, [rsp + 0]
	call _c
	mov rax, [rel const6] ; True
	push rax
	pop rax
	cmp rax, 0
	jne .jump385
	lea rdi, [rel const77] ; q
	call _fail_assertion
.jump385:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for s
	sub rsp, 8
	; Moving 8 bytes from rbp - -72 to rsp
		mov r10, [rbp - -72 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump386
	lea rdi, [rel const1] ; non-positive loop bound
	call _fail_assertion
.jump386:
	; Computing bound for r
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - -40 to rsp
		mov r10, [rbp - -40 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - -80 to rsp
		mov r10, [rbp - -80 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	sub rax, r10
	push rax
	pop rax
	neg rax
	push rax
	pop rax
	neg rax
	push rax
	pop rax
	pop r10
	imul rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump387
	sub rsp, 8 ; Align stack
	lea rdi, [rel const1] ; non-positive loop bound
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump387:
	; Computing bound for q
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for r
	mov rax, [rel const78] ; 72.0
	push rax
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmpltsd xmm1, xmm0
	movq rax, xmm1
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump388
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	sub rsp, 24
	; Moving 24 bytes from rbp - -40 to rsp
		mov r10, [rbp - -40 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -40 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -40 + 0]
		mov [rsp + 0], r10
	jmp .jump389
.jump388:
	sub rsp, 8
	; Moving 8 bytes from rbp - -40 to rsp
		mov r10, [rbp - -40 + 0]
		mov [rsp + 0], r10
	sub rsp, 24
	; Moving 24 bytes from rbp - -40 to rsp
		mov r10, [rbp - -40 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -40 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -40 + 0]
		mov [rsp + 0], r10
.jump389:
	; Moving 8 bytes from rsp + 24 to rsp + 24
		mov r10, [rsp + 24 + 0]
		mov [rsp + 24 + 0], r10
	add rsp, 24
	mov rax, [rsp]
	cmp rax, 0
	jg .jump390
	sub rsp, 8 ; Align stack
	lea rdi, [rel const1] ; non-positive loop bound
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump390:
	; Computing bound for q
	sub rsp, 8 ; Align stack
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for s
	sub rsp, 8 ; Align stack
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	movsd xmm0, [rsp]
	add rsp, 8
	call _to_int
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump391
	lea rdi, [rel const1] ; non-positive loop bound
	call _fail_assertion
.jump391:
	; Computing bound for r
	sub rsp, 8
	; Moving 8 bytes from rbp - -24 to rsp
		mov r10, [rbp - -24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump392
	sub rsp, 8 ; Align stack
	lea rdi, [rel const1] ; non-positive loop bound
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump392:
	; Computing bound for q
	sub rsp, 8
	; Moving 8 bytes from r12 - -16 to rsp
		mov r10, [r12 - -16 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump393
	lea rdi, [rel const1] ; non-positive loop bound
	call _fail_assertion
.jump393:
	; Computing total size of heap memory to allocate
	mov rdi, 16 ; sizeof int[]
	imul rdi, [rsp + 0 + 0] ; multiply by (- argnum)
	jno .jump394
	lea rdi, [rel const3] ; overflow computing array size
	call _fail_assertion
.jump394:
	imul rdi, [rsp + 0 + 8] ; multiply by g
	jno .jump395
	lea rdi, [rel const3] ; overflow computing array size
	call _fail_assertion
.jump395:
	imul rdi, [rsp + 0 + 16] ; multiply by to_int(b)
	jno .jump396
	lea rdi, [rel const3] ; overflow computing array size
	call _fail_assertion
.jump396:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize s to 0
	mov rax, 0
	push rax
	; Initialize r to 0
	mov rax, 0
	push rax
	; Initialize q to 0
	mov rax, 0
	push rax
.jump397: ; Begin body of loop
	; Compare s to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump399 ; If s >= bound, ...
	mov qword [rsp + 16], 0 ; s = 0
	add qword [rsp + 8], 1 ; r++
.jump399:
	; Compare r to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump400 ; If r >= bound, ...
	mov qword [rsp + 8], 0 ; r = 0
	add qword [rsp + 0], 1 ; q++
.jump400:
	; Compare q to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jge .jump398 ; If q >= bound, break
.jump401:
	; Compute loop body
	sub rsp, 16
	; Moving 16 bytes from r12 - -16 to rsp
		mov r10, [r12 - -16 + 8]
		mov [rsp + 8], r10
		mov r10, [r12 - -16 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	shl rax, 4
	add rax, [rsp + 64]
	; Move body (16 bytes) to index
	; Moving 16 bytes from rsp to rax
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 16
	; Increment s
	add qword [rsp + 16], 1
	jmp .jump397
.jump398: ; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for r
	sub rsp, 8
	; Moving 8 bytes from rbp - -64 to rsp
		mov r10, [rbp - -64 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump402
	lea rdi, [rel const1] ; non-positive loop bound
	call _fail_assertion
.jump402:
	; Computing bound for q
	sub rsp, 16
	; Moving 16 bytes from r12 - -16 to rsp
		mov r10, [r12 - -16 + 8]
		mov [rsp + 8], r10
		mov r10, [r12 - -16 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - -80 to rsp
		mov r10, [rbp - -80 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump403
	sub rsp, 8 ; Align stack
	lea rdi, [rel const9] ; negative array index
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump403:
	cmp rax, [rsp + 8]
	jl .jump404
	sub rsp, 8 ; Align stack
	lea rdi, [rel const10] ; index too large
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump404:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	shl rax, 3
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump405
	sub rsp, 8 ; Align stack
	lea rdi, [rel const1] ; non-positive loop bound
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump405:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof float
	imul rdi, [rsp + 0 + 0] ; multiply by args[n]
	jno .jump406
	sub rsp, 8 ; Align stack
	lea rdi, [rel const3] ; overflow computing array size
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump406:
	imul rdi, [rsp + 0 + 8] ; multiply by l
	jno .jump407
	sub rsp, 8 ; Align stack
	lea rdi, [rel const3] ; overflow computing array size
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump407:
	sub rsp, 8 ; Align stack
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize r to 0
	mov rax, 0
	push rax
	; Initialize q to 0
	mov rax, 0
	push rax
.jump408: ; Begin body of loop
	; Compare r to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump410 ; If r >= bound, ...
	mov qword [rsp + 8], 0 ; r = 0
	add qword [rsp + 0], 1 ; q++
.jump410:
	; Compare q to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jge .jump409 ; If q >= bound, break
.jump411:
	; Compute loop body
	sub rsp, 8 ; Align stack
	sub rsp, 8
	; Moving 8 bytes from rbp - -24 to rsp
		mov r10, [rbp - -24 + 0]
		mov [rsp + 0], r10
	pop rdi
	call _to_float
	add rsp, 8 ; Remove alignment
	sub rsp, 8
	movsd [rsp], xmm0
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	shl rax, 3
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment r
	add qword [rsp + 8], 1
	jmp .jump408
.jump409: ; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	sub rsp, 24
	; Moving 24 bytes from rbp - -16 to rsp
		mov r10, [rbp - -16 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - -16 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	call _d
	add rsp, 24
	add rsp, 24
	add rsp, 32
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump412
	lea rdi, [rel const1] ; non-positive loop bound
	call _fail_assertion
.jump412:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize r to 0
	mov rax, 0
	push rax
	; Initialize q to 0
	mov rax, 0
	push rax
.jump413: ; Begin body of loop
	; Compare r to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump415 ; If r >= bound, ...
	mov qword [rsp + 8], 0 ; r = 0
	add qword [rsp + 0], 1 ; q++
.jump415:
	; Compare q to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jge .jump414 ; If q >= bound, break
.jump416:
	; Compute loop body
	mov rax, [rel const6] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump417
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for t
	sub rsp, 8
	; Moving 8 bytes from rbp - -72 to rsp
		mov r10, [rbp - -72 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump419
	lea rdi, [rel const1] ; non-positive loop bound
	call _fail_assertion
.jump419:
	; Computing bound for s
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump420
	sub rsp, 8 ; Align stack
	lea rdi, [rel const1] ; non-positive loop bound
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump420:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int
	imul rdi, [rsp + 0 + 0] ; multiply by r
	jno .jump421
	sub rsp, 8 ; Align stack
	lea rdi, [rel const3] ; overflow computing array size
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump421:
	imul rdi, [rsp + 0 + 8] ; multiply by m
	jno .jump422
	sub rsp, 8 ; Align stack
	lea rdi, [rel const3] ; overflow computing array size
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump422:
	sub rsp, 8 ; Align stack
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize t to 0
	mov rax, 0
	push rax
	; Initialize s to 0
	mov rax, 0
	push rax
.jump423: ; Begin body of loop
	; Compare t to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump425 ; If t >= bound, ...
	mov qword [rsp + 8], 0 ; t = 0
	add qword [rsp + 0], 1 ; s++
.jump425:
	; Compare s to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jge .jump424 ; If s >= bound, break
.jump426:
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - -72 to rsp
		mov r10, [rbp - -72 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	shl rax, 3
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment t
	add qword [rsp + 8], 1
	jmp .jump423
.jump424: ; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	jmp .jump418
.jump417:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for t
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump427
	lea rdi, [rel const1] ; non-positive loop bound
	call _fail_assertion
.jump427:
	; Computing bound for s
	sub rsp, 8
	; Moving 8 bytes from rbp - -40 to rsp
		mov r10, [rbp - -40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump428
	sub rsp, 8 ; Align stack
	lea rdi, [rel const1] ; non-positive loop bound
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump428:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int
	imul rdi, [rsp + 0 + 0] ; multiply by i
	jno .jump429
	sub rsp, 8 ; Align stack
	lea rdi, [rel const3] ; overflow computing array size
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump429:
	imul rdi, [rsp + 0 + 8] ; multiply by p
	jno .jump430
	sub rsp, 8 ; Align stack
	lea rdi, [rel const3] ; overflow computing array size
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump430:
	sub rsp, 8 ; Align stack
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize t to 0
	mov rax, 0
	push rax
	; Initialize s to 0
	mov rax, 0
	push rax
.jump431: ; Begin body of loop
	; Compare t to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump433 ; If t >= bound, ...
	mov qword [rsp + 8], 0 ; t = 0
	add qword [rsp + 0], 1 ; s++
.jump433:
	; Compare s to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jge .jump432 ; If s >= bound, break
.jump434:
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 120 to rsp
		mov r10, [rbp - 120 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	shl rax, 3
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment t
	add qword [rsp + 8], 1
	jmp .jump431
.jump432: ; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
.jump418:
	mov rax, [rel const79] ; 897
	push rax
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for t
	sub rsp, 8
	; Moving 8 bytes from rbp - -48 to rsp
		mov r10, [rbp - -48 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump435
	lea rdi, [rel const1] ; non-positive loop bound
	call _fail_assertion
.jump435:
	; Computing bound for s
	sub rsp, 8
	; Moving 8 bytes from rbp - -72 to rsp
		mov r10, [rbp - -72 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump436
	sub rsp, 8 ; Align stack
	lea rdi, [rel const1] ; non-positive loop bound
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump436:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int
	imul rdi, [rsp + 0 + 0] ; multiply by m
	jno .jump437
	sub rsp, 8 ; Align stack
	lea rdi, [rel const3] ; overflow computing array size
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump437:
	imul rdi, [rsp + 0 + 8] ; multiply by j
	jno .jump438
	sub rsp, 8 ; Align stack
	lea rdi, [rel const3] ; overflow computing array size
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump438:
	sub rsp, 8 ; Align stack
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize t to 0
	mov rax, 0
	push rax
	; Initialize s to 0
	mov rax, 0
	push rax
.jump439: ; Begin body of loop
	; Compare t to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump441 ; If t >= bound, ...
	mov qword [rsp + 8], 0 ; t = 0
	add qword [rsp + 0], 1 ; s++
.jump441:
	; Compare s to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jge .jump440 ; If s >= bound, break
.jump442:
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	shl rax, 3
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment t
	add qword [rsp + 8], 1
	jmp .jump439
.jump440: ; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	sub rsp, 8 ; Align stack
	mov rax, [rel const80] ; 26.78
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	call _to_int
	add rsp, 8 ; Remove alignment
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump443
	sub rsp, 8 ; Align stack
	lea rdi, [rel const9] ; negative array index
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump443:
	cmp rax, [rsp + 16]
	jl .jump444
	sub rsp, 8 ; Align stack
	lea rdi, [rel const10] ; index too large
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump444:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump445
	sub rsp, 8 ; Align stack
	lea rdi, [rel const9] ; negative array index
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump445:
	cmp rax, [rsp + 24]
	jl .jump446
	sub rsp, 8 ; Align stack
	lea rdi, [rel const10] ; index too large
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump446:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	shl rax, 3
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 8
	; Moving 8 bytes from rax to rsp
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump447
	sub rsp, 8 ; Align stack
	lea rdi, [rel const9] ; negative array index
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump447:
	cmp rax, [rsp + 16]
	jl .jump448
	sub rsp, 8 ; Align stack
	lea rdi, [rel const10] ; index too large
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump448:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump449
	sub rsp, 8 ; Align stack
	lea rdi, [rel const9] ; negative array index
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump449:
	cmp rax, [rsp + 24]
	jl .jump450
	sub rsp, 8 ; Align stack
	lea rdi, [rel const10] ; index too large
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump450:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	shl rax, 3
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 8
	; Moving 8 bytes from rax to rsp
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment r
	add qword [rsp + 8], 1
	jmp .jump413
.jump414: ; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump451
	lea rdi, [rel const1] ; non-positive loop bound
	call _fail_assertion
.jump451:
	; Computing total size of heap memory to allocate
	mov rdi, 24 ; sizeof {bool,int,bool}
imul rdi, [rsp + 0 + 0] ; multiply by (sum[q : d(e, (array[q : args[n], r : l] to_float(g)), (array[q : (- argnum), r : g, s : to_int(b)] args)), r : (if (b > 72.0) then {h, f} else {h, i}){1}] (if true then (array[s : r, t : m] m) else (array[s : i, t : p] s))[(array[s : m, t : j] f)[f, to_int(26.78)], 897])
	jno .jump452
	lea rdi, [rel const3] ; overflow computing array size
	call _fail_assertion
.jump452:
	imul rdi, [rsp + 0 + 8] ; multiply by ((- (- (n - i))) * p)
	jno .jump453
	lea rdi, [rel const3] ; overflow computing array size
	call _fail_assertion
.jump453:
	imul rdi, [rsp + 0 + 16] ; multiply by m
	jno .jump454
	lea rdi, [rel const3] ; overflow computing array size
	call _fail_assertion
.jump454:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize s to 0
	mov rax, 0
	push rax
	; Initialize r to 0
	mov rax, 0
	push rax
	; Initialize q to 0
	mov rax, 0
	push rax
.jump455: ; Begin body of loop
	; Compare s to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump457 ; If s >= bound, ...
	mov qword [rsp + 16], 0 ; s = 0
	add qword [rsp + 8], 1 ; r++
.jump457:
	; Compare r to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump458 ; If r >= bound, ...
	mov qword [rsp + 8], 0 ; r = 0
	add qword [rsp + 0], 1 ; q++
.jump458:
	; Compare q to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jge .jump456 ; If q >= bound, break
.jump459:
	; Compute loop body
	sub rsp, 24
	lea rdi, [rsp + 0]
	call _a
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, 24
	add rax, [rsp + 72]
	; Move body (24 bytes) to index
	; Moving 24 bytes from rsp to rax
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 24
	; Increment s
	add qword [rsp + 16], 1
	jmp .jump455
.jump456: ; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for u
	sub rsp, 8
	; Moving 8 bytes from rbp - -48 to rsp
		mov r10, [rbp - -48 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump460
	lea rdi, [rel const1] ; non-positive loop bound
	call _fail_assertion
.jump460:
	; Computing total size of heap memory to allocate
	mov rdi, 32 ; sizeof {bool,int,bool}[,,]
	imul rdi, [rsp + 0 + 0] ; multiply by j
	jno .jump461
	lea rdi, [rel const3] ; overflow computing array size
	call _fail_assertion
.jump461:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize u to 0
	mov rax, 0
	push rax
.jump462: ; Begin body of loop
	; Compare u to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jge .jump463 ; If u >= bound, break
.jump464:
	; Compute loop body
	sub rsp, 32
	; Moving 32 bytes from rbp - 48 to rsp
		mov r10, [rbp - 48 + 24]
		mov [rsp + 24], r10
		mov r10, [rbp - 48 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - 48 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	shl rax, 5
	add rax, [rsp + 48]
	; Move body (32 bytes) to index
	; Moving 32 bytes from rsp to rax
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	; Increment u
	add qword [rsp + 0], 1
	jmp .jump462
.jump463: ; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - -24 to rsp
		mov r10, [rbp - -24 + 0]
		mov [rsp + 0], r10
	pop rax
	add rsp, 64 ; Local variables
	pop rbp
	ret

i:
_i:
	push rbp
	mov rbp, rsp
	push rdi
	sub rsp, 8 ; Align stack
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for l
	sub rsp, 8
	; Moving 8 bytes from r12 - -16 to rsp
		mov r10, [r12 - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump549
	lea rdi, [rel const1] ; non-positive loop bound
	call _fail_assertion
.jump549:
	; Computing bound for k
	sub rsp, 8
	; Moving 8 bytes from r12 - -16 to rsp
		mov r10, [r12 - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump550
	sub rsp, 8 ; Align stack
	lea rdi, [rel const1] ; non-positive loop bound
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump550:
	; Computing bound for j
	sub rsp, 8
	; Moving 8 bytes from r12 - -16 to rsp
		mov r10, [r12 - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump551
	lea rdi, [rel const1] ; non-positive loop bound
	call _fail_assertion
.jump551:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof float
	imul rdi, [rsp + 0 + 0] ; multiply by argnum
	jno .jump552
	lea rdi, [rel const3] ; overflow computing array size
	call _fail_assertion
.jump552:
	imul rdi, [rsp + 0 + 8] ; multiply by argnum
	jno .jump553
	lea rdi, [rel const3] ; overflow computing array size
	call _fail_assertion
.jump553:
	imul rdi, [rsp + 0 + 16] ; multiply by argnum
	jno .jump554
	lea rdi, [rel const3] ; overflow computing array size
	call _fail_assertion
.jump554:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize l to 0
	mov rax, 0
	push rax
	; Initialize k to 0
	mov rax, 0
	push rax
	; Initialize j to 0
	mov rax, 0
	push rax
.jump555: ; Begin body of loop
	; Compare l to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump557 ; If l >= bound, ...
	mov qword [rsp + 16], 0 ; l = 0
	add qword [rsp + 8], 1 ; k++
.jump557:
	; Compare k to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump558 ; If k >= bound, ...
	mov qword [rsp + 8], 0 ; k = 0
	add qword [rsp + 0], 1 ; j++
.jump558:
	; Compare j to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jge .jump556 ; If j >= bound, break
.jump559:
	; Compute loop body
	sub rsp, 8 ; Align stack
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	movsd xmm0, [rsp]
	add rsp, 8
	call _exp
	add rsp, 8 ; Remove alignment
	sub rsp, 8
	movsd [rsp], xmm0
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	shl rax, 3
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment l
	add qword [rsp + 16], 1
	jmp .jump555
.jump556: ; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from r12 - -16 to rsp
		mov r10, [r12 - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const6] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump560
	mov rax, [rel const12] ; False
	push rax
	jmp .jump561
.jump560:
	mov rax, [rel const6] ; True
	push rax
.jump561:
	pop rax
	cmp rax, 0
	je .jump562
	mov rax, [rel const6] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump564
	sub rsp, 8
	; Moving 8 bytes from r12 - -16 to rsp
		mov r10, [r12 - -16 + 0]
		mov [rsp + 0], r10
	jmp .jump565
.jump564:
	mov rax, [rel const97] ; 587
	push rax
.jump565:
	jmp .jump563
.jump562:
	sub rsp, 8
	; Moving 8 bytes from r12 - 40 to rsp
		mov r10, [r12 - 40 + 0]
		mov [rsp + 0], r10
.jump563:
	sub rsp, 8
	; Moving 8 bytes from r12 - 40 to rsp
		mov r10, [r12 - 40 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump566
	sub rsp, 8 ; Align stack
	lea rdi, [rel const9] ; negative array index
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump566:
	cmp rax, [rsp + 24]
	jl .jump567
	sub rsp, 8 ; Align stack
	lea rdi, [rel const10] ; index too large
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump567:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump568
	sub rsp, 8 ; Align stack
	lea rdi, [rel const9] ; negative array index
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump568:
	cmp rax, [rsp + 32]
	jl .jump569
	sub rsp, 8 ; Align stack
	lea rdi, [rel const10] ; index too large
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump569:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump570
	sub rsp, 8 ; Align stack
	lea rdi, [rel const9] ; negative array index
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump570:
	cmp rax, [rsp + 40]
	jl .jump571
	sub rsp, 8 ; Align stack
	lea rdi, [rel const10] ; index too large
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump571:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	shl rax, 3
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 8
	; Moving 8 bytes from rax to rsp
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	sub rsp, 8 ; Align stack
	mov rax, [rel const98] ; 64.16
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	call _tan
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	call _asin
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	call _cos
	add rsp, 8 ; Remove alignment
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	call _pow
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	call _cos
	add rsp, 8 ; Remove alignment
	sub rsp, 8
	movsd [rsp], xmm0
	sub rsp, 24
	sub rsp, 8 ; Align stack
	lea rdi, [rsp + 8]
	call _a
	add rsp, 8 ; Remove alignment
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for n
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - -16 to rsp
		mov r10, [r12 - -16 + 0]
		mov [rsp + 0], r10
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for l
	mov rax, [rel const99] ; 700
	push rax
	mov rax, [rsp]
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize l to 0
	mov rax, 0
	push rax
.jump572: ; Begin body of loop
	; Compare l to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jge .jump573 ; If l >= bound, break
.jump574:
	; Compute loop body
	mov rax, [rel const100] ; 363
	push rax
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment l
	add qword [rsp + 0], 1
	jmp .jump572
.jump573: ; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	; Moving 8 bytes from rsp + 0 to rsp + 16
		mov r10, [rsp + 0 + 0]
		mov [rsp + 16 + 0], r10
	add rsp, 16
	mov rax, [rsp]
	cmp rax, 0
	jg .jump575
	sub rsp, 8 ; Align stack
	lea rdi, [rel const1] ; non-positive loop bound
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump575:
	; Computing bound for m
	sub rsp, 16
	; Moving 16 bytes from r12 - -16 to rsp
		mov r10, [r12 - -16 + 8]
		mov [rsp + 8], r10
		mov r10, [r12 - -16 + 0]
		mov [rsp + 0], r10
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for m
	sub rsp, 8
	; Moving 8 bytes from r12 - 48 to rsp
		mov r10, [r12 - 48 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump576
	sub rsp, 8 ; Align stack
	lea rdi, [rel const1] ; non-positive loop bound
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump576:
	; Computing bound for l
	sub rsp, 8
	; Moving 8 bytes from r12 - 48 to rsp
		mov r10, [r12 - 48 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump577
	lea rdi, [rel const1] ; non-positive loop bound
	call _fail_assertion
.jump577:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int
	imul rdi, [rsp + 0 + 0] ; multiply by f
	jno .jump578
	lea rdi, [rel const3] ; overflow computing array size
	call _fail_assertion
.jump578:
	imul rdi, [rsp + 0 + 8] ; multiply by f
	jno .jump579
	lea rdi, [rel const3] ; overflow computing array size
	call _fail_assertion
.jump579:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize m to 0
	mov rax, 0
	push rax
	; Initialize l to 0
	mov rax, 0
	push rax
.jump580: ; Begin body of loop
	; Compare m to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump582 ; If m >= bound, ...
	mov qword [rsp + 8], 0 ; m = 0
	add qword [rsp + 0], 1 ; l++
.jump582:
	; Compare l to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jge .jump581 ; If l >= bound, break
.jump583:
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 104 to rsp
		mov r10, [rbp - 104 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	shl rax, 3
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment m
	add qword [rsp + 8], 1
	jmp .jump580
.jump581: ; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from r12 - 40 to rsp
		mov r10, [r12 - 40 + 0]
		mov [rsp + 0], r10
	sub rsp, 8 ; Align stack
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	movsd xmm0, [rsp]
	add rsp, 8
	call _to_int
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump584
	lea rdi, [rel const9] ; negative array index
	call _fail_assertion
.jump584:
	cmp rax, [rsp + 16]
	jl .jump585
	lea rdi, [rel const10] ; index too large
	call _fail_assertion
.jump585:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump586
	lea rdi, [rel const9] ; negative array index
	call _fail_assertion
.jump586:
	cmp rax, [rsp + 24]
	jl .jump587
	lea rdi, [rel const10] ; index too large
	call _fail_assertion
.jump587:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	shl rax, 3
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 8
	; Moving 8 bytes from rax to rsp
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump588
	lea rdi, [rel const9] ; negative array index
	call _fail_assertion
.jump588:
	cmp rax, [rsp + 8]
	jl .jump589
	lea rdi, [rel const10] ; index too large
	call _fail_assertion
.jump589:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	shl rax, 3
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump590
	lea rdi, [rel const1] ; non-positive loop bound
	call _fail_assertion
.jump590:
	; Computing bound for l
	mov rax, [rel const6] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump591
	sub rsp, 16
	; Moving 16 bytes from r12 - -16 to rsp
		mov r10, [r12 - -16 + 8]
		mov [rsp + 8], r10
		mov r10, [r12 - -16 + 0]
		mov [rsp + 0], r10
	jmp .jump592
.jump591:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for l
	sub rsp, 8
	; Moving 8 bytes from r12 - -16 to rsp
		mov r10, [r12 - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump593
	lea rdi, [rel const1] ; non-positive loop bound
	call _fail_assertion
.jump593:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int
	imul rdi, [rsp + 0 + 0] ; multiply by argnum
	jno .jump594
	lea rdi, [rel const3] ; overflow computing array size
	call _fail_assertion
.jump594:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize l to 0
	mov rax, 0
	push rax
.jump595: ; Begin body of loop
	; Compare l to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jge .jump596 ; If l >= bound, break
.jump597:
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 40 to rsp
		mov r10, [r12 - 40 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	shl rax, 3
	add rax, [rsp + 24]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment l
	add qword [rsp + 0], 1
	jmp .jump595
.jump596: ; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
.jump592:
	sub rsp, 8
	; Moving 8 bytes from r12 - 48 to rsp
		mov r10, [r12 - 48 + 0]
		mov [rsp + 0], r10
	sub rsp, 32
	sub rsp, 8 ; Align stack
	lea rdi, [rsp + 8]
	call _i
	add rsp, 8 ; Remove alignment
	; Moving 8 bytes from rsp + 32 to rsp + 32
		mov r10, [rsp + 32 + 0]
		mov [rsp + 32 + 0], r10
	add rsp, 32
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump598
	sub rsp, 8 ; Align stack
	lea rdi, [rel const9] ; negative array index
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump598:
	cmp rax, [rsp + 8]
	jl .jump599
	sub rsp, 8 ; Align stack
	lea rdi, [rel const10] ; index too large
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump599:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	shl rax, 3
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump600
	sub rsp, 8 ; Align stack
	lea rdi, [rel const1] ; non-positive loop bound
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump600:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize n to 0
	mov rax, 0
	push rax
	; Initialize m to 0
	mov rax, 0
	push rax
	; Initialize l to 0
	mov rax, 0
	push rax
.jump601: ; Begin body of loop
	; Compare n to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump603 ; If n >= bound, ...
	mov qword [rsp + 16], 0 ; n = 0
	add qword [rsp + 8], 1 ; m++
.jump603:
	; Compare m to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump604 ; If m >= bound, ...
	mov qword [rsp + 8], 0 ; m = 0
	add qword [rsp + 0], 1 ; l++
.jump604:
	; Compare l to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jge .jump602 ; If l >= bound, break
.jump605:
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - -16 to rsp
		mov r10, [r12 - -16 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment n
	add qword [rsp + 16], 1
	jmp .jump601
.jump602: ; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	sub rsp, 8
	; Moving 8 bytes from r12 - 32 to rsp
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	sete al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	jne .jump606
	sub rsp, 8 ; Align stack
	lea rdi, [rel const101] ; l
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump606:
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for n
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	movsd xmm0, [rsp]
	add rsp, 8
	call _acos
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	call _sqrt
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	call _sqrt
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	call _to_int
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump607
	sub rsp, 8 ; Align stack
	lea rdi, [rel const1] ; non-positive loop bound
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump607:
	; Computing bound for m
	mov rax, [rel const6] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump608
	mov rax, [rel const6] ; True
	push rax
	jmp .jump609
.jump608:
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmplesd xmm0, xmm1
	movq rax, xmm0
	and rax, 1
	push rax
.jump609:
	pop rax
	cmp rax, 0
	je .jump610
	sub rsp, 24
	; Moving 24 bytes from rbp - 40 to rsp
		mov r10, [rbp - 40 + 16]
		mov [rsp + 16], r10
		mov r10, [rbp - 40 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const12] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump612
	mov rax, [rel const102] ; 606
	push rax
	jmp .jump613
.jump612:
	sub rsp, 8
	; Moving 8 bytes from r12 - 40 to rsp
		mov r10, [r12 - 40 + 0]
		mov [rsp + 0], r10
.jump613:
	jmp .jump611
.jump610:
	sub rsp, 24
	lea rdi, [rsp + 0]
	call _a
	sub rsp, 8
	; Moving 8 bytes from r12 - 40 to rsp
		mov r10, [r12 - 40 + 0]
		mov [rsp + 0], r10
.jump611:
	; Moving 8 bytes from rsp + 0 to rsp + 24
		mov r10, [rsp + 0 + 0]
		mov [rsp + 24 + 0], r10
	add rsp, 24
	mov rax, [rsp]
	cmp rax, 0
	jg .jump614
	lea rdi, [rel const1] ; non-positive loop bound
	call _fail_assertion
.jump614:
	; Computing bound for l
	sub rsp, 16
	lea rdi, [rsp + 0]
	call _c
	sub rsp, 8
	; Moving 8 bytes from r12 - 32 to rsp
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 48 to rsp
		mov r10, [r12 - 48 + 0]
		mov [rsp + 0], r10
	mov rdi, 32
	call _jpl_alloc
	; Moving 32 bytes from rsp to rax
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	push rax
	mov rax, 1
	push rax
	sub rsp, 8
	; Moving 8 bytes from r12 - 40 to rsp
		mov r10, [r12 - 40 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - -16 to rsp
		mov r10, [r12 - -16 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	sub rax, r10
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump615
	sub rsp, 8 ; Align stack
	lea rdi, [rel const9] ; negative array index
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump615:
	cmp rax, [rsp + 8]
	jl .jump616
	sub rsp, 8 ; Align stack
	lea rdi, [rel const10] ; index too large
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump616:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	shl rax, 5
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 32
	; Moving 32 bytes from rax to rsp
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	; Moving 8 bytes from rsp + 0 to rsp + 24
		mov r10, [rsp + 0 + 0]
		mov [rsp + 24 + 0], r10
	add rsp, 24
	mov rax, [rsp]
	cmp rax, 0
	jg .jump617
	sub rsp, 8 ; Align stack
	lea rdi, [rel const1] ; non-positive loop bound
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump617:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize n to 0
	mov rax, 0
	push rax
	; Initialize m to 0
	mov rax, 0
	push rax
	; Initialize l to 0
	mov rax, 0
	push rax
.jump618: ; Begin body of loop
	; Compare n to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump620 ; If n >= bound, ...
	mov qword [rsp + 16], 0 ; n = 0
	add qword [rsp + 8], 1 ; m++
.jump620:
	; Compare m to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump621 ; If m >= bound, ...
	mov qword [rsp + 8], 0 ; m = 0
	add qword [rsp + 0], 1 ; l++
.jump621:
	; Compare l to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jge .jump619 ; If l >= bound, break
.jump622:
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 80 to rsp
		mov r10, [rbp - 80 + 0]
		mov [rsp + 0], r10
	pop rdi
	call _to_float
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp + 48] ; Load sum
	addsd xmm0, xmm1 ; Add loop body
	movsd [rsp + 48], xmm0 ; Save sum
	; Increment n
	add qword [rsp + 16], 1
	jmp .jump618
.jump619: ; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for o
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for n
	mov rax, [rel const12] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump623
	sub rsp, 8
	; Moving 8 bytes from r12 - -16 to rsp
		mov r10, [r12 - -16 + 0]
		mov [rsp + 0], r10
	jmp .jump624
.jump623:
	mov rax, [rel const103] ; 23
	push rax
.jump624:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump625
	sub rsp, 8 ; Align stack
	lea rdi, [rel const1] ; non-positive loop bound
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump625:
	; Computing bound for m
	sub rsp, 8
	; Moving 8 bytes from r12 - 32 to rsp
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump626
	lea rdi, [rel const1] ; non-positive loop bound
	call _fail_assertion
.jump626:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int
	imul rdi, [rsp + 0 + 0] ; multiply by h
	jno .jump627
	lea rdi, [rel const3] ; overflow computing array size
	call _fail_assertion
.jump627:
	imul rdi, [rsp + 0 + 8] ; multiply by (if false then argnum else 23)
	jno .jump628
	lea rdi, [rel const3] ; overflow computing array size
	call _fail_assertion
.jump628:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize n to 0
	mov rax, 0
	push rax
	; Initialize m to 0
	mov rax, 0
	push rax
.jump629: ; Begin body of loop
	; Compare n to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump631 ; If n >= bound, ...
	mov qword [rsp + 8], 0 ; n = 0
	add qword [rsp + 0], 1 ; m++
.jump631:
	; Compare m to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jge .jump630 ; If m >= bound, break
.jump632:
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - -16 to rsp
		mov r10, [r12 - -16 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	shl rax, 3
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment n
	add qword [rsp + 8], 1
	jmp .jump629
.jump630: ; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	mov rax, [rel const104] ; 723
	push rax
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for o
	sub rsp, 8
	; Moving 8 bytes from r12 - -16 to rsp
		mov r10, [r12 - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump633
	sub rsp, 8 ; Align stack
	lea rdi, [rel const1] ; non-positive loop bound
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump633:
	; Computing bound for n
	sub rsp, 8
	; Moving 8 bytes from r12 - 40 to rsp
		mov r10, [r12 - 40 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump634
	lea rdi, [rel const1] ; non-positive loop bound
	call _fail_assertion
.jump634:
	; Computing bound for m
	sub rsp, 8
	; Moving 8 bytes from r12 - 48 to rsp
		mov r10, [r12 - 48 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump635
	sub rsp, 8 ; Align stack
	lea rdi, [rel const1] ; non-positive loop bound
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump635:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize o to 0
	mov rax, 0
	push rax
	; Initialize n to 0
	mov rax, 0
	push rax
	; Initialize m to 0
	mov rax, 0
	push rax
.jump636: ; Begin body of loop
	; Compare o to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump638 ; If o >= bound, ...
	mov qword [rsp + 16], 0 ; o = 0
	add qword [rsp + 8], 1 ; n++
.jump638:
	; Compare n to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump639 ; If n >= bound, ...
	mov qword [rsp + 8], 0 ; n = 0
	add qword [rsp + 0], 1 ; m++
.jump639:
	; Compare m to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jge .jump637 ; If m >= bound, break
.jump640:
	; Compute loop body
	mov rax, [rel const105] ; 60
	push rax
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment o
	add qword [rsp + 16], 1
	jmp .jump636
.jump637: ; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	pop rax
	pop r10
	imul rax, r10
	push rax
	sub rsp, 8
	; Moving 8 bytes from r12 - -16 to rsp
		mov r10, [r12 - -16 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 40 to rsp
		mov r10, [r12 - 40 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	setl al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump641
	sub rsp, 8 ; Align stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	movsd xmm0, [rsp]
	add rsp, 8
	call _to_int
	add rsp, 8 ; Remove alignment
	push rax
	jmp .jump642
.jump641:
	mov rax, [rel const106] ; 414
	push rax
.jump642:
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump643
	lea rdi, [rel const9] ; negative array index
	call _fail_assertion
.jump643:
	cmp rax, [rsp + 16]
	jl .jump644
	lea rdi, [rel const10] ; index too large
	call _fail_assertion
.jump644:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump645
	lea rdi, [rel const9] ; negative array index
	call _fail_assertion
.jump645:
	cmp rax, [rsp + 24]
	jl .jump646
	lea rdi, [rel const10] ; index too large
	call _fail_assertion
.jump646:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	shl rax, 3
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 8
	; Moving 8 bytes from rax to rsp
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump647
	lea rdi, [rel const1] ; non-positive loop bound
	call _fail_assertion
.jump647:
	; Computing bound for n
	mov rax, [rel const107] ; 655
	push rax
	mov rax, [rsp]
	; Computing bound for m
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for n
	sub rsp, 8
	; Moving 8 bytes from r12 - 40 to rsp
		mov r10, [r12 - 40 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 40 to rsp
		mov r10, [r12 - 40 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	sub rax, r10
	push rax
	pop rax
	neg rax
	push rax
	sub rsp, 8
	; Moving 8 bytes from r12 - 40 to rsp
		mov r10, [r12 - 40 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	sub rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump648
	sub rsp, 8 ; Align stack
	lea rdi, [rel const1] ; non-positive loop bound
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump648:
	; Computing bound for m
	mov rax, [rel const108] ; 498
	push rax
	mov rax, [rsp]
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize n to 0
	mov rax, 0
	push rax
	; Initialize m to 0
	mov rax, 0
	push rax
.jump649: ; Begin body of loop
	; Compare n to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump651 ; If n >= bound, ...
	mov qword [rsp + 8], 0 ; n = 0
	add qword [rsp + 0], 1 ; m++
.jump651:
	; Compare m to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jge .jump650 ; If m >= bound, break
.jump652:
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 112 to rsp
		mov r10, [rbp - 112 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment n
	add qword [rsp + 8], 1
	jmp .jump649
.jump650: ; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump653
	lea rdi, [rel const1] ; non-positive loop bound
	call _fail_assertion
.jump653:
	; Computing total size of heap memory to allocate
	mov rdi, 0 ; sizeof {}
imul rdi, [rsp + 0 + 0] ; multiply by (sum[m : 498, n : (g - (- (g - g)))] m)
	jno .jump654
	lea rdi, [rel const3] ; overflow computing array size
	call _fail_assertion
.jump654:
	imul rdi, [rsp + 0 + 8] ; multiply by 655
	jno .jump655
	lea rdi, [rel const3] ; overflow computing array size
	call _fail_assertion
.jump655:
imul rdi, [rsp + 0 + 16] ; multiply by (- (array[m : h, n : (if false then argnum else 23)] argnum)[(if (g < argnum) then to_int(l) else 414), ((sum[m : f, n : g, o : argnum] 60) * 723)])
	jno .jump656
	lea rdi, [rel const3] ; overflow computing array size
	call _fail_assertion
.jump656:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize o to 0
	mov rax, 0
	push rax
	; Initialize n to 0
	mov rax, 0
	push rax
	; Initialize m to 0
	mov rax, 0
	push rax
.jump657: ; Begin body of loop
	; Compare o to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump659 ; If o >= bound, ...
	mov qword [rsp + 16], 0 ; o = 0
	add qword [rsp + 8], 1 ; n++
.jump659:
	; Compare n to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump660 ; If n >= bound, ...
	mov qword [rsp + 8], 0 ; n = 0
	add qword [rsp + 0], 1 ; m++
.jump660:
	; Compare m to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jge .jump658 ; If m >= bound, break
.jump661:
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for r
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump662
	sub rsp, 8 ; Align stack
	lea rdi, [rel const1] ; non-positive loop bound
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump662:
	; Computing bound for q
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for r
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump663
	sub rsp, 8 ; Align stack
	lea rdi, [rel const1] ; non-positive loop bound
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump663:
	; Computing bound for q
	sub rsp, 8
	; Moving 8 bytes from r12 - 32 to rsp
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump664
	lea rdi, [rel const1] ; non-positive loop bound
	call _fail_assertion
.jump664:
	; Computing bound for p
	mov rax, [rel const109] ; 364
	push rax
	mov rax, [rsp]
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize r to 0
	mov rax, 0
	push rax
	; Initialize q to 0
	mov rax, 0
	push rax
	; Initialize p to 0
	mov rax, 0
	push rax
.jump665: ; Begin body of loop
	; Compare r to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump667 ; If r >= bound, ...
	mov qword [rsp + 16], 0 ; r = 0
	add qword [rsp + 8], 1 ; q++
.jump667:
	; Compare q to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump668 ; If q >= bound, ...
	mov qword [rsp + 8], 0 ; q = 0
	add qword [rsp + 0], 1 ; p++
.jump668:
	; Compare p to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jge .jump666 ; If p >= bound, break
.jump669:
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 176 to rsp
		mov r10, [rbp - 176 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment r
	add qword [rsp + 16], 1
	jmp .jump665
.jump666: ; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump670
	lea rdi, [rel const1] ; non-positive loop bound
	call _fail_assertion
.jump670:
	; Computing bound for p
	sub rsp, 8
	; Moving 8 bytes from r12 - 48 to rsp
		mov r10, [r12 - 48 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - -16 to rsp
		mov r10, [r12 - -16 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	imul rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump671
	sub rsp, 8 ; Align stack
	lea rdi, [rel const1] ; non-positive loop bound
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump671:
	; Computing total size of heap memory to allocate
	mov rdi, 24 ; sizeof {}[,]
	imul rdi, [rsp + 0 + 0] ; multiply by (argnum * f)
	jno .jump672
	sub rsp, 8 ; Align stack
	lea rdi, [rel const3] ; overflow computing array size
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump672:
imul rdi, [rsp + 0 + 8] ; multiply by (sum[p : 364, q : h, r : n] p)
	jno .jump673
	sub rsp, 8 ; Align stack
	lea rdi, [rel const3] ; overflow computing array size
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump673:
	imul rdi, [rsp + 0 + 16] ; multiply by n
	jno .jump674
	sub rsp, 8 ; Align stack
	lea rdi, [rel const3] ; overflow computing array size
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump674:
	sub rsp, 8 ; Align stack
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize r to 0
	mov rax, 0
	push rax
	; Initialize q to 0
	mov rax, 0
	push rax
	; Initialize p to 0
	mov rax, 0
	push rax
.jump675: ; Begin body of loop
	; Compare r to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump677 ; If r >= bound, ...
	mov qword [rsp + 16], 0 ; r = 0
	add qword [rsp + 8], 1 ; q++
.jump677:
	; Compare q to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump678 ; If q >= bound, ...
	mov qword [rsp + 8], 0 ; q = 0
	add qword [rsp + 0], 1 ; p++
.jump678:
	; Compare p to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jge .jump676 ; If p >= bound, break
.jump679:
	; Compute loop body
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for t
	sub rsp, 8
	; Moving 8 bytes from rbp - 152 to rsp
		mov r10, [rbp - 152 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump680
	lea rdi, [rel const1] ; non-positive loop bound
	call _fail_assertion
.jump680:
	; Computing bound for s
	sub rsp, 8
	; Moving 8 bytes from rbp - 104 to rsp
		mov r10, [rbp - 104 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump681
	sub rsp, 8 ; Align stack
	lea rdi, [rel const1] ; non-positive loop bound
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump681:
	; Computing total size of heap memory to allocate
	mov rdi, 0 ; sizeof {}
	imul rdi, [rsp + 0 + 0] ; multiply by m
	jno .jump682
	sub rsp, 8 ; Align stack
	lea rdi, [rel const3] ; overflow computing array size
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump682:
	imul rdi, [rsp + 0 + 8] ; multiply by q
	jno .jump683
	sub rsp, 8 ; Align stack
	lea rdi, [rel const3] ; overflow computing array size
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump683:
	sub rsp, 8 ; Align stack
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize t to 0
	mov rax, 0
	push rax
	; Initialize s to 0
	mov rax, 0
	push rax
.jump684: ; Begin body of loop
	; Compare t to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump686 ; If t >= bound, ...
	mov qword [rsp + 8], 0 ; t = 0
	add qword [rsp + 0], 1 ; s++
.jump686:
	; Compare s to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jge .jump685 ; If s >= bound, break
.jump687:
	; Compute loop body
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 0
	add rax, [rsp + 32]
	; Move body (0 bytes) to index
	; Moving 0 bytes from rsp to rax
	add rsp, 0
	; Increment t
	add qword [rsp + 8], 1
	jmp .jump684
.jump685: ; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 64] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	imul rax, 24
	add rax, [rsp + 72]
	; Move body (24 bytes) to index
	; Moving 24 bytes from rsp to rax
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 24
	; Increment r
	add qword [rsp + 16], 1
	jmp .jump675
.jump676: ; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from r12 - 48 to rsp
		mov r10, [r12 - 48 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 104 to rsp
		mov r10, [rbp - 104 + 0]
		mov [rsp + 0], r10
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for q
	sub rsp, 8
	; Moving 8 bytes from r12 - 48 to rsp
		mov r10, [r12 - 48 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump688
	sub rsp, 8 ; Align stack
	lea rdi, [rel const1] ; non-positive loop bound
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump688:
	; Computing bound for p
	sub rsp, 8
	; Moving 8 bytes from r12 - -16 to rsp
		mov r10, [r12 - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump689
	lea rdi, [rel const1] ; non-positive loop bound
	call _fail_assertion
.jump689:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize q to 0
	mov rax, 0
	push rax
	; Initialize p to 0
	mov rax, 0
	push rax
.jump690: ; Begin body of loop
	; Compare q to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump692 ; If q >= bound, ...
	mov qword [rsp + 8], 0 ; q = 0
	add qword [rsp + 0], 1 ; p++
.jump692:
	; Compare p to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jge .jump691 ; If p >= bound, break
.jump693:
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	pop rax
	neg rax
	push rax
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment q
	add qword [rsp + 8], 1
	jmp .jump690
.jump691: ; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump694
	lea rdi, [rel const9] ; negative array index
	call _fail_assertion
.jump694:
	cmp rax, [rsp + 24]
	jl .jump695
	lea rdi, [rel const10] ; index too large
	call _fail_assertion
.jump695:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump696
	lea rdi, [rel const9] ; negative array index
	call _fail_assertion
.jump696:
	cmp rax, [rsp + 32]
	jl .jump697
	lea rdi, [rel const10] ; index too large
	call _fail_assertion
.jump697:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump698
	lea rdi, [rel const9] ; negative array index
	call _fail_assertion
.jump698:
	cmp rax, [rsp + 40]
	jl .jump699
	lea rdi, [rel const10] ; index too large
	call _fail_assertion
.jump699:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 24
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 24
	; Moving 24 bytes from rax to rsp
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 48 to rsp
		mov r10, [r12 - 48 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from r12 - 16 to rsp
		mov r10, [r12 - 16 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmpltsd xmm1, xmm0
	movq rax, xmm1
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump700
	mov rax, [rel const110] ; 24
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 104 to rsp
		mov r10, [rbp - 104 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	setne al
	and rax, 1
	push rax
	jmp .jump701
.jump700:
	mov rax, [rel const12] ; False
	push rax
.jump701:
	pop rax
	cmp rax, 0
	je .jump702
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for r
	sub rsp, 8
	; Moving 8 bytes from r12 - 32 to rsp
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump704
	sub rsp, 8 ; Align stack
	lea rdi, [rel const1] ; non-positive loop bound
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump704:
	; Computing bound for q
	sub rsp, 8
	; Moving 8 bytes from rbp - 88 to rsp
		mov r10, [rbp - 88 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump705
	lea rdi, [rel const1] ; non-positive loop bound
	call _fail_assertion
.jump705:
	; Computing bound for p
	sub rsp, 8
	; Moving 8 bytes from rbp - 88 to rsp
		mov r10, [rbp - 88 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump706
	sub rsp, 8 ; Align stack
	lea rdi, [rel const1] ; non-positive loop bound
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump706:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int
	imul rdi, [rsp + 0 + 0] ; multiply by o
	jno .jump707
	sub rsp, 8 ; Align stack
	lea rdi, [rel const3] ; overflow computing array size
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump707:
	imul rdi, [rsp + 0 + 8] ; multiply by o
	jno .jump708
	sub rsp, 8 ; Align stack
	lea rdi, [rel const3] ; overflow computing array size
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump708:
	imul rdi, [rsp + 0 + 16] ; multiply by h
	jno .jump709
	sub rsp, 8 ; Align stack
	lea rdi, [rel const3] ; overflow computing array size
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump709:
	sub rsp, 8 ; Align stack
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize r to 0
	mov rax, 0
	push rax
	; Initialize q to 0
	mov rax, 0
	push rax
	; Initialize p to 0
	mov rax, 0
	push rax
.jump710: ; Begin body of loop
	; Compare r to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump712 ; If r >= bound, ...
	mov qword [rsp + 16], 0 ; r = 0
	add qword [rsp + 8], 1 ; q++
.jump712:
	; Compare q to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump713 ; If q >= bound, ...
	mov qword [rsp + 8], 0 ; q = 0
	add qword [rsp + 0], 1 ; p++
.jump713:
	; Compare p to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jge .jump711 ; If p >= bound, break
.jump714:
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from r12 - 40 to rsp
		mov r10, [r12 - 40 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	shl rax, 3
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment r
	add qword [rsp + 16], 1
	jmp .jump710
.jump711: ; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from r12 - 32 to rsp
		mov r10, [r12 - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const111] ; 2.02
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	call _to_int
	push rax
	mov rax, [rel const112] ; 925
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump715
	lea rdi, [rel const9] ; negative array index
	call _fail_assertion
.jump715:
	cmp rax, [rsp + 24]
	jl .jump716
	lea rdi, [rel const10] ; index too large
	call _fail_assertion
.jump716:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump717
	lea rdi, [rel const9] ; negative array index
	call _fail_assertion
.jump717:
	cmp rax, [rsp + 32]
	jl .jump718
	lea rdi, [rel const10] ; index too large
	call _fail_assertion
.jump718:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump719
	lea rdi, [rel const9] ; negative array index
	call _fail_assertion
.jump719:
	cmp rax, [rsp + 40]
	jl .jump720
	lea rdi, [rel const10] ; index too large
	call _fail_assertion
.jump720:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	shl rax, 3
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 8
	; Moving 8 bytes from rax to rsp
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	jmp .jump703
.jump702:
	sub rsp, 8
	; Moving 8 bytes from rbp - 104 to rsp
		mov r10, [rbp - 104 + 0]
		mov [rsp + 0], r10
.jump703:
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump721
	lea rdi, [rel const9] ; negative array index
	call _fail_assertion
.jump721:
	cmp rax, [rsp + 16]
	jl .jump722
	lea rdi, [rel const10] ; index too large
	call _fail_assertion
.jump722:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump723
	lea rdi, [rel const9] ; negative array index
	call _fail_assertion
.jump723:
	cmp rax, [rsp + 24]
	jl .jump724
	lea rdi, [rel const10] ; index too large
	call _fail_assertion
.jump724:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, 0
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 0
	; Moving 0 bytes from rax to rsp
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 0
	add rax, [rsp + 48]
	; Move body (0 bytes) to index
	; Moving 0 bytes from rsp to rax
	add rsp, 0
	; Increment o
	add qword [rsp + 16], 1
	jmp .jump657
.jump658: ; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	mov rax, [rbp - 8] ; Address to write return value into
	; Moving 32 bytes from rsp to rax
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 80 ; Local variables
	pop rbp
	ret

jpl_main:
_jpl_main:
	push rbp
	mov rbp, rsp
	push r12
	mov r12, rbp
	sub rsp, 8 ; Align stack
	mov rax, [rel const27] ; 89.95
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	call _tan
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	call _exp
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	call _cos
	sub rsp, 8
	movsd [rsp], xmm0
	sub rsp, 8 ; Align stack
	mov rax, [rel const28] ; 3.21
	push rax
	mov rax, [rel const29] ; 24.16
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	call _atan2
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	call _acos
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	call _sqrt
	add rsp, 8 ; Remove alignment
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	call _atan2
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	call _asin
	add rsp, 8 ; Remove alignment
	sub rsp, 8
	movsd [rsp], xmm0
	mov rax, [rel const6] ; True
	push rax
	pop rax
	cmp rax, 0
	jne .jump177
	lea rdi, [rel const30] ; c
	call _fail_assertion
.jump177:
	sub rsp, 8 ; Align stack
	sub rsp, 8 ; Align stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	movsd xmm0, [rsp]
	add rsp, 8
	call _acos
	sub rsp, 8
	movsd [rsp], xmm0
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	; Moving 8 bytes from rsp + 0 to rsp + 8
		mov r10, [rsp + 0 + 0]
		mov [rsp + 8 + 0], r10
	add rsp, 8
	; Moving 8 bytes from rsp + 0 to rsp + 0
		mov r10, [rsp + 0 + 0]
		mov [rsp + 0 + 0], r10
	add rsp, 0
	movsd xmm0, [rsp]
	add rsp, 8
	call _log
	add rsp, 8 ; Remove alignment
	sub rsp, 8
	movsd [rsp], xmm0
	lea rdi, [rel const31] ; (FloatType)
	lea rsi, [rsp]
	call _show
	add rsp, 8
	add rsp, 8 ; Remove alignment
	sub rsp, 8 ; Align stack
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for d
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump178
	sub rsp, 8 ; Align stack
	lea rdi, [rel const1] ; non-positive loop bound
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump178:
	; Computing bound for c
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for e
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump179
	sub rsp, 8 ; Align stack
	lea rdi, [rel const1] ; non-positive loop bound
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump179:
	; Computing bound for d
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump180
	lea rdi, [rel const1] ; non-positive loop bound
	call _fail_assertion
.jump180:
	; Computing bound for c
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump181
	sub rsp, 8 ; Align stack
	lea rdi, [rel const1] ; non-positive loop bound
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump181:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int
	imul rdi, [rsp + 0 + 0] ; multiply by argnum
	jno .jump182
	sub rsp, 8 ; Align stack
	lea rdi, [rel const3] ; overflow computing array size
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump182:
	imul rdi, [rsp + 0 + 8] ; multiply by argnum
	jno .jump183
	sub rsp, 8 ; Align stack
	lea rdi, [rel const3] ; overflow computing array size
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump183:
	imul rdi, [rsp + 0 + 16] ; multiply by argnum
	jno .jump184
	sub rsp, 8 ; Align stack
	lea rdi, [rel const3] ; overflow computing array size
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump184:
	sub rsp, 8 ; Align stack
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize e to 0
	mov rax, 0
	push rax
	; Initialize d to 0
	mov rax, 0
	push rax
	; Initialize c to 0
	mov rax, 0
	push rax
.jump185: ; Begin body of loop
	; Compare e to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump187 ; If e >= bound, ...
	mov qword [rsp + 16], 0 ; e = 0
	add qword [rsp + 8], 1 ; d++
.jump187:
	; Compare d to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump188 ; If d >= bound, ...
	mov qword [rsp + 8], 0 ; d = 0
	add qword [rsp + 0], 1 ; c++
.jump188:
	; Compare c to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jge .jump186 ; If c >= bound, break
.jump189:
	; Compute loop body
	mov rax, [rel const32] ; 898
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	shl rax, 3
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment e
	add qword [rsp + 16], 1
	jmp .jump185
.jump186: ; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	sub rsp, 8 ; Align stack
	mov rax, [rel const33] ; 10.55
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	call _asin
	add rsp, 8 ; Remove alignment
	sub rsp, 8
	movsd [rsp], xmm0
	; Moving 32 bytes from rsp + 8 to rsp + 8
		mov r10, [rsp + 8 + 24]
		mov [rsp + 8 + 24], r10
		mov r10, [rsp + 8 + 16]
		mov [rsp + 8 + 16], r10
		mov r10, [rsp + 8 + 8]
		mov [rsp + 8 + 8], r10
		mov r10, [rsp + 8 + 0]
		mov [rsp + 8 + 0], r10
	add rsp, 8
	sub rsp, 8 ; Align stack
	mov rax, [rel const34] ; 61.37
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	call _acos
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	call _to_int
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rel const35] ; 789
	push rax
	mov rax, [rel const12] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump190
	mov rax, [rel const36] ; 944
	push rax
	jmp .jump191
.jump190:
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
.jump191:
	pop rax
	pop r10
	sub rax, r10
	push rax
	pop rax
	pop r10
	add rax, r10
	push rax
	mov rax, [rel const37] ; 741
	push rax
	mov rax, [rel const38] ; 804
	push rax
	pop rax
	pop r10
	add rax, r10
	push rax
	pop rax
	neg rax
	push rax
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for e
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	movsd xmm0, [rsp]
	add rsp, 8
	call _to_int
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump192
	sub rsp, 8 ; Align stack
	lea rdi, [rel const1] ; non-positive loop bound
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump192:
	; Computing bound for d
	sub rsp, 8 ; Align stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	movsd xmm0, [rsp]
	add rsp, 8
	call _to_int
	add rsp, 8 ; Remove alignment
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump193
	lea rdi, [rel const1] ; non-positive loop bound
	call _fail_assertion
.jump193:
	; Computing bound for c
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	movsd xmm0, [rsp]
	add rsp, 8
	call _acos
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	call _to_int
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump194
	sub rsp, 8 ; Align stack
	lea rdi, [rel const1] ; non-positive loop bound
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump194:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize e to 0
	mov rax, 0
	push rax
	; Initialize d to 0
	mov rax, 0
	push rax
	; Initialize c to 0
	mov rax, 0
	push rax
.jump195: ; Begin body of loop
	; Compare e to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump197 ; If e >= bound, ...
	mov qword [rsp + 16], 0 ; e = 0
	add qword [rsp + 8], 1 ; d++
.jump197:
	; Compare d to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump198 ; If d >= bound, ...
	mov qword [rsp + 8], 0 ; d = 0
	add qword [rsp + 0], 1 ; c++
.jump198:
	; Compare c to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jge .jump196 ; If c >= bound, break
.jump199:
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 136 to rsp
		mov r10, [rbp - 136 + 0]
		mov [rsp + 0], r10
	; Moving 8 bytes from rsp + 0 to rsp + 0
		mov r10, [rsp + 0 + 0]
		mov [rsp + 0 + 0], r10
	add rsp, 0
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment e
	add qword [rsp + 16], 1
	jmp .jump195
.jump196: ; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump200
	lea rdi, [rel const9] ; negative array index
	call _fail_assertion
.jump200:
	cmp rax, [rsp + 24]
	jl .jump201
	lea rdi, [rel const10] ; index too large
	call _fail_assertion
.jump201:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump202
	lea rdi, [rel const9] ; negative array index
	call _fail_assertion
.jump202:
	cmp rax, [rsp + 32]
	jl .jump203
	lea rdi, [rel const10] ; index too large
	call _fail_assertion
.jump203:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump204
	lea rdi, [rel const9] ; negative array index
	call _fail_assertion
.jump204:
	cmp rax, [rsp + 40]
	jl .jump205
	lea rdi, [rel const10] ; index too large
	call _fail_assertion
.jump205:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	shl rax, 3
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 8
	; Moving 8 bytes from rax to rsp
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump206
	lea rdi, [rel const1] ; non-positive loop bound
	call _fail_assertion
.jump206:
	; Computing total size of heap memory to allocate
	mov rdi, 32 ; sizeof {float,float,float,float}
imul rdi, [rsp + 0 + 0] ; multiply by {asin(10.55), (array[c : argnum, d : argnum, e : argnum] 898)}{1}[(sum[c : to_int(acos(b)), d : (- to_int(b)), e : to_int(b)] {d}{0}), (- (804 + 741)), (((if false then 944 else argnum) - 789) + to_int(acos(61.37)))]
	jno .jump207
	lea rdi, [rel const3] ; overflow computing array size
	call _fail_assertion
.jump207:
	imul rdi, [rsp + 0 + 8] ; multiply by argnum
	jno .jump208
	lea rdi, [rel const3] ; overflow computing array size
	call _fail_assertion
.jump208:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize d to 0
	mov rax, 0
	push rax
	; Initialize c to 0
	mov rax, 0
	push rax
.jump209: ; Begin body of loop
	; Compare d to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump211 ; If d >= bound, ...
	mov qword [rsp + 8], 0 ; d = 0
	add qword [rsp + 0], 1 ; c++
.jump211:
	; Compare c to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jge .jump210 ; If c >= bound, break
.jump212:
	; Compute loop body
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for f
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump213
	lea rdi, [rel const1] ; non-positive loop bound
	call _fail_assertion
.jump213:
	; Computing bound for e
	sub rsp, 8
	; Moving 8 bytes from rbp - 64 to rsp
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump214
	sub rsp, 8 ; Align stack
	lea rdi, [rel const1] ; non-positive loop bound
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump214:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize f to 0
	mov rax, 0
	push rax
	; Initialize e to 0
	mov rax, 0
	push rax
.jump215: ; Begin body of loop
	; Compare f to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump217 ; If f >= bound, ...
	mov qword [rsp + 8], 0 ; f = 0
	add qword [rsp + 0], 1 ; e++
.jump217:
	; Compare e to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jge .jump216 ; If e >= bound, break
.jump218:
	; Compute loop body
	sub rsp, 8 ; Align stack
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	pop rdi
	call _to_float
	add rsp, 8 ; Remove alignment
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp + 32] ; Load sum
	addsd xmm0, xmm1 ; Add loop body
	movsd [rsp + 32], xmm0 ; Save sum
	; Increment f
	add qword [rsp + 8], 1
	jmp .jump215
.jump216: ; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	sub rsp, 8 ; Align stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	movsd xmm0, [rsp]
	add rsp, 8
	call _atan
	add rsp, 8 ; Remove alignment
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	call _atan2
	sub rsp, 8
	movsd [rsp], xmm0
	sub rsp, 8 ; Align stack
	mov rax, [rel const39] ; 80.06
	push rax
	sub rsp, 8 ; Align stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	movsd xmm0, [rsp]
	add rsp, 8
	call _cos
	add rsp, 8 ; Remove alignment
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	call _pow
	sub rsp, 8
	movsd [rsp], xmm0
	sub rsp, 8 ; Align stack
	mov rax, [rel const40] ; 68.92
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	call _acos
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	call _acos
	add rsp, 8 ; Remove alignment
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	call _pow
	add rsp, 8 ; Remove alignment
	sub rsp, 8
	movsd [rsp], xmm0
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for f
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump219
	lea rdi, [rel const1] ; non-positive loop bound
	call _fail_assertion
.jump219:
	; Computing bound for e
	mov rax, [rel const41] ; 519
	push rax
	mov rax, [rel const18] ; 445
	push rax
	mov rax, [rel const42] ; 3.41
	push rax
	; Moving 8 bytes from rsp + 16 to rsp + 16
		mov r10, [rsp + 16 + 0]
		mov [rsp + 16 + 0], r10
	add rsp, 16
	mov rax, [rsp]
	cmp rax, 0
	jg .jump220
	sub rsp, 8 ; Align stack
	lea rdi, [rel const1] ; non-positive loop bound
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump220:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize f to 0
	mov rax, 0
	push rax
	; Initialize e to 0
	mov rax, 0
	push rax
.jump221: ; Begin body of loop
	; Compare f to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump223 ; If f >= bound, ...
	mov qword [rsp + 8], 0 ; f = 0
	add qword [rsp + 0], 1 ; e++
.jump223:
	; Compare e to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jge .jump222 ; If e >= bound, break
.jump224:
	; Compute loop body
	sub rsp, 8 ; Align stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	movsd xmm0, [rsp]
	add rsp, 8
	call _atan
	add rsp, 8 ; Remove alignment
	sub rsp, 8
	movsd [rsp], xmm0
	mov rax, [rel const43] ; 9.53
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp + 32] ; Load sum
	addsd xmm0, xmm1 ; Add loop body
	movsd [rsp + 32], xmm0 ; Save sum
	; Increment f
	add qword [rsp + 8], 1
	jmp .jump221
.jump222: ; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	mov rax, [rel const44] ; 19.37
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	shl rax, 5
	add rax, [rsp + 64]
	; Move body (32 bytes) to index
	; Moving 32 bytes from rsp to rax
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	; Increment d
	add qword [rsp + 8], 1
	jmp .jump209
.jump210: ; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	lea rdi, [rel const45] ; c.png
	call _write_image
	add rsp, 24
	add rsp, 8 ; Remove alignment
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for d
	mov rax, [rel const60] ; 608
	push rax
	mov rax, [rsp]
	mov rdi, 4864
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize d to 0
	mov rax, 0
	push rax
.jump321: ; Begin body of loop
	; Compare d to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jge .jump322 ; If d >= bound, break
.jump323:
	; Compute loop body
	mov rax, [rel const12] ; False
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	shl rax, 3
	add rax, [rsp + 24]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment d
	add qword [rsp + 0], 1
	jmp .jump321
.jump322: ; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	mov rax, [rel const6] ; True
	push rax
	pop rax
	cmp rax, 0
	jne .jump324
	mov rax, [rel const6] ; True
	push rax
	pop rax
.jump324:
	push rax
	pop rax
	cmp rax, 0
	je .jump325
	mov rax, [rel const60] ; 608
	push rax
	jmp .jump326
.jump325:
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp r10, 0
	jne .jump327
	lea rdi, [rel const7] ; mod by zero
	call _fail_assertion
.jump327:
	cqo
	idiv r10
	mov rax, rdx
	push rax
.jump326:
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump328
	sub rsp, 8 ; Align stack
	lea rdi, [rel const9] ; negative array index
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump328:
	cmp rax, [rsp + 8]
	jl .jump329
	sub rsp, 8 ; Align stack
	lea rdi, [rel const10] ; index too large
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump329:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	shl rax, 3
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump330
	mov rax, [rel const61] ; 337
	push rax
	mov rax, [rel const62] ; 73
	push rax
	pop rax
	pop r10
	cmp rax, r10
	sete al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump332
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	movsd xmm0, [rsp]
	add rsp, 8
	call _tan
	sub rsp, 8
	movsd [rsp], xmm0
	jmp .jump333
.jump332:
	mov rax, [rel const63] ; 38.38
	push rax
.jump333:
	mov rax, [rel const6] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump334
	sub rsp, 8 ; Align stack
	mov rax, [rel const64] ; 41.41
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	call _sin
	add rsp, 8 ; Remove alignment
	sub rsp, 8
	movsd [rsp], xmm0
	jmp .jump335
.jump334:
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
.jump335:
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmpltsd xmm1, xmm0
	movq rax, xmm1
	and rax, 1
	push rax
	jmp .jump331
.jump330:
	mov rax, [rel const12] ; False
	push rax
.jump331:
	pop rax
	cmp rax, 0
	je .jump336
	jmp .jump337
.jump336:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for f
	mov rax, [rel const65] ; 802
	push rax
	mov rax, [rsp]
	; Computing bound for e
	mov rax, [rel const66] ; 681
	push rax
	mov rax, [rsp]
	; Computing bound for d
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump338
	lea rdi, [rel const1] ; non-positive loop bound
	call _fail_assertion
.jump338:
	; Computing total size of heap memory to allocate
	mov rdi, 0 ; sizeof {}
	imul rdi, [rsp + 0 + 0] ; multiply by argnum
	jno .jump339
	lea rdi, [rel const3] ; overflow computing array size
	call _fail_assertion
.jump339:
	imul rdi, [rsp + 0 + 8] ; multiply by 681
	jno .jump340
	lea rdi, [rel const3] ; overflow computing array size
	call _fail_assertion
.jump340:
	imul rdi, [rsp + 0 + 16] ; multiply by 802
	jno .jump341
	lea rdi, [rel const3] ; overflow computing array size
	call _fail_assertion
.jump341:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize f to 0
	mov rax, 0
	push rax
	; Initialize e to 0
	mov rax, 0
	push rax
	; Initialize d to 0
	mov rax, 0
	push rax
.jump342: ; Begin body of loop
	; Compare f to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump344 ; If f >= bound, ...
	mov qword [rsp + 16], 0 ; f = 0
	add qword [rsp + 8], 1 ; e++
.jump344:
	; Compare e to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump345 ; If e >= bound, ...
	mov qword [rsp + 8], 0 ; e = 0
	add qword [rsp + 0], 1 ; d++
.jump345:
	; Compare d to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jge .jump343 ; If d >= bound, break
.jump346:
	; Compute loop body
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 0
	add rax, [rsp + 48]
	; Move body (0 bytes) to index
	; Moving 0 bytes from rsp to rax
	add rsp, 0
	; Increment f
	add qword [rsp + 16], 1
	jmp .jump342
.jump343: ; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	; Moving 32 bytes from rsp + 0 to rsp + 0
		mov r10, [rsp + 0 + 24]
		mov [rsp + 0 + 24], r10
		mov r10, [rsp + 0 + 16]
		mov [rsp + 0 + 16], r10
		mov r10, [rsp + 0 + 8]
		mov [rsp + 0 + 8], r10
		mov r10, [rsp + 0 + 0]
		mov [rsp + 0 + 0], r10
	add rsp, 0
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	cmp rax, r10
	setg al
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump347
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const67] ; 28.7
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmpltsd xmm0, xmm1
	movq rax, xmm0
	and rax, 1
	push rax
	jmp .jump348
.jump347:
	mov rax, [rel const6] ; True
	push rax
.jump348:
	pop rax
	cmp rax, 0
	je .jump349
	mov rax, [rel const68] ; 138
	push rax
	jmp .jump350
.jump349:
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const6] ; True
	push rax
	; Moving 8 bytes from rsp + 8 to rsp + 8
		mov r10, [rsp + 8 + 0]
		mov [rsp + 8 + 0], r10
	add rsp, 8
.jump350:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for f
	mov rax, [rel const69] ; 79
	push rax
	mov rax, [rsp]
	; Computing bound for e
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump351
	lea rdi, [rel const1] ; non-positive loop bound
	call _fail_assertion
.jump351:
	; Computing bound for d
	mov rax, [rel const70] ; 120
	push rax
	mov rax, [rsp]
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int
	imul rdi, [rsp + 0 + 0] ; multiply by 120
	jno .jump352
	sub rsp, 8 ; Align stack
	lea rdi, [rel const3] ; overflow computing array size
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump352:
	imul rdi, [rsp + 0 + 8] ; multiply by argnum
	jno .jump353
	sub rsp, 8 ; Align stack
	lea rdi, [rel const3] ; overflow computing array size
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump353:
	imul rdi, [rsp + 0 + 16] ; multiply by 79
	jno .jump354
	sub rsp, 8 ; Align stack
	lea rdi, [rel const3] ; overflow computing array size
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump354:
	sub rsp, 8 ; Align stack
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize f to 0
	mov rax, 0
	push rax
	; Initialize e to 0
	mov rax, 0
	push rax
	; Initialize d to 0
	mov rax, 0
	push rax
.jump355: ; Begin body of loop
	; Compare f to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump357 ; If f >= bound, ...
	mov qword [rsp + 16], 0 ; f = 0
	add qword [rsp + 8], 1 ; e++
.jump357:
	; Compare e to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump358 ; If e >= bound, ...
	mov qword [rsp + 8], 0 ; e = 0
	add qword [rsp + 0], 1 ; d++
.jump358:
	; Compare d to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jge .jump356 ; If d >= bound, break
.jump359:
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 96 to rsp
		mov r10, [rbp - 96 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	shl rax, 3
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment f
	add qword [rsp + 16], 1
	jmp .jump355
.jump356: ; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	sub rsp, 24
	lea rdi, [rsp + 0]
	call _a
	; Moving 8 bytes from rsp + 8 to rsp + 16
		mov r10, [rsp + 8 + 0]
		mov [rsp + 16 + 0], r10
	add rsp, 16
	mov rax, [rel const71] ; 847
	push rax
	pop rax
	neg rax
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump360
	lea rdi, [rel const9] ; negative array index
	call _fail_assertion
.jump360:
	cmp rax, [rsp + 24]
	jl .jump361
	lea rdi, [rel const10] ; index too large
	call _fail_assertion
.jump361:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump362
	lea rdi, [rel const9] ; negative array index
	call _fail_assertion
.jump362:
	cmp rax, [rsp + 32]
	jl .jump363
	lea rdi, [rel const10] ; index too large
	call _fail_assertion
.jump363:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump364
	lea rdi, [rel const9] ; negative array index
	call _fail_assertion
.jump364:
	cmp rax, [rsp + 40]
	jl .jump365
	lea rdi, [rel const10] ; index too large
	call _fail_assertion
.jump365:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	shl rax, 3
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 8
	; Moving 8 bytes from rax to rsp
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const72] ; 639
	push rax
	pop rax
	pop r10
	cmp r10, 0
	jne .jump366
	lea rdi, [rel const7] ; mod by zero
	call _fail_assertion
.jump366:
	cqo
	idiv r10
	mov rax, rdx
	push rax
	pop rax
	pop r10
	imul rax, r10
	push rax
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for e
	sub rsp, 8 ; Align stack
	mov rax, [rel const73] ; 74.95
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	call _sin
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	call _to_int
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump367
	lea rdi, [rel const1] ; non-positive loop bound
	call _fail_assertion
.jump367:
	; Computing bound for d
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for d
	mov rax, [rel const12] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump368
	mov rax, [rel const74] ; 107
	push rax
	jmp .jump369
.jump368:
	mov rax, [rel const75] ; 226
	push rax
.jump369:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump370
	lea rdi, [rel const1] ; non-positive loop bound
	call _fail_assertion
.jump370:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize d to 0
	mov rax, 0
	push rax
.jump371: ; Begin body of loop
	; Compare d to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jge .jump372 ; If d >= bound, break
.jump373:
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 104 to rsp
		mov r10, [rbp - 104 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment d
	add qword [rsp + 0], 1
	jmp .jump371
.jump372: ; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump374
	sub rsp, 8 ; Align stack
	lea rdi, [rel const1] ; non-positive loop bound
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump374:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize e to 0
	mov rax, 0
	push rax
	; Initialize d to 0
	mov rax, 0
	push rax
.jump375: ; Begin body of loop
	; Compare e to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump377 ; If e >= bound, ...
	mov qword [rsp + 8], 0 ; e = 0
	add qword [rsp + 0], 1 ; d++
.jump377:
	; Compare d to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jge .jump376 ; If d >= bound, break
.jump378:
	; Compute loop body
	sub rsp, 8 ; Align stack
	mov rax, [rel const76] ; 48.35
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	call _sin
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	call _to_int
	add rsp, 8 ; Remove alignment
	push rax
	pop rax
	add [rsp + 32], rax ; Add loop body to sum
	; Increment e
	add qword [rsp + 8], 1
	jmp .jump375
.jump376: ; End body of loop
	; Free all loop variables
	add rsp, 16
	; Free all loop bounds
	add rsp, 16
	; sum left on stack
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump379
	sub rsp, 8 ; Align stack
	lea rdi, [rel const9] ; negative array index
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump379:
	cmp rax, [rsp + 24]
	jl .jump380
	sub rsp, 8 ; Align stack
	lea rdi, [rel const10] ; index too large
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump380:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump381
	sub rsp, 8 ; Align stack
	lea rdi, [rel const9] ; negative array index
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump381:
	cmp rax, [rsp + 32]
	jl .jump382
	sub rsp, 8 ; Align stack
	lea rdi, [rel const10] ; index too large
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump382:
	mov rax, [rsp + 16]
	cmp rax, 0
	jge .jump383
	sub rsp, 8 ; Align stack
	lea rdi, [rel const9] ; negative array index
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump383:
	cmp rax, [rsp + 40]
	jl .jump384
	sub rsp, 8 ; Align stack
	lea rdi, [rel const10] ; index too large
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump384:
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, 0
	add rax, [rsp + 48]
	add rsp, 8
	add rsp, 8
	add rsp, 8
	add rsp, 32
	sub rsp, 0
	; Moving 0 bytes from rax to rsp
.jump337:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for f
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const19] ; 863
	push rax
	pop rax
	pop r10
	sub rax, r10
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump465
	lea rdi, [rel const1] ; non-positive loop bound
	call _fail_assertion
.jump465:
	; Computing bound for e
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for g
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump466
	lea rdi, [rel const1] ; non-positive loop bound
	call _fail_assertion
.jump466:
	; Computing bound for f
	sub rsp, 16
	; Moving 16 bytes from rbp - -16 to rsp
		mov r10, [rbp - -16 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump467
	sub rsp, 8 ; Align stack
	lea rdi, [rel const9] ; negative array index
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump467:
	cmp rax, [rsp + 8]
	jl .jump468
	sub rsp, 8 ; Align stack
	lea rdi, [rel const10] ; index too large
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump468:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	shl rax, 3
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump469
	sub rsp, 8 ; Align stack
	lea rdi, [rel const1] ; non-positive loop bound
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump469:
	; Computing bound for e
	sub rsp, 8 ; Align stack
	mov rax, [rel const81] ; 74.84
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	call _to_int
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump470
	lea rdi, [rel const1] ; non-positive loop bound
	call _fail_assertion
.jump470:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize g to 0
	mov rax, 0
	push rax
	; Initialize f to 0
	mov rax, 0
	push rax
	; Initialize e to 0
	mov rax, 0
	push rax
.jump471: ; Begin body of loop
	; Compare g to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump473 ; If g >= bound, ...
	mov qword [rsp + 16], 0 ; g = 0
	add qword [rsp + 8], 1 ; f++
.jump473:
	; Compare f to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump474 ; If f >= bound, ...
	mov qword [rsp + 8], 0 ; f = 0
	add qword [rsp + 0], 1 ; e++
.jump474:
	; Compare e to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jge .jump472 ; If e >= bound, break
.jump475:
	; Compute loop body
	mov rax, [rel const72] ; 639
	push rax
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment g
	add qword [rsp + 16], 1
	jmp .jump471
.jump472: ; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump476
	sub rsp, 8 ; Align stack
	lea rdi, [rel const1] ; non-positive loop bound
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump476:
	; Computing total size of heap memory to allocate
	mov rdi, 32 ; sizeof int[,,]
imul rdi, [rsp + 0 + 0] ; multiply by (sum[e : to_int(74.84), f : args[argnum], g : argnum] 639)
	jno .jump477
	sub rsp, 8 ; Align stack
	lea rdi, [rel const3] ; overflow computing array size
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump477:
	imul rdi, [rsp + 0 + 8] ; multiply by (863 - argnum)
	jno .jump478
	sub rsp, 8 ; Align stack
	lea rdi, [rel const3] ; overflow computing array size
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump478:
	sub rsp, 8 ; Align stack
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize f to 0
	mov rax, 0
	push rax
	; Initialize e to 0
	mov rax, 0
	push rax
.jump479: ; Begin body of loop
	; Compare f to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump481 ; If f >= bound, ...
	mov qword [rsp + 8], 0 ; f = 0
	add qword [rsp + 0], 1 ; e++
.jump481:
	; Compare e to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jge .jump480 ; If e >= bound, break
.jump482:
	; Compute loop body
	mov rax, [rel const12] ; False
	push rax
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump483
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for i
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump485
	sub rsp, 8 ; Align stack
	lea rdi, [rel const1] ; non-positive loop bound
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump485:
	; Computing bound for h
	mov rax, [rel const82] ; 330
	push rax
	mov rax, [rsp]
	; Computing bound for g
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump486
	sub rsp, 8 ; Align stack
	lea rdi, [rel const1] ; non-positive loop bound
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump486:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int
	imul rdi, [rsp + 0 + 0] ; multiply by argnum
	jno .jump487
	sub rsp, 8 ; Align stack
	lea rdi, [rel const3] ; overflow computing array size
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump487:
	imul rdi, [rsp + 0 + 8] ; multiply by 330
	jno .jump488
	sub rsp, 8 ; Align stack
	lea rdi, [rel const3] ; overflow computing array size
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump488:
	imul rdi, [rsp + 0 + 16] ; multiply by e
	jno .jump489
	sub rsp, 8 ; Align stack
	lea rdi, [rel const3] ; overflow computing array size
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump489:
	sub rsp, 8 ; Align stack
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize i to 0
	mov rax, 0
	push rax
	; Initialize h to 0
	mov rax, 0
	push rax
	; Initialize g to 0
	mov rax, 0
	push rax
.jump490: ; Begin body of loop
	; Compare i to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump492 ; If i >= bound, ...
	mov qword [rsp + 16], 0 ; i = 0
	add qword [rsp + 8], 1 ; h++
.jump492:
	; Compare h to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump493 ; If h >= bound, ...
	mov qword [rsp + 8], 0 ; h = 0
	add qword [rsp + 0], 1 ; g++
.jump493:
	; Compare g to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jge .jump491 ; If g >= bound, break
.jump494:
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 104 to rsp
		mov r10, [rbp - 104 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	shl rax, 3
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment i
	add qword [rsp + 16], 1
	jmp .jump490
.jump491: ; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
	jmp .jump484
.jump483:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for i
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump495
	sub rsp, 8 ; Align stack
	lea rdi, [rel const1] ; non-positive loop bound
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump495:
	; Computing bound for h
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump496
	lea rdi, [rel const1] ; non-positive loop bound
	call _fail_assertion
.jump496:
	; Computing bound for g
	mov rax, [rel const83] ; 746
	push rax
	mov rax, [rsp]
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int
	imul rdi, [rsp + 0 + 0] ; multiply by 746
	jno .jump497
	sub rsp, 8 ; Align stack
	lea rdi, [rel const3] ; overflow computing array size
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump497:
	imul rdi, [rsp + 0 + 8] ; multiply by e
	jno .jump498
	sub rsp, 8 ; Align stack
	lea rdi, [rel const3] ; overflow computing array size
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump498:
	imul rdi, [rsp + 0 + 16] ; multiply by f
	jno .jump499
	sub rsp, 8 ; Align stack
	lea rdi, [rel const3] ; overflow computing array size
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump499:
	sub rsp, 8 ; Align stack
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize i to 0
	mov rax, 0
	push rax
	; Initialize h to 0
	mov rax, 0
	push rax
	; Initialize g to 0
	mov rax, 0
	push rax
.jump500: ; Begin body of loop
	; Compare i to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump502 ; If i >= bound, ...
	mov qword [rsp + 16], 0 ; i = 0
	add qword [rsp + 8], 1 ; h++
.jump502:
	; Compare h to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump503 ; If h >= bound, ...
	mov qword [rsp + 8], 0 ; h = 0
	add qword [rsp + 0], 1 ; g++
.jump503:
	; Compare g to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jge .jump501 ; If g >= bound, break
.jump504:
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 112 to rsp
		mov r10, [rbp - 112 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 40] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 24]
	shl rax, 3
	add rax, [rsp + 56]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment i
	add qword [rsp + 16], 1
	jmp .jump500
.jump501: ; End body of loop
	; Free all loop variables
	add rsp, 24
	; array left on stack
.jump484:
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 48] ; No overflow if indices in bounds
	add rax, [rsp + 32]
	imul rax, [rsp + 56] ; No overflow if indices in bounds
	add rax, [rsp + 40]
	shl rax, 5
	add rax, [rsp + 64]
	; Move body (32 bytes) to index
	; Moving 32 bytes from rsp to rax
		mov r10, [rsp + 24]
		mov [rax + 24], r10
		mov r10, [rsp + 16]
		mov [rax + 16], r10
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 32
	; Increment f
	add qword [rsp + 8], 1
	jmp .jump479
.jump480: ; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	sub rsp, 8 ; Align stack
	mov rax, [rel const84] ; 30.89
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	call _acos
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	call _log
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	call _to_int
	add rsp, 8 ; Remove alignment
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 16 to rsp
		mov r10, [rbp - 16 + 0]
		mov [rsp + 0], r10
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	call _pow
	sub rsp, 8
	movsd [rsp], xmm0
	mov rax, [rel const85] ; 24.6
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmplesd xmm1, xmm0
	movq rax, xmm1
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump505
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for g
	sub rsp, 8 ; Align stack
	mov rax, [rel const86] ; 78.38
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	call _to_int
	add rsp, 8 ; Remove alignment
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump507
	lea rdi, [rel const1] ; non-positive loop bound
	call _fail_assertion
.jump507:
	; Computing bound for f
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump508
	sub rsp, 8 ; Align stack
	lea rdi, [rel const1] ; non-positive loop bound
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump508:
	; Computing bound for e
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for e
	mov rax, [rel const87] ; 814
	push rax
	mov rax, [rsp]
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize e to 0
	mov rax, 0
	push rax
.jump509: ; Begin body of loop
	; Compare e to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jge .jump510 ; If e >= bound, break
.jump511:
	; Compute loop body
	mov rax, [rel const88] ; 22
	push rax
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment e
	add qword [rsp + 0], 1
	jmp .jump509
.jump510: ; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump512
	lea rdi, [rel const1] ; non-positive loop bound
	call _fail_assertion
.jump512:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize g to 0
	mov rax, 0
	push rax
	; Initialize f to 0
	mov rax, 0
	push rax
	; Initialize e to 0
	mov rax, 0
	push rax
.jump513: ; Begin body of loop
	; Compare g to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump515 ; If g >= bound, ...
	mov qword [rsp + 16], 0 ; g = 0
	add qword [rsp + 8], 1 ; f++
.jump515:
	; Compare f to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump516 ; If f >= bound, ...
	mov qword [rsp + 8], 0 ; f = 0
	add qword [rsp + 0], 1 ; e++
.jump516:
	; Compare e to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jge .jump514 ; If e >= bound, break
.jump517:
	; Compute loop body
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for j
	sub rsp, 8
	; Moving 8 bytes from rbp - 88 to rsp
		mov r10, [rbp - 88 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump518
	sub rsp, 8 ; Align stack
	lea rdi, [rel const1] ; non-positive loop bound
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump518:
	; Computing bound for i
	mov rax, [rel const89] ; 564
	push rax
	mov rax, [rsp]
	; Computing bound for h
	mov rax, [rel const90] ; 398
	push rax
	mov rax, [rsp]
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 24], rax ; Move to pre-allocated space
	; Initialize j to 0
	mov rax, 0
	push rax
	; Initialize i to 0
	mov rax, 0
	push rax
	; Initialize h to 0
	mov rax, 0
	push rax
.jump519: ; Begin body of loop
	; Compare j to its bound
	mov rax, [rsp + 16]
	cmp rax, [rsp + 40]
	jl .jump521 ; If j >= bound, ...
	mov qword [rsp + 16], 0 ; j = 0
	add qword [rsp + 8], 1 ; i++
.jump521:
	; Compare i to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 32]
	jl .jump522 ; If i >= bound, ...
	mov qword [rsp + 8], 0 ; i = 0
	add qword [rsp + 0], 1 ; h++
.jump522:
	; Compare h to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 24]
	jge .jump520 ; If h >= bound, break
.jump523:
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 144 to rsp
		mov r10, [rbp - 144 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment j
	add qword [rsp + 16], 1
	jmp .jump519
.jump520: ; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	pop rax
	add [rsp + 48], rax ; Add loop body to sum
	; Increment g
	add qword [rsp + 16], 1
	jmp .jump513
.jump514: ; End body of loop
	; Free all loop variables
	add rsp, 24
	; Free all loop bounds
	add rsp, 24
	; sum left on stack
	jmp .jump506
.jump505:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for f
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump524
	lea rdi, [rel const1] ; non-positive loop bound
	call _fail_assertion
.jump524:
	; Computing bound for e
	mov rax, [rel const91] ; 854
	push rax
	mov rax, [rsp]
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int
	imul rdi, [rsp + 0 + 0] ; multiply by 854
	jno .jump525
	sub rsp, 8 ; Align stack
	lea rdi, [rel const3] ; overflow computing array size
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump525:
	imul rdi, [rsp + 0 + 8] ; multiply by argnum
	jno .jump526
	sub rsp, 8 ; Align stack
	lea rdi, [rel const3] ; overflow computing array size
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump526:
	sub rsp, 8 ; Align stack
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 16], rax ; Move to pre-allocated space
	; Initialize f to 0
	mov rax, 0
	push rax
	; Initialize e to 0
	mov rax, 0
	push rax
.jump527: ; Begin body of loop
	; Compare f to its bound
	mov rax, [rsp + 8]
	cmp rax, [rsp + 24]
	jl .jump529 ; If f >= bound, ...
	mov qword [rsp + 8], 0 ; f = 0
	add qword [rsp + 0], 1 ; e++
.jump529:
	; Compare e to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 16]
	jge .jump528 ; If e >= bound, break
.jump530:
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 88 to rsp
		mov r10, [rbp - 88 + 0]
		mov [rsp + 0], r10
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	imul rax, [rsp + 32] ; No overflow if indices in bounds
	add rax, [rsp + 16]
	shl rax, 3
	add rax, [rsp + 40]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment f
	add qword [rsp + 8], 1
	jmp .jump527
.jump528: ; End body of loop
	; Free all loop variables
	add rsp, 16
	; array left on stack
	mov rax, [rel const92] ; 483
	push rax
	mov rax, [rel const93] ; 124
	push rax
	pop rax
	neg rax
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump531
	sub rsp, 8 ; Align stack
	lea rdi, [rel const9] ; negative array index
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump531:
	cmp rax, [rsp + 16]
	jl .jump532
	sub rsp, 8 ; Align stack
	lea rdi, [rel const10] ; index too large
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump532:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump533
	sub rsp, 8 ; Align stack
	lea rdi, [rel const9] ; negative array index
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump533:
	cmp rax, [rsp + 24]
	jl .jump534
	sub rsp, 8 ; Align stack
	lea rdi, [rel const10] ; index too large
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump534:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	shl rax, 3
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 8
	; Moving 8 bytes from rax to rsp
		mov r10, [rax + 0]
		mov [rsp + 0], r10
.jump506:
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump535
	sub rsp, 8 ; Align stack
	lea rdi, [rel const9] ; negative array index
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump535:
	cmp rax, [rsp + 16]
	jl .jump536
	sub rsp, 8 ; Align stack
	lea rdi, [rel const10] ; index too large
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump536:
	mov rax, [rsp + 8]
	cmp rax, 0
	jge .jump537
	sub rsp, 8 ; Align stack
	lea rdi, [rel const9] ; negative array index
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump537:
	cmp rax, [rsp + 24]
	jl .jump538
	sub rsp, 8 ; Align stack
	lea rdi, [rel const10] ; index too large
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump538:
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	imul rax, [rsp + 24] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	shl rax, 5
	add rax, [rsp + 32]
	add rsp, 8
	add rsp, 8
	add rsp, 24
	sub rsp, 32
	; Moving 32 bytes from rax to rsp
		mov r10, [rax + 24]
		mov [rsp + 24], r10
		mov r10, [rax + 16]
		mov [rsp + 16], r10
		mov r10, [rax + 8]
		mov [rsp + 8], r10
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for i
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump539
	lea rdi, [rel const1] ; non-positive loop bound
	call _fail_assertion
.jump539:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool
	imul rdi, [rsp + 0 + 0] ; multiply by h
	jno .jump540
	lea rdi, [rel const3] ; overflow computing array size
	call _fail_assertion
.jump540:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize i to 0
	mov rax, 0
	push rax
.jump541: ; Begin body of loop
	; Compare i to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jge .jump542 ; If i >= bound, break
.jump543:
	; Compute loop body
	mov rax, [rel const6] ; True
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	shl rax, 3
	add rax, [rsp + 24]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment i
	add qword [rsp + 0], 1
	jmp .jump541
.jump542: ; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump544
	sub rsp, 8 ; Align stack
	lea rdi, [rel const9] ; negative array index
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump544:
	cmp rax, [rsp + 8]
	jl .jump545
	sub rsp, 8 ; Align stack
	lea rdi, [rel const10] ; index too large
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump545:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	shl rax, 3
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump546
	sub rsp, 16
	; Moving 16 bytes from rbp - -16 to rsp
		mov r10, [rbp - -16 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const12] ; False
	push rax
	mov rax, [rel const94] ; 39
	push rax
	jmp .jump547
.jump546:
	sub rsp, 8
	; Moving 8 bytes from rbp - 40 to rsp
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rdi, 16
	call _jpl_alloc
	; Moving 16 bytes from rsp to rax
		mov r10, [rsp + 8]
		mov [rax + 8], r10
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 16
	push rax
	mov rax, 2
	push rax
	mov rax, [rel const95] ; 52
	push rax
	mov rax, [rel const6] ; True
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
.jump547:
	; Moving 16 bytes from rsp + 8 to rsp + 24
		mov r10, [rsp + 8 + 8]
		mov [rsp + 24 + 8], r10
		mov r10, [rsp + 8 + 0]
		mov [rsp + 24 + 0], r10
	add rsp, 24
	; Moving 8 bytes from rsp + 0 to rsp + 8
		mov r10, [rsp + 0 + 0]
		mov [rsp + 8 + 0], r10
	add rsp, 8
	pop rax
	cmp rax, 0
	jne .jump548
	lea rdi, [rel const96] ; i
	call _fail_assertion
.jump548:
	sub rsp, 16
	; Moving 16 bytes from rbp - -16 to rsp
		mov r10, [rbp - -16 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	add rsp, 56 ; Local variables
	pop r12
	pop rbp
	ret

