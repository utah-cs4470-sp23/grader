global jpl_main
global _jpl_main
extern _fail_assertion
extern _jpl_alloc
extern _get_time
extern _show
extern _print
extern _print_time
extern _read_image
extern _write_image
extern _fmod
extern _sqrt
extern _exp
extern _sin
extern _cos
extern _tan
extern _asin
extern _acos
extern _atan
extern _log
extern _pow
extern _atan2
extern _to_int
extern _to_float

section .data
const0: dq 1
const1: dq 0
const2: dq 70.89
const3: dq 43.23
const4: dq 526
const5: dq 24.7
const6: db `non-positive loop bound`, 0
const7: dq 110
const8: db `negative array index`, 0
const9: db `index too large`, 0
const10: db `overflow computing array size`, 0
const11: dq 88.36
const12: dq 342
const13: dq 4.73
const14: dq 203
const15: db `(BoolType)`, 0
const16: dq 316
const17: dq 635
const18: dq 666
const19: dq 408
const20: db `mod by zero`, 0
const21: dq 1.29
const22: dq 361
const23: dq 711
const24: dq 20.09
const25: dq 72.98
const26: dq 82.19
const27: db `(FloatType)`, 0
const28: db `h.png`, 0
const29: dq 442
const30: dq 962
const31: db `(IntType)`, 0

section .text
jpl_main:
_jpl_main:
	push rbp
	mov rbp, rsp
	push r12
	mov r12, rbp
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for a
	mov rax, [rel const0] ; True
	push rax
	pop rax
	xor rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump1
	mov rax, [rel const0] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump3
	mov rax, [rel const1] ; False
	push rax
	jmp .jump4
.jump3:
	mov rax, [rel const0] ; True
	push rax
.jump4:
	jmp .jump2
.jump1:
	mov rax, [rel const0] ; True
	push rax
.jump2:
	pop rax
	cmp rax, 0
	je .jump5
	mov rax, [rel const0] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump7
	mov rax, [rel const2] ; 70.89
	push rax
	jmp .jump8
.jump7:
	mov rax, [rel const3] ; 43.23
	push rax
.jump8:
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for a
	mov rax, [rel const4] ; 526
	push rax
	mov rax, [rsp]
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize a to 0
	mov rax, 0
	push rax
.jump9: ; Begin body of loop
	; Compare a to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jge .jump10 ; If a >= bound, break
.jump11:
	; Compute loop body
	mov rax, [rel const5] ; 24.7
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp + 16] ; Load sum
	addsd xmm0, xmm1 ; Add loop body
	movsd [rsp + 16], xmm0 ; Save sum
	; Increment a
	add qword [rsp + 0], 1
	jmp .jump9
.jump10: ; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmplesd xmm1, xmm0
	movq rax, xmm1
	and rax, 1
	push rax
	jmp .jump6
.jump5:
	mov rax, [rel const0] ; True
	push rax
	mov rax, [rel const0] ; True
	push rax
	pop rax
	cmp rax, 0
	jne .jump12
	mov rax, [rel const1] ; False
	push rax
	pop rax
.jump12:
	push rax
	pop rax
	pop r10
	cmp rax, r10
	sete al
	and rax, 1
	push rax
.jump6:
	pop rax
	cmp rax, 0
	je .jump13
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for a
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump15
	lea rdi, [rel const6] ; non-positive loop bound
	call _fail_assertion
.jump15:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize a to 0
	mov rax, 0
	push rax
.jump16: ; Begin body of loop
	; Compare a to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jge .jump17 ; If a >= bound, break
.jump18:
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment a
	add qword [rsp + 0], 1
	jmp .jump16
.jump17: ; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	sub rax, r10
	push rax
	jmp .jump14
.jump13:
	sub rsp, 16
	; Moving 16 bytes from rbp - -16 to rsp
		mov r10, [rbp - -16 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	; Moving 16 bytes from rsp + 0 to rsp + 0
		mov r10, [rsp + 0 + 8]
		mov [rsp + 0 + 8], r10
		mov r10, [rsp + 0 + 0]
		mov [rsp + 0 + 0], r10
	add rsp, 0
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for a
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump19
	lea rdi, [rel const6] ; non-positive loop bound
	call _fail_assertion
.jump19:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize a to 0
	mov rax, 0
	push rax
.jump20: ; Begin body of loop
	; Compare a to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jge .jump21 ; If a >= bound, break
.jump22:
	; Compute loop body
	mov rax, [rel const7] ; 110
	push rax
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment a
	add qword [rsp + 0], 1
	jmp .jump20
.jump21: ; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump23
	sub rsp, 8 ; Align stack
	lea rdi, [rel const8] ; negative array index
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump23:
	cmp rax, [rsp + 8]
	jl .jump24
	sub rsp, 8 ; Align stack
	lea rdi, [rel const9] ; index too large
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump24:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	shl rax, 3
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp
		mov r10, [rax + 0]
		mov [rsp + 0], r10
.jump14:
	mov rax, [rsp]
	cmp rax, 0
	jg .jump25
	sub rsp, 8 ; Align stack
	lea rdi, [rel const6] ; non-positive loop bound
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump25:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof float
imul rdi, [rsp + 0 + 0] ; multiply by (if (if (if (! true) then (if true then false else true) else true) then ((sum[a : 526] 24.7) >= (if true then 70.89 else 43.23)) else ((true || false) == true)) then (argnum - (sum[a : argnum] argnum)) else {args}{0}[(sum[a : argnum] 110)])
	jno .jump26
	sub rsp, 8 ; Align stack
	lea rdi, [rel const10] ; overflow computing array size
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump26:
	sub rsp, 8 ; Align stack
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize a to 0
	mov rax, 0
	push rax
.jump27: ; Begin body of loop
	; Compare a to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jge .jump28 ; If a >= bound, break
.jump29:
	; Compute loop body
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for b
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump30
	lea rdi, [rel const6] ; non-positive loop bound
	call _fail_assertion
.jump30:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize b to 0
	mov rax, 0
	push rax
.jump31: ; Begin body of loop
	; Compare b to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jge .jump32 ; If b >= bound, break
.jump33:
	; Compute loop body
	mov rax, [rel const11] ; 88.36
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp + 16] ; Load sum
	addsd xmm0, xmm1 ; Add loop body
	movsd [rsp + 16], xmm0 ; Save sum
	; Increment b
	add qword [rsp + 0], 1
	jmp .jump31
.jump32: ; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	mov rdi, 8
	sub rsp, 8 ; Align stack
	call _jpl_alloc
	add rsp, 8 ; Remove alignment
	; Moving 8 bytes from rsp to rax
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	push rax
	mov rax, 1
	push rax
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for b
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for b
	sub rsp, 8
	; Moving 8 bytes from rbp - 32 to rsp
		mov r10, [rbp - 32 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump34
	sub rsp, 8 ; Align stack
	lea rdi, [rel const6] ; non-positive loop bound
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump34:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize b to 0
	mov rax, 0
	push rax
.jump35: ; Begin body of loop
	; Compare b to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jge .jump36 ; If b >= bound, break
.jump37:
	; Compute loop body
	mov rax, [rel const12] ; 342
	push rax
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment b
	add qword [rsp + 0], 1
	jmp .jump35
.jump36: ; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump38
	lea rdi, [rel const6] ; non-positive loop bound
	call _fail_assertion
.jump38:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize b to 0
	mov rax, 0
	push rax
.jump39: ; Begin body of loop
	; Compare b to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jge .jump40 ; If b >= bound, break
.jump41:
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	add rax, r10
	push rax
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment b
	add qword [rsp + 0], 1
	jmp .jump39
.jump40: ; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump42
	sub rsp, 8 ; Align stack
	lea rdi, [rel const8] ; negative array index
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump42:
	cmp rax, [rsp + 8]
	jl .jump43
	sub rsp, 8 ; Align stack
	lea rdi, [rel const9] ; index too large
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump43:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	shl rax, 3
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rel const13] ; 4.73
	push rax
	; Moving 8 bytes from rsp + 0 to rsp + 0
		mov r10, [rsp + 0 + 0]
		mov [rsp + 0 + 0], r10
	add rsp, 0
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	addsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	shl rax, 3
	add rax, [rsp + 24]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment a
	add qword [rsp + 0], 1
	jmp .jump27
.jump28: ; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	mov rax, [rel const0] ; True
	push rax
	pop rax
	xor rax, 1
	push rax
	mov rdi, 8
	call _jpl_alloc
	; Moving 8 bytes from rsp to rax
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	push rax
	mov rax, 1
	push rax
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for c
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for c
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump44
	lea rdi, [rel const6] ; non-positive loop bound
	call _fail_assertion
.jump44:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize c to 0
	mov rax, 0
	push rax
.jump45: ; Begin body of loop
	; Compare c to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jge .jump46 ; If c >= bound, break
.jump47:
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment c
	add qword [rsp + 0], 1
	jmp .jump45
.jump46: ; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	mov rax, [rsp]
	cmp rax, 0
	jg .jump48
	sub rsp, 8 ; Align stack
	lea rdi, [rel const6] ; non-positive loop bound
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump48:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize c to 0
	mov rax, 0
	push rax
.jump49: ; Begin body of loop
	; Compare c to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jge .jump50 ; If c >= bound, break
.jump51:
	; Compute loop body
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for d
	sub rsp, 8
	; Moving 8 bytes from rbp - 64 to rsp
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump52
	lea rdi, [rel const6] ; non-positive loop bound
	call _fail_assertion
.jump52:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize d to 0
	mov rax, 0
	push rax
.jump53: ; Begin body of loop
	; Compare d to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jge .jump54 ; If d >= bound, break
.jump55:
	; Compute loop body
	mov rax, [rel const14] ; 203
	push rax
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment d
	add qword [rsp + 0], 1
	jmp .jump53
.jump54: ; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment c
	add qword [rsp + 0], 1
	jmp .jump49
.jump50: ; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump56
	lea rdi, [rel const8] ; negative array index
	call _fail_assertion
.jump56:
	cmp rax, [rsp + 8]
	jl .jump57
	lea rdi, [rel const9] ; index too large
	call _fail_assertion
.jump57:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	shl rax, 3
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
	xor rax, 1
	push rax
	pop rax
	xor rax, 1
	push rax
	lea rdi, [rel const15] ; (BoolType)
	lea rsi, [rsp]
	call _show
	add rsp, 8
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for c
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for c
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump58
	lea rdi, [rel const6] ; non-positive loop bound
	call _fail_assertion
.jump58:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof bool
	imul rdi, [rsp + 0 + 0] ; multiply by b
	jno .jump59
	lea rdi, [rel const10] ; overflow computing array size
	call _fail_assertion
.jump59:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize c to 0
	mov rax, 0
	push rax
.jump60: ; Begin body of loop
	; Compare c to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jge .jump61 ; If c >= bound, break
.jump62:
	; Compute loop body
	mov rax, [rel const1] ; False
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	shl rax, 3
	add rax, [rsp + 24]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment c
	add qword [rsp + 0], 1
	jmp .jump60
.jump61: ; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for c
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump63
	lea rdi, [rel const6] ; non-positive loop bound
	call _fail_assertion
.jump63:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize c to 0
	mov rax, 0
	push rax
.jump64: ; Begin body of loop
	; Compare c to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jge .jump65 ; If c >= bound, break
.jump66:
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment c
	add qword [rsp + 0], 1
	jmp .jump64
.jump65: ; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump67
	sub rsp, 8 ; Align stack
	lea rdi, [rel const8] ; negative array index
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump67:
	cmp rax, [rsp + 8]
	jl .jump68
	sub rsp, 8 ; Align stack
	lea rdi, [rel const9] ; index too large
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump68:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	shl rax, 3
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	pop rax
	cmp rax, 0
	je .jump69
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for c
	sub rsp, 16
	; Moving 16 bytes from rbp - -16 to rsp
		mov r10, [rbp - -16 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const16] ; 316
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump71
	lea rdi, [rel const8] ; negative array index
	call _fail_assertion
.jump71:
	cmp rax, [rsp + 8]
	jl .jump72
	lea rdi, [rel const9] ; index too large
	call _fail_assertion
.jump72:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	shl rax, 3
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump73
	lea rdi, [rel const6] ; non-positive loop bound
	call _fail_assertion
.jump73:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize c to 0
	mov rax, 0
	push rax
.jump74: ; Begin body of loop
	; Compare c to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jge .jump75 ; If c >= bound, break
.jump76:
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment c
	add qword [rsp + 0], 1
	jmp .jump74
.jump75: ; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	jmp .jump70
.jump69:
	mov rax, [rel const1] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump77
	mov rax, [rel const1] ; False
	push rax
	jmp .jump78
.jump77:
	mov rax, [rel const1] ; False
	push rax
.jump78:
	pop rax
	cmp rax, 0
	je .jump79
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for c
	mov rax, [rel const17] ; 635
	push rax
	mov rax, [rsp]
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize c to 0
	mov rax, 0
	push rax
.jump81: ; Begin body of loop
	; Compare c to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jge .jump82 ; If c >= bound, break
.jump83:
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment c
	add qword [rsp + 0], 1
	jmp .jump81
.jump82: ; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	jmp .jump80
.jump79:
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for c
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump84
	lea rdi, [rel const6] ; non-positive loop bound
	call _fail_assertion
.jump84:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize c to 0
	mov rax, 0
	push rax
.jump85: ; Begin body of loop
	; Compare c to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jge .jump86 ; If c >= bound, break
.jump87:
	; Compute loop body
	mov rax, [rel const18] ; 666
	push rax
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment c
	add qword [rsp + 0], 1
	jmp .jump85
.jump86: ; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
.jump80:
.jump70:
	pop rax
	neg rax
	push rax
	mov rax, [rsp]
	cmp rax, 0
	jg .jump88
	sub rsp, 8 ; Align stack
	lea rdi, [rel const6] ; non-positive loop bound
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump88:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof int
imul rdi, [rsp + 0 + 0] ; multiply by (- (if (array[c : b] false)[(sum[c : argnum] argnum)] then (sum[c : args[316]] argnum) else (if (if false then false else false) then (sum[c : 635] argnum) else (sum[c : b] 666))))
	jno .jump89
	sub rsp, 8 ; Align stack
	lea rdi, [rel const10] ; overflow computing array size
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump89:
	sub rsp, 8 ; Align stack
	call _jpl_alloc ; Put pointer to heap space in RAX
	add rsp, 8 ; Remove alignment
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize c to 0
	mov rax, 0
	push rax
.jump90: ; Begin body of loop
	; Compare c to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jge .jump91 ; If c >= bound, break
.jump92:
	; Compute loop body
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for d
	sub rsp, 8
	; Moving 8 bytes from rbp - 48 to rsp
		mov r10, [rbp - 48 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump93
	lea rdi, [rel const6] ; non-positive loop bound
	call _fail_assertion
.jump93:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize d to 0
	mov rax, 0
	push rax
.jump94: ; Begin body of loop
	; Compare d to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jge .jump95 ; If d >= bound, break
.jump96:
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment d
	add qword [rsp + 0], 1
	jmp .jump94
.jump95: ; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	pop rax
	neg rax
	push rax
	mov rax, [rel const19] ; 408
	push rax
	pop rax
	neg rax
	push rax
	pop rax
	pop r10
	cmp r10, 0
	jne .jump97
	lea rdi, [rel const20] ; mod by zero
	call _fail_assertion
.jump97:
	cqo
	idiv r10
	mov rax, rdx
	push rax
	pop rax
	neg rax
	push rax
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	shl rax, 3
	add rax, [rsp + 24]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment c
	add qword [rsp + 0], 1
	jmp .jump90
.jump91: ; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	sub rsp, 16
	; Moving 16 bytes from rbp - 40 to rsp
		mov r10, [rbp - 40 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	; Moving 16 bytes from rsp + 0 to rsp + 0
		mov r10, [rsp + 0 + 8]
		mov [rsp + 0 + 8], r10
		mov r10, [rsp + 0 + 0]
		mov [rsp + 0 + 0], r10
	add rsp, 0
	; Moving 16 bytes from rsp + 0 to rsp + 0
		mov r10, [rsp + 0 + 8]
		mov [rsp + 0 + 8], r10
		mov r10, [rsp + 0 + 0]
		mov [rsp + 0 + 0], r10
	add rsp, 0
	mov rax, [rel const0] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump98
	mov rax, [rel const1] ; False
	push rax
	; Moving 8 bytes from rsp + 0 to rsp + 0
		mov r10, [rsp + 0 + 0]
		mov [rsp + 0 + 0], r10
	add rsp, 0
	pop rax
	cmp rax, 0
	je .jump100
	mov rax, [rel const1] ; False
	push rax
	pop rax
	cmp rax, 0
	je .jump102
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	jmp .jump103
.jump102:
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
.jump103:
	jmp .jump101
.jump100:
	sub rsp, 16
	; Moving 16 bytes from rbp - 40 to rsp
		mov r10, [rbp - 40 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 40 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump104
	lea rdi, [rel const8] ; negative array index
	call _fail_assertion
.jump104:
	cmp rax, [rsp + 8]
	jl .jump105
	lea rdi, [rel const9] ; index too large
	call _fail_assertion
.jump105:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	shl rax, 3
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp
		mov r10, [rax + 0]
		mov [rsp + 0], r10
.jump101:
	jmp .jump99
.jump98:
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	mov rdi, 8
	call _jpl_alloc
	; Moving 8 bytes from rsp to rax
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	push rax
	mov rax, 1
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	pop rax
	pop r10
	imul rax, r10
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump106
	lea rdi, [rel const8] ; negative array index
	call _fail_assertion
.jump106:
	cmp rax, [rsp + 8]
	jl .jump107
	lea rdi, [rel const9] ; index too large
	call _fail_assertion
.jump107:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	shl rax, 3
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp
		mov r10, [rax + 0]
		mov [rsp + 0], r10
.jump99:
	; Allocating 8 bytes for the pointer
	sub rsp, 8
	; Computing bound for g
	sub rsp, 8
	; Moving 8 bytes from rbp - 64 to rsp
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump108
	lea rdi, [rel const6] ; non-positive loop bound
	call _fail_assertion
.jump108:
	; Computing total size of heap memory to allocate
	mov rdi, 8 ; sizeof float
	imul rdi, [rsp + 0 + 0] ; multiply by f
	jno .jump109
	lea rdi, [rel const10] ; overflow computing array size
	call _fail_assertion
.jump109:
	call _jpl_alloc ; Put pointer to heap space in RAX
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize g to 0
	mov rax, 0
	push rax
.jump110: ; Begin body of loop
	; Compare g to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jge .jump111 ; If g >= bound, break
.jump112:
	; Compute loop body
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for h
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump113
	sub rsp, 8 ; Align stack
	lea rdi, [rel const6] ; non-positive loop bound
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump113:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize h to 0
	mov rax, 0
	push rax
.jump114: ; Begin body of loop
	; Compare h to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jge .jump115 ; If h >= bound, break
.jump116:
	; Compute loop body
	mov rax, [rel const21] ; 1.29
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp + 16] ; Load sum
	addsd xmm0, xmm1 ; Add loop body
	movsd [rsp + 16], xmm0 ; Save sum
	; Increment h
	add qword [rsp + 0], 1
	jmp .jump114
.jump115: ; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	; Index to store in
	mov rax, 0
	imul rax, [rsp + 16] ; No overflow if indices in bounds
	add rax, [rsp + 8]
	shl rax, 3
	add rax, [rsp + 24]
	; Move body (8 bytes) to index
	; Moving 8 bytes from rsp to rax
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	; Increment g
	add qword [rsp + 0], 1
	jmp .jump110
.jump111: ; End body of loop
	; Free all loop variables
	add rsp, 8
	; array left on stack
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump117
	sub rsp, 8 ; Align stack
	lea rdi, [rel const8] ; negative array index
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump117:
	cmp rax, [rsp + 8]
	jl .jump118
	sub rsp, 8 ; Align stack
	lea rdi, [rel const9] ; index too large
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump118:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	shl rax, 3
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	sub rsp, 16
	; Moving 16 bytes from rbp - 24 to rsp
		mov r10, [rbp - 24 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	; Moving 16 bytes from rsp + 0 to rsp + 0
		mov r10, [rsp + 0 + 8]
		mov [rsp + 0 + 8], r10
		mov r10, [rsp + 0 + 0]
		mov [rsp + 0 + 0], r10
	add rsp, 0
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for g
	sub rsp, 8
	; Moving 8 bytes from rbp - -16 to rsp
		mov r10, [rbp - -16 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump119
	sub rsp, 8 ; Align stack
	lea rdi, [rel const6] ; non-positive loop bound
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump119:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize g to 0
	mov rax, 0
	push rax
.jump120: ; Begin body of loop
	; Compare g to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jge .jump121 ; If g >= bound, break
.jump122:
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 24 to rsp
		mov r10, [rbp - 24 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment g
	add qword [rsp + 0], 1
	jmp .jump120
.jump121: ; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	mov rax, [rel const22] ; 361
	push rax
	pop rax
	neg rax
	push rax
	pop rax
	pop r10
	cmp r10, 0
	jne .jump123
	sub rsp, 8 ; Align stack
	lea rdi, [rel const20] ; mod by zero
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump123:
	cqo
	idiv r10
	mov rax, rdx
	push rax
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump124
	lea rdi, [rel const8] ; negative array index
	call _fail_assertion
.jump124:
	cmp rax, [rsp + 8]
	jl .jump125
	lea rdi, [rel const9] ; index too large
	call _fail_assertion
.jump125:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	shl rax, 3
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	cmpeqsd xmm0, xmm1
	movq rax, xmm0
	and rax, 1
	push rax
	pop rax
	cmp rax, 0
	je .jump126
	mov rax, [rel const23] ; 711
	push rax
	pop rax
	neg rax
	push rax
	mov rdi, 8
	sub rsp, 8 ; Align stack
	call _jpl_alloc
	add rsp, 8 ; Remove alignment
	; Moving 8 bytes from rsp to rax
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	push rax
	mov rax, 1
	push rax
	; Allocating 8 bytes for the sum
	sub rsp, 8
	; Computing bound for g
	sub rsp, 8
	; Moving 8 bytes from rbp - 64 to rsp
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp]
	cmp rax, 0
	jg .jump128
	lea rdi, [rel const6] ; non-positive loop bound
	call _fail_assertion
.jump128:
	; Initialize sum to 0
	mov rax, 0
	mov [rsp + 8], rax ; Move to pre-allocated space
	; Initialize g to 0
	mov rax, 0
	push rax
.jump129: ; Begin body of loop
	; Compare g to its bound
	mov rax, [rsp + 0]
	cmp rax, [rsp + 8]
	jge .jump130 ; If g >= bound, break
.jump131:
	; Compute loop body
	sub rsp, 8
	; Moving 8 bytes from rbp - 104 to rsp
		mov r10, [rbp - 104 + 0]
		mov [rsp + 0], r10
	pop rax
	add [rsp + 16], rax ; Add loop body to sum
	; Increment g
	add qword [rsp + 0], 1
	jmp .jump129
.jump130: ; End body of loop
	; Free all loop variables
	add rsp, 8
	; Free all loop bounds
	add rsp, 8
	; sum left on stack
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump132
	sub rsp, 8 ; Align stack
	lea rdi, [rel const8] ; negative array index
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump132:
	cmp rax, [rsp + 8]
	jl .jump133
	sub rsp, 8 ; Align stack
	lea rdi, [rel const9] ; index too large
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump133:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	shl rax, 3
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	jmp .jump127
.jump126:
	mov rax, [rel const0] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump134
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	mov rdi, 8
	sub rsp, 8 ; Align stack
	call _jpl_alloc
	add rsp, 8 ; Remove alignment
	; Moving 8 bytes from rsp to rax
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	push rax
	mov rax, 1
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 64 to rsp
		mov r10, [rbp - 64 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump136
	sub rsp, 8 ; Align stack
	lea rdi, [rel const8] ; negative array index
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump136:
	cmp rax, [rsp + 8]
	jl .jump137
	sub rsp, 8 ; Align stack
	lea rdi, [rel const9] ; index too large
	call _fail_assertion
	add rsp, 8 ; Remove alignment
.jump137:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	shl rax, 3
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	jmp .jump135
.jump134:
	sub rsp, 8
	; Moving 8 bytes from rbp - 56 to rsp
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
.jump135:
.jump127:
	mov rax, [rel const24] ; 20.09
	push rax
	mov rax, [rel const25] ; 72.98
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	call _fmod
	sub rsp, 8
	movsd [rsp], xmm0
	mov rax, [rel const26] ; 82.19
	push rax
	movsd xmm0, [rsp]
	add rsp, 8
	movsd xmm1, [rsp]
	add rsp, 8
	addsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	mov rdi, 8
	call _jpl_alloc
	; Moving 8 bytes from rsp to rax
		mov r10, [rsp + 0]
		mov [rax + 0], r10
	add rsp, 8
	push rax
	mov rax, 1
	push rax
	sub rsp, 8
	; Moving 8 bytes from rbp - 72 to rsp
		mov r10, [rbp - 72 + 0]
		mov [rsp + 0], r10
	mov rax, [rsp + 0]
	cmp rax, 0
	jge .jump138
	lea rdi, [rel const8] ; negative array index
	call _fail_assertion
.jump138:
	cmp rax, [rsp + 8]
	jl .jump139
	lea rdi, [rel const9] ; index too large
	call _fail_assertion
.jump139:
	mov rax, 0
	imul rax, [rsp + 8] ; No overflow if indices in bounds
	add rax, [rsp + 0]
	shl rax, 3
	add rax, [rsp + 16]
	add rsp, 8
	add rsp, 16
	sub rsp, 8
	; Moving 8 bytes from rax to rsp
		mov r10, [rax + 0]
		mov [rsp + 0], r10
	movsd xmm1, [rsp]
	add rsp, 8
	pxor xmm0, xmm0
	subsd xmm0, xmm1
	sub rsp, 8
	movsd [rsp], xmm0
	lea rdi, [rel const27] ; (FloatType)
	lea rsi, [rsp]
	call _show
	add rsp, 8
	sub rsp, 24
	lea rdi, [rsp]
	lea rsi, [rel const28] ; h.png
	call _read_image
	mov rax, [rel const29] ; 442
	push rax
	sub rsp, 16
	; Moving 16 bytes from rbp - 56 to rsp
		mov r10, [rbp - 56 + 8]
		mov [rsp + 8], r10
		mov r10, [rbp - 56 + 0]
		mov [rsp + 0], r10
	mov rax, [rel const30] ; 962
	push rax
	lea rdi, [rel const31] ; (IntType)
	lea rsi, [rsp]
	call _show
	add rsp, 8
	mov rax, [rel const0] ; True
	push rax
	pop rax
	cmp rax, 0
	je .jump140
	jmp .jump141
.jump140:
.jump141:
	; Moving 0 bytes from rsp + 0 to rsp + 0
	add rsp, 0
	; Moving 0 bytes from rsp + 0 to rsp + 0
	add rsp, 0
	add rsp, 112 ; Local variables
	pop r12
	pop rbp
	ret

