fn a() : {int,int[,,],bool} {
  return a()
  let b[c, d] = (if (if {exp(42.86), (! true)}{1} then (if {false}{0} then (! (false || false)) else true) else (a(){0} < (- argnum))) then (if ((if true then (sum[b : argnum, c : 860] 68.96) else exp(37.65)) < asin(acos(78.89))) then {(array[b : argnum, c : 310] a())}{0} else (if ((! false) && (346 == 768)) then (if (if false then true else true) then (array[b : argnum, c : 960] a()) else (array[b : argnum, c : argnum] a())) else (if (! true) then (array[b : 562, c : argnum] a()) else (array[b : 698, c : 198] a())))) else (array[b : (if {true}{0} then (argnum - (sum[b : argnum, c : argnum] b)) else 364), c : (- 674)] {(sum[d : b] (212 % argnum)), (array[d : (b * 571), e : (sum[d : argnum] argnum), f : b] d), (false && (b != argnum))}))
  let e = ((array[e : d, f : (- d)] (array[g : 719, h : c] false))[998, c][{a(){2}, argnum, c}{2}, (if (! (c < c)) then c else (- (- argnum)))] && (if false then (! a(){2}) else (! (if (! false) then true else (821 != argnum)))))
  return {to_int(sin((- log(92.52)))), (array[f : (sum[f : c, g : (- argnum), h : argnum] 866), g : (c * (sum[f : c, g : argnum, h : c] g))] (array[h : argnum, i : g, j : (f / f)] i))[argnum, (array[f : 379, g : (d * d), h : a(){0}] (- 272))[(- argnum), (c * c), (d - 649)]], (e != true)}
  return {{a(), 673}}{0}{0}
}

let b[c, d, e] = (array[b : (array[b : to_int(25.89), c : argnum] ((sum[d : b] 189) - (argnum + b)))[(sum[b : to_int(log(21.94)), c : (if true then (786 - argnum) else to_int(35.38))] argnum), (if (! true) then argnum else argnum)], c : (if false then (sum[b : (sum[b : argnum, c : a(){0}, d : 567] c), c : (- args[argnum]), d : (605 - (- 18))] (if (b >= argnum) then b else d)) else (- (argnum % (sum[b : argnum, c : argnum, d : 310] 842)))), d : (array[b : 698, c : (506 % 684), d : to_int(92.22)] (array[e : c, f : d] c))[args[(469 % argnum)], {{}, 566}{1}, (if (argnum == 53) then argnum else argnum)][(if true then {argnum, 81} else {argnum, argnum}){1}, (- (- 512))]] sin((if ((false || false) || (! true)) then {false, 39.86, false}{1} else log((sum[e : argnum, f : b, g : b] 89.87)))))
let f = [d]
let g[h, i] = (array[g : 161, h : (array[g : (if true then d else d), h : (if (e <= e) then e else (e * c)), i : (sum[g : d, h : argnum, i : (d * argnum)] d)] 837)[(33 - (sum[g : (- c)] (sum[h : e, i : g] 821))), {(! false), e}{1}, (if true then (d * d) else (- 464))]] d)
let {j[k, l, m]} = {(array[j : e, k : (e + h)] (array[l : i, m : 216] b))[argnum, (if false then c else 339)][(- to_int(tan(8.94))), {g[c, c]}{0}]}
let {n[o, p, q], r, {s[t]}} = (if ((sum[n : k, o : h] 64.28) >= 13.98) then {{(array[n : d, o : argnum, p : l] l), (l / argnum), {f}}, (true && (false != true))} else {{(array[n : d, o : argnum, p : m] m), 447, {args}}, (k >= argnum)}){0}
let u[v, w] = (if (array[u : h, v : o] false)[i, 296] then (array[u : g[d, h], v : r] {g}) else (array[u : k, v : c] {g}))[(p - c), l]{0}
fn x({ y : {}[], { { z[A] : int[,,][] }, B : bool }, { C : {{bool,int},float[,,],int}, D[E, F, G] : {}[,][,,] } }, { { { H : float, { I : {float}, { { J[K] : bool[], L[M, N] : {int,float,bool}[,], O[P, Q, R] : {float,float,int}[,,] } } }, {  } }, S[T] : {{},bool}[], U : int }, { V : float }, W : bool }, {  }) : bool {
  let {} = (if (H < (if W then (if (t < i) then pow(V, 88.7) else to_float(r)) else sin(cos(H)))) then {} else (array[X : Q, Y : R] (array[Z : U, aa : G] {}))[argnum, argnum][m, R])
  return ((array[X : (sum[X : A, Y : F, Z : K] k)] (W || (923 <= E)))[E] || (W && (array[X : P, Y : (if B then T else r)] W)[127, v]))
  assert false, "X"
  let X = I
  return (if true then (((if (k != U) then R else argnum) < r) == (! ((- V) < H))) else B)
}

read image "y.png" to y

let {{}} = {h, (array[z : (sum[z : q] z), A : t, B : w] {{}})[(sum[z : (sum[z : t, A : e, B : p] i), A : l, B : h] d), m, p]}{1}
write image (if (h == o) then (if {k, (! true), n}{1} then y else (if {true, i}{0} then (array[z : m, A : i, B : r] y)[q, m, 643] else {y, b, c}{0})) else {a(), o, {y, s}}{2}{0}) to "z.png"

fn z({ A : int, { B : float, C[D, E] : int[,], { F : float } }, G[H, I] : {}[,] }, {  }, {  }) : float {
  let J = exp(B)
  let K = o
  let L = (! (if (false == ((false == true) == false)) then (o > h) else (! (exp(96.19) != 47.05))))
  assert (e >= A), "M"
  return pow(J, ((85.1 + tan(J)) * F))
}

