fn a(b : float) : {int} {
  return {{{53}}}{0}{0}
  let c = ({(- (- 106))}{0} <= argnum)
  let {} = {}
  let d[e] = args
  return {to_int((- acos(to_float(argnum))))}
}

let b[c] = args
let {} = {}
fn d(e : float, { f[g] : bool[] }) : float {
  let h[i] = {args}{0}
  return atan(cos(to_float((- g))))
  let j[k] = {{b}}{0}{0}
  assert ((acos(sqrt(atan(e))) != cos(98.7)) == (acos(log(sin(35.44))) < sin(acos(atan(41.72))))), "l"
  return pow(atan(acos(asin(pow(e, e)))), exp(sqrt(asin(to_float(k)))))
}

let e = a(asin(sqrt(asin(6.99)))){0}
fn f(g[h] : float[], i[j] : float[]) : int[] {
  return {{b}}{0}{0}
  return args
  return args
  return [((- c) - h)]
  return b
}

fn g() : bool {
  let h[i] = [((- tan(asin(88.93))) / exp(atan2(acos(72.27), (97.98 * 70.23))))]
  return false
  let j[k] = args
  let l = tan({10.79}{0})
  return {{(i <= argnum)}}{0}{0}
}

fn h() : {} {
  let i = tan(asin(exp(log(sin(16.51)))))
  assert (! g()), "j"
  let j[k] = args
  assert {{(! g())}}{0}{0}, "l"
  return {{}}{0}
}

type i = {}
let j = to_float(argnum)
print "k"

let {k} = {exp(sqrt((asin(81.21) % j)))}
