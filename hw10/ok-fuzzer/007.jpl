let a = pow(82.99, acos((atan(to_float(argnum)) * acos(cos(29.33)))))
fn b(c : bool) : int {
  return 971
  let d = asin(tan((- {a}{0})))
  let e[f] = args
  return (- f)
  return argnum
}

fn c() : float {
  let d[e] = [atan(tan(cos(a)))]
  return a
  return a
  assert (! (! (asin(to_float(argnum)) < sin(a)))), "f"
  return {a}{0}
}

fn d() : float {
  let e[f] = {{args}}{0}{0}
  let g[h] = args
  assert (! true), "i"
  let i[j] = g
  return acos(sqrt({exp(a)}{0}))
}

let e = (! (((- b(true)) + {706}{0}) <= (- (to_int(97.24) / (- argnum)))))
let {f} = {73.19}
let {g[h]} = {{{args}}{0}}{0}
fn i(j : bool, { k[l] : int[] }, m[n] : bool[]) : float {
  assert (! (b((n > h)) <= to_int(sqrt(f)))), "o"
  let {} = {{{}}}{0}{0}
  let {o} = {args}
  let {p[q]} = {o}
  return (- exp(sin(to_float(argnum))))
}

fn j(k : bool, l : float, m : bool) : {}[] {
  let n[o] = [to_int(acos(sin(c())))]
  assert {e}{0}, "p"
  let p[q] = args
  let r = args
  return {[{{}}{0}]}{0}
}

time let k = f

fn l({  }, { {  } }, m[n] : bool[]) : float {
  assert e, "o"
  let o = to_int(pow(atan(d()), a))
  assert e, "p"
  assert true, "p"
  return acos(atan(c()))
}

type m = bool
